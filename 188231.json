{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","commits":[{"id":"9818efa55563ddfecdecafbdd43f4bee9f252e7d","date":1364853872,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,boolean,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new ConfigSolrXml(loader, null, is, null, false, this);\n      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", null);\n\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"transientCacheSize\", Integer.MAX_VALUE);\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason\n    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....\n    try {\n      if (isXmlFile) {\n        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);\n        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);\n      } else {\n        cfg = new SolrProperties(this, loader, is, fileName);\n        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", null);\n\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n    \n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n    \n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cc2a5e90b34bfc6bb00b6261a7956c2c022c275","date":1364946285,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new ConfigSolrXml(loader, null, is, null, false, this);\n      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", null);\n\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"transientCacheSize\", Integer.MAX_VALUE);\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new ConfigSolrXml(loader, null, is, null, false, this);\n      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", null);\n\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"transientCacheSize\", Integer.MAX_VALUE);\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      libLoader = SolrResourceLoader.createClassLoader(f, null);\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":["a837c064b67fa63a9394136e31218b908cdcf783","b24326411db492f92ea49f6fb947c90bc73cf19e","5ce60a6712f1e8ef7077bc4051aefc65f457f283"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e475642767c688ede5728d7918326f70b4e0bf3a","date":1366072489,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult. TODO: Remove this silly stuff for 5.0, persistence not supported.\n    try {\n      cfg = new ConfigSolrXml(loader, null, is, null, false, this);\n      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (! cfg.is50OrLater()) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, null);\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult\n    try {\n      cfg = new ConfigSolrXml(loader, null, is, null, false, this);\n      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.ConfLevel.SOLR, \"sharedLib\", null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.ConfLevel.SOLR_LOGGING, \"enabled\", true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING, \"class\", null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"size\", 50);\n          v.threshold = cfg.get(ConfigSolr.ConfLevel.SOLR_LOGGING_WATCHER, \"threshold\", null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n    \n    String dcoreName = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"defaultCoreName\", null);\n    if (dcoreName != null && !dcoreName.isEmpty()) {\n      defaultCoreName = dcoreName;\n    }\n    persistent = cfg.getBool(ConfigSolr.ConfLevel.SOLR, \"persistent\", false);\n    zkHost = cfg.get(ConfigSolr.ConfLevel.SOLR, \"zkHost\", null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.ConfLevel.SOLR, \"coreLoadThreads\", CORE_LOAD_THREADS);\n    \n    adminPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminPath\", null);\n    shareSchema = cfg.getBool(ConfigSolr.ConfLevel.SOLR_CORES, \"shareSchema\", DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"zkClientTimeout\", DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateConnTimeout\", 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"distribUpdateSoTimeout\", 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostPort\", null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"hostContext\", null);\n\n    host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"host\", null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"leaderVoteWait\", LEADER_VOTE_WAIT);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n    adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"adminHandler\", null);\n    managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, \"managementPath\", null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, \"transientCacheSize\", Integer.MAX_VALUE);\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3278df77f7f499b55fdb79861c0641450444e7d0","date":1366238988,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult. TODO: Remove this silly stuff for 5.0, persistence not supported.\n    try {\n      cfg = new ConfigSolrXml(loader, null, is, null, false, this);\n      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (! cfg.is50OrLater()) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult. TODO: Remove this silly stuff for 5.0, persistence not supported.\n    try {\n      cfg = new ConfigSolrXml(loader, null, is, null, false, this);\n      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (! cfg.is50OrLater()) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, null);\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(cfg, DEFAULT_HOST_CONTEXT);\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7c73b6560033b6dcc828fbcc94ba9315c20f3c0","date":1366659310,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    //ConfigSolr cfg;\n    \n    // keep orig config for persist to consult. TODO: Remove this silly stuff for 5.0, persistence not supported.\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n      this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    ConfigSolr cfg;\n    \n    // keep orig config for persist to consult. TODO: Remove this silly stuff for 5.0, persistence not supported.\n    try {\n      cfg = new ConfigSolrXml(loader, null, is, null, false, this);\n      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = cfg.initShardHandler();\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (! cfg.is50OrLater()) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f225b9b576dc345ee8c27f91147b4afc0350511c","f225b9b576dc345ee8c27f91147b4afc0350511c","f225b9b576dc345ee8c27f91147b4afc0350511c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9409650933cc688e77e565092a25e58adfc2e18d","date":1366663164,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    //ConfigSolr cfg;\n    \n    // keep orig config for persist to consult. TODO: Remove this silly stuff for 5.0, persistence not supported.\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n      this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    //ConfigSolr cfg;\n    \n    // keep orig config for persist to consult. TODO: Remove this silly stuff for 5.0, persistence not supported.\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n      this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    coreMaps.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            coreMaps.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              coreMaps.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, coreMaps, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b29abed5661c7911e4b45d5a3d79a186268e28c4","date":1366675770,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    //ConfigSolr cfg;\n    \n    // keep orig config for persist to consult. TODO: Remove this silly stuff for 5.0, persistence not supported.\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n      this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    initZooKeeper(zkHost, zkClientTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkController != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85a757d77b8686d261b25acf542b0037bf65d8fa","date":1367436352,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    // Initialize Logging\n    if (cfg.getBool(ConfigSolr.CfgProp.SOLR_LOGGING_ENABLED, true)) {\n      String slf4jImpl = null;\n      String fname = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_CLASS, null);\n      try {\n        slf4jImpl = StaticLoggerBinder.getSingleton()\n            .getLoggerFactoryClassStr();\n        if (fname == null) {\n          if (slf4jImpl.indexOf(\"Log4j\") > 0) {\n            fname = \"Log4j\";\n          } else if (slf4jImpl.indexOf(\"JDK\") > 0) {\n            fname = \"JUL\";\n          }\n        }\n      } catch (Throwable ex) {\n        log.warn(\"Unable to read SLF4J version.  LogWatcher will be disabled: \" + ex);\n      }\n      \n      // Now load the framework\n      if (fname != null) {\n        if (\"JUL\".equalsIgnoreCase(fname)) {\n          logging = new JulWatcher(slf4jImpl);\n        }\n        else if( \"Log4j\".equals(fname) ) {\n          logging = new Log4jWatcher(slf4jImpl);\n        } else {\n          try {\n            logging = loader.newInstance(fname, LogWatcher.class);\n          } catch (Throwable e) {\n            log.warn(\"Unable to load LogWatcher\", e);\n          }\n        }\n        \n        if (logging != null) {\n          ListenerConfig v = new ListenerConfig();\n          v.size = cfg.getInt(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_SIZE, 50);\n          v.threshold = cfg.get(ConfigSolr.CfgProp.SOLR_LOGGING_WATCHER_THRESHOLD, null);\n          if (v.size > 0) {\n            log.info(\"Registering Log Listener\");\n            logging.registerListener(v, this);\n          }\n        }\n      }\n    }\n\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5268b3b46fa91a88e4d8fdd00f16f42577e6da11","date":1368012863,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f5d1cc8d16a148260af030c38f50f1873f02e11d","date":1368062450,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1","date":1369336666,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce","date":1370818281,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dc6e48afbb50ae0a22fa76e226f04fd585532938","date":1371429211,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n\n          if (p.isTransient() || ! p.isLoadOnStartup()) {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n\n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d264f386d864b5751209060e8886ca9845f70469","date":1372172126,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load the cores defined for this CoreContainer\n   */\n  public void load()  {\n\n    log.info(\"Loading cores into CoreContainer {}\", System.identityHashCode(this));\n\n    ThreadPoolExecutor coreLoadExecutor = null;\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(solrHome), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n\n          if (p.isTransient() || ! p.isLoadOnStartup()) {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n\n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n\n          if (p.isTransient() || ! p.isLoadOnStartup()) {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n\n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"354983dcdf70c800bf2573d10b54a7391b1dc167","date":1372183171,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load().mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n\n          if (p.isTransient() || ! p.isLoadOnStartup()) {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n\n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load the cores defined for this CoreContainer\n   */\n  public void load()  {\n\n    log.info(\"Loading cores into CoreContainer {}\", System.identityHashCode(this));\n\n    ThreadPoolExecutor coreLoadExecutor = null;\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(solrHome), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n\n          if (p.isTransient() || ! p.isLoadOnStartup()) {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n\n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    boolean genericCoreNodeNames = cfg.getBool(ConfigSolr.CfgProp.SOLR_GENERICCORENODENAMES, false);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, genericCoreNodeNames, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n\n          if (p.isTransient() || ! p.isLoadOnStartup()) {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n\n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n\n          if (p.isTransient() || ! p.isLoadOnStartup()) {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n\n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7116474e2e390259937401cf928323e0cbc75e60","date":1372780249,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#load().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":"  /**\n   * Load the cores defined for this CoreContainer\n   */\n  public void load()  {\n\n    log.info(\"Loading cores into CoreContainer [instanceDir={}]\", loader.getInstanceDir());\n\n    ThreadPoolExecutor coreLoadExecutor = null;\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(solrHome), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    boolean genericCoreNodeNames = cfg.getBool(ConfigSolr.CfgProp.SOLR_GENERICCORENODENAMES, false);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, genericCoreNodeNames, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n\n          if (p.isTransient() || ! p.isLoadOnStartup()) {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n\n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    boolean genericCoreNodeNames = cfg.getBool(ConfigSolr.CfgProp.SOLR_GENERICCORENODENAMES, false);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, genericCoreNodeNames, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n\n          if (p.isTransient() || ! p.isLoadOnStartup()) {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n\n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":4,"author":"Han Jiang","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#load(String,InputStream,String).mjava","sourceNew":null,"sourceOld":"  /**\n   * Load a config file listing the available solr cores.\n   * \n   * @param dir the home directory of all resources.\n   * @param is the configuration file InputStream. May be a properties file or an xml file\n   */\n\n  // Let's keep this ugly boolean out of public circulation.\n  protected void load(String dir, InputStream is, String fileName)  {\n    ThreadPoolExecutor coreLoadExecutor = null;\n    if (null == dir) {\n      // don't rely on SolrResourceLoader(), determine explicitly first\n      dir = SolrResourceLoader.locateSolrHome();\n    }\n    log.info(\"Loading CoreContainer using Solr Home: '{}'\", dir);\n    \n    this.loader = new SolrResourceLoader(dir);\n    solrHome = loader.getInstanceDir();\n\n    try {\n      Config config = new Config(loader, null, new InputSource(is), null, false);\n\n      // old style defines cores in solr.xml, new style disovers them by \n      // directory structure\n      boolean oldStyle = (config.getNode(\"solr/cores\", false) != null);\n      \n      if (oldStyle) {\n        // ConfigSolr handles keep orig values around for non solrcore level items,\n        // but this is still how original core lvl attributes are kept around\n        this.origCfg = new Config(loader, null, copyDoc(config.getDocument()));\n        \n        this.cfg = new ConfigSolrXmlOld(config, this);\n      } else {\n        this.cfg = new ConfigSolrXml(config, this);\n\n      }\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"\", e);\n    }\n    // Since the cores var is now initialized to null, let's set it up right\n    // now.\n    cfg.substituteProperties();\n\n    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n    libDir = cfg.get(ConfigSolr.CfgProp.SOLR_SHAREDLIB , null);\n    if (libDir != null) {\n      File f = FileUtils.resolvePath(new File(dir), libDir);\n      log.info(\"loading shared library: \" + f.getAbsolutePath());\n      loader.addToClassLoader(libDir, null, false);\n      loader.reloadLuceneSPI();\n    }\n\n    shardHandlerFactory = initShardHandler(cfg);\n\n    solrCores.allocateLazyCores(cfg, loader);\n\n    logging = JulWatcher.newRegisteredLogWatcher(cfg, loader);\n\n    if (cfg instanceof ConfigSolrXmlOld) { //TODO: Remove for 5.0\n      String dcoreName = cfg.get(ConfigSolr.CfgProp.SOLR_CORES_DEFAULT_CORE_NAME, null);\n      if (dcoreName != null && !dcoreName.isEmpty()) {\n        defaultCoreName = dcoreName;\n      }\n      persistent = cfg.getBool(ConfigSolr.CfgProp.SOLR_PERSISTENT, false);\n      adminPath = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINPATH, \"/admin/cores\");\n    } else {\n      adminPath = \"/admin/cores\";\n      defaultCoreName = DEFAULT_DEFAULT_CORE_NAME;\n    }\n    zkHost = cfg.get(ConfigSolr.CfgProp.SOLR_ZKHOST, null);\n    coreLoadThreads = cfg.getInt(ConfigSolr.CfgProp.SOLR_CORELOADTHREADS, CORE_LOAD_THREADS);\n    \n\n    shareSchema = cfg.getBool(ConfigSolr.CfgProp.SOLR_SHARESCHEMA, DEFAULT_SHARE_SCHEMA);\n    zkClientTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_ZKCLIENTTIMEOUT, DEFAULT_ZK_CLIENT_TIMEOUT);\n    \n    int distribUpdateConnTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATECONNTIMEOUT, 0);\n    int distribUpdateSoTimeout = cfg.getInt(ConfigSolr.CfgProp.SOLR_DISTRIBUPDATESOTIMEOUT, 0);\n\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostPort = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTPORT, null);\n    // Note: initZooKeeper will apply hardcoded default if cloud mode\n    String hostContext = cfg.get(ConfigSolr.CfgProp.SOLR_HOSTCONTEXT, null);\n\n    String host = cfg.get(ConfigSolr.CfgProp.SOLR_HOST, null);\n    \n    String leaderVoteWait = cfg.get(ConfigSolr.CfgProp.SOLR_LEADERVOTEWAIT, LEADER_VOTE_WAIT);\n\n    adminHandler = cfg.get(ConfigSolr.CfgProp.SOLR_ADMINHANDLER, null);\n    managementPath = cfg.get(ConfigSolr.CfgProp.SOLR_MANAGEMENTPATH, null);\n\n    transientCacheSize = cfg.getInt(ConfigSolr.CfgProp.SOLR_TRANSIENTCACHESIZE, Integer.MAX_VALUE);\n\n    if (shareSchema) {\n      indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();\n    }\n\n    zkClientTimeout = Integer.parseInt(System.getProperty(\"zkClientTimeout\",\n        Integer.toString(zkClientTimeout)));\n    zkSys.initZooKeeper(this, solrHome, zkHost, zkClientTimeout, hostPort, hostContext, host, leaderVoteWait, distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    if (isZooKeeperAware() && coreLoadThreads <= 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"SolrCloud requires a value of at least 2 in solr.xml for coreLoadThreads\");\n    }\n    \n    if (adminPath != null) {\n      if (adminHandler == null) {\n        coreAdminHandler = new CoreAdminHandler(this);\n      } else {\n        coreAdminHandler = this.createMultiCoreHandler(adminHandler);\n      }\n    }\n    \n    collectionsHandler = new CollectionsHandler(this);\n    containerProperties = cfg.getSolrProperties(\"solr\");\n\n    // setup executor to load cores in parallel\n    coreLoadExecutor = new ThreadPoolExecutor(coreLoadThreads, coreLoadThreads, 1,\n        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),\n        new DefaultSolrThreadFactory(\"coreLoadExecutor\"));\n    try {\n      CompletionService<SolrCore> completionService = new ExecutorCompletionService<SolrCore>(\n          coreLoadExecutor);\n      Set<Future<SolrCore>> pending = new HashSet<Future<SolrCore>>();\n\n      List<String> allCores = cfg.getAllCoreNames();\n\n      for (String oneCoreName : allCores) {\n\n        try {\n          String rawName = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NAME, null);\n\n          if (null == rawName) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Each core in solr.xml must have a 'name'\");\n          }\n          final String name = rawName;\n          final CoreDescriptor p = new CoreDescriptor(this, name,\n              cfg.getProperty(oneCoreName, CoreDescriptor.CORE_INSTDIR, null));\n          \n          // deal with optional settings\n          String opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_CONFIG, null);\n          \n          if (opt != null) {\n            p.setConfigName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SCHEMA, null);\n          if (opt != null) {\n            p.setSchemaName(opt);\n          }\n          \n          if (zkSys.getZkController() != null) {\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_SHARD, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setShardId(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_COLLECTION, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setCollectionName(opt);\n            }\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_ROLES, null);\n            if (opt != null) {\n              p.getCloudDescriptor().setRoles(opt);\n            }\n\n            opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_NODE_NAME, null);\n            if (opt != null && opt.length() > 0) {\n              p.getCloudDescriptor().setCoreNodeName(opt);\n            }\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_PROPERTIES, null);\n          if (opt != null) {\n            p.setPropertiesName(opt);\n          }\n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_DATADIR, null);\n          if (opt != null) {\n            p.setDataDir(opt);\n          }\n          \n          p.setCoreProperties(cfg.readCoreProperties(oneCoreName));\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_LOADONSTARTUP, null);\n          if (opt != null) {\n            p.setLoadOnStartup((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          opt = cfg.getProperty(oneCoreName, CoreDescriptor.CORE_TRANSIENT, null);\n          if (opt != null) {\n            p.setTransient((\"true\".equalsIgnoreCase(opt) || \"on\"\n                .equalsIgnoreCase(opt)) ? true : false);\n          }\n          \n          if (p.isLoadOnStartup()) { // The normal case\n\n            Callable<SolrCore> task = new Callable<SolrCore>() {\n              @Override\n              public SolrCore call() {\n                SolrCore c = null;\n                try {\n                  if (zkSys.getZkController() != null) {\n                    preRegisterInZk(p);\n                  }\n                  c = create(p);\n                  registerCore(p.isTransient(), name, c, false);\n                } catch (Throwable t) {\n                  if (isZooKeeperAware()) {\n                    try {\n                      zkSys.zkController.unregister(name, p);\n                    } catch (InterruptedException e) {\n                      Thread.currentThread().interrupt();\n                      SolrException.log(log, null, e);\n                    } catch (KeeperException e) {\n                      SolrException.log(log, null, e);\n                    }\n                  }\n                  SolrException.log(log, null, t);\n                  if (c != null) {\n                    c.close();\n                  }\n                }\n                return c;\n              }\n            };\n            pending.add(completionService.submit(task));\n\n          } else {\n            // Store it away for later use. includes non-transient but not\n            // loaded at startup cores.\n            solrCores.putDynamicDescriptor(rawName, p);\n          }\n        } catch (Throwable ex) {\n          SolrException.log(log, null, ex);\n        }\n      }\n      \n      while (pending != null && pending.size() > 0) {\n        try {\n\n          Future<SolrCore> future = completionService.take();\n          if (future == null) return;\n          pending.remove(future);\n\n          try {\n            SolrCore c = future.get();\n            // track original names\n            if (c != null) {\n              solrCores.putCoreToOrigName(c, c.getName());\n            }\n          } catch (ExecutionException e) {\n            SolrException.log(SolrCore.log, \"Error loading core\", e);\n          }\n          \n        } catch (InterruptedException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"interrupted while loading core\", e);\n        }\n      }\n\n      // Start the background thread\n      backgroundCloser = new CloserThread(this, solrCores, cfg);\n      backgroundCloser.start();\n\n    } finally {\n      if (coreLoadExecutor != null) {\n        ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f5d1cc8d16a148260af030c38f50f1873f02e11d":["5268b3b46fa91a88e4d8fdd00f16f42577e6da11"],"7116474e2e390259937401cf928323e0cbc75e60":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce","7116474e2e390259937401cf928323e0cbc75e60"],"07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce":["36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1"],"4cc2a5e90b34bfc6bb00b6261a7956c2c022c275":["9818efa55563ddfecdecafbdd43f4bee9f252e7d"],"354983dcdf70c800bf2573d10b54a7391b1dc167":["d264f386d864b5751209060e8886ca9845f70469"],"e475642767c688ede5728d7918326f70b4e0bf3a":["4cc2a5e90b34bfc6bb00b6261a7956c2c022c275"],"36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1":["f5d1cc8d16a148260af030c38f50f1873f02e11d"],"d264f386d864b5751209060e8886ca9845f70469":["dc6e48afbb50ae0a22fa76e226f04fd585532938"],"c7c73b6560033b6dcc828fbcc94ba9315c20f3c0":["3278df77f7f499b55fdb79861c0641450444e7d0"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["354983dcdf70c800bf2573d10b54a7391b1dc167"],"9818efa55563ddfecdecafbdd43f4bee9f252e7d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5268b3b46fa91a88e4d8fdd00f16f42577e6da11":["85a757d77b8686d261b25acf542b0037bf65d8fa"],"dc6e48afbb50ae0a22fa76e226f04fd585532938":["07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce"],"b29abed5661c7911e4b45d5a3d79a186268e28c4":["9409650933cc688e77e565092a25e58adfc2e18d"],"9409650933cc688e77e565092a25e58adfc2e18d":["c7c73b6560033b6dcc828fbcc94ba9315c20f3c0"],"3278df77f7f499b55fdb79861c0641450444e7d0":["e475642767c688ede5728d7918326f70b4e0bf3a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"85a757d77b8686d261b25acf542b0037bf65d8fa":["b29abed5661c7911e4b45d5a3d79a186268e28c4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7116474e2e390259937401cf928323e0cbc75e60"]},"commit2Childs":{"f5d1cc8d16a148260af030c38f50f1873f02e11d":["36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1"],"7116474e2e390259937401cf928323e0cbc75e60":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce":["37a0f60745e53927c4c876cfe5b5a58170f0646c","dc6e48afbb50ae0a22fa76e226f04fd585532938"],"4cc2a5e90b34bfc6bb00b6261a7956c2c022c275":["e475642767c688ede5728d7918326f70b4e0bf3a"],"354983dcdf70c800bf2573d10b54a7391b1dc167":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"e475642767c688ede5728d7918326f70b4e0bf3a":["3278df77f7f499b55fdb79861c0641450444e7d0"],"36f2b01395ef2bc334ebf2f94f2fe44e0f2921b1":["07e5c48260f0b3abf6daef83f4ce8bd72b0be5ce"],"d264f386d864b5751209060e8886ca9845f70469":["354983dcdf70c800bf2573d10b54a7391b1dc167"],"c7c73b6560033b6dcc828fbcc94ba9315c20f3c0":["9409650933cc688e77e565092a25e58adfc2e18d"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["7116474e2e390259937401cf928323e0cbc75e60"],"9818efa55563ddfecdecafbdd43f4bee9f252e7d":["4cc2a5e90b34bfc6bb00b6261a7956c2c022c275"],"5268b3b46fa91a88e4d8fdd00f16f42577e6da11":["f5d1cc8d16a148260af030c38f50f1873f02e11d"],"dc6e48afbb50ae0a22fa76e226f04fd585532938":["d264f386d864b5751209060e8886ca9845f70469"],"b29abed5661c7911e4b45d5a3d79a186268e28c4":["85a757d77b8686d261b25acf542b0037bf65d8fa"],"9409650933cc688e77e565092a25e58adfc2e18d":["b29abed5661c7911e4b45d5a3d79a186268e28c4"],"3278df77f7f499b55fdb79861c0641450444e7d0":["c7c73b6560033b6dcc828fbcc94ba9315c20f3c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9818efa55563ddfecdecafbdd43f4bee9f252e7d"],"85a757d77b8686d261b25acf542b0037bf65d8fa":["5268b3b46fa91a88e4d8fdd00f16f42577e6da11"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}