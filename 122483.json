{"path":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","commits":[{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","pathOld":"/dev/null","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Refuse to import a segment that's too large\n      if (size >= maxMergeSize && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + size + \" vs max size \" + maxMergeSize + \")\");\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++)\n          anyTooLarge |= size(infos.info(i)) >= maxMergeSize;\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        }\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ded5d448578a903cd50db958f11addab67e51bf6","7ed80954d0e91206342729d058da7955cb93aa64","5b05dbf5e8a6920898fb3838ec15c9eb64bc01af","867c1d467255521b6a85a819a2097440670b7cc9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b05dbf5e8a6920898fb3838ec15c9eb64bc01af","date":1191617513,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Refuse to import a segment that's too large\n      if (info.docCount > maxMergeDocs && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + info.docCount + \" docs vs max docs \" + maxMergeDocs + \")\");\n\n      if (size >= maxMergeSize && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + size + \" vs max size \" + maxMergeSize + \")\");\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || info.docCount >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        }\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Refuse to import a segment that's too large\n      if (size >= maxMergeSize && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + size + \" vs max size \" + maxMergeSize + \")\");\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++)\n          anyTooLarge |= size(infos.info(i)) >= maxMergeSize;\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        }\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":["ded5d448578a903cd50db958f11addab67e51bf6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ed80954d0e91206342729d058da7955cb93aa64","date":1193061871,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    this.writer = writer;\n    message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Refuse to import a segment that's too large\n      if (info.docCount > maxMergeDocs && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + info.docCount + \" docs vs max docs \" + maxMergeDocs + \")\");\n\n      if (size >= maxMergeSize && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + size + \" vs max size \" + maxMergeSize + \")\");\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || info.docCount >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Refuse to import a segment that's too large\n      if (info.docCount > maxMergeDocs && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + info.docCount + \" docs vs max docs \" + maxMergeDocs + \")\");\n\n      if (size >= maxMergeSize && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + size + \" vs max size \" + maxMergeSize + \")\");\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || info.docCount >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        }\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ded5d448578a903cd50db958f11addab67e51bf6","date":1207033122,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    this.writer = writer;\n    message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || info.docCount >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    this.writer = writer;\n    message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Refuse to import a segment that's too large\n      if (info.docCount > maxMergeDocs && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + info.docCount + \" docs vs max docs \" + maxMergeDocs + \")\");\n\n      if (size >= maxMergeSize && info.dir != directory)\n        throw new IllegalArgumentException(\"Segment is too large (\" + size + \" vs max size \" + maxMergeSize + \")\");\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || info.docCount >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf","5b05dbf5e8a6920898fb3838ec15c9eb64bc01af"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2993c85d947e3191bba14229ea72fd5675d048e2","date":1228593940,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    this.writer = writer;\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || info.docCount >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    this.writer = writer;\n    message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || info.docCount >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9a4527f280143d14f0364f609f28965fc03a76e","date":1242489516,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    this.writer = writer;\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    this.writer = writer;\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Directory directory = writer.getDirectory();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || info.docCount >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"13eaef7d286f35b5c850a1c2eb7b337679aa6453","date":1249118545,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    this.writer = writer;\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ded5d448578a903cd50db958f11addab67e51bf6":["7ed80954d0e91206342729d058da7955cb93aa64"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7ed80954d0e91206342729d058da7955cb93aa64":["5b05dbf5e8a6920898fb3838ec15c9eb64bc01af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"13eaef7d286f35b5c850a1c2eb7b337679aa6453":["c9a4527f280143d14f0364f609f28965fc03a76e"],"c9a4527f280143d14f0364f609f28965fc03a76e":["2993c85d947e3191bba14229ea72fd5675d048e2"],"2993c85d947e3191bba14229ea72fd5675d048e2":["ded5d448578a903cd50db958f11addab67e51bf6"],"5b05dbf5e8a6920898fb3838ec15c9eb64bc01af":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["13eaef7d286f35b5c850a1c2eb7b337679aa6453"]},"commit2Childs":{"ded5d448578a903cd50db958f11addab67e51bf6":["2993c85d947e3191bba14229ea72fd5675d048e2"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["5b05dbf5e8a6920898fb3838ec15c9eb64bc01af"],"7ed80954d0e91206342729d058da7955cb93aa64":["ded5d448578a903cd50db958f11addab67e51bf6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"13eaef7d286f35b5c850a1c2eb7b337679aa6453":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c9a4527f280143d14f0364f609f28965fc03a76e":["13eaef7d286f35b5c850a1c2eb7b337679aa6453"],"5b05dbf5e8a6920898fb3838ec15c9eb64bc01af":["7ed80954d0e91206342729d058da7955cb93aa64"],"2993c85d947e3191bba14229ea72fd5675d048e2":["c9a4527f280143d14f0364f609f28965fc03a76e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}