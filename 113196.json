{"path":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica]).mjava","commits":[{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica]).mjava","pathOld":"/dev/null","sourceNew":"  void putNonLeadersIntoLowerTerm(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n    getProxyForReplica(leader).close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    sendDoc(2, null, leaderJetty);\n    \n    for (Replica replica : notLeaders) {\n      waitForState(collectionName, replica.getName(), State.DOWN, 60000);\n    }\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    leaderJetty.stop();\n\n    // Wait for a steady state, till the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (Replica replica : clusterState.getCollection(collectionName).getSlice(shard).getReplicas()) {\n        if (replica.getState() != State.DOWN) {\n          allDown = false;\n        }\n      }\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, shard, cloudClient.getZkStateReader().getZkClient())) {\n      for (Replica notLeader : notLeaders) {\n        assertTrue(zkShardTerms.getTerm(leader.getName()) > zkShardTerms.getTerm(notLeader.getName()));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23899910c6ea46c4aff96056cfae91d3e31b262a","date":1522788117,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica]).mjava","sourceNew":"  private void putNonLeadersIntoLowerTerm(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n    getProxyForReplica(leader).close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    sendDoc(2, null, leaderJetty);\n    \n    for (Replica replica : notLeaders) {\n      waitForState(collectionName, replica.getName(), State.DOWN, 60000);\n    }\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    leaderJetty.stop();\n\n    // Wait for a steady state, till the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (Replica replica : clusterState.getCollection(collectionName).getSlice(shard).getReplicas()) {\n        if (replica.getState() != State.DOWN) {\n          allDown = false;\n        }\n      }\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, shard, cloudClient.getZkStateReader().getZkClient())) {\n      for (Replica notLeader : notLeaders) {\n        assertTrue(zkShardTerms.getTerm(leader.getName()) > zkShardTerms.getTerm(notLeader.getName()));\n      }\n    }\n  }\n\n","sourceOld":"  void putNonLeadersIntoLowerTerm(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n    getProxyForReplica(leader).close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    sendDoc(2, null, leaderJetty);\n    \n    for (Replica replica : notLeaders) {\n      waitForState(collectionName, replica.getName(), State.DOWN, 60000);\n    }\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    leaderJetty.stop();\n\n    // Wait for a steady state, till the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (Replica replica : clusterState.getCollection(collectionName).getSlice(shard).getReplicas()) {\n        if (replica.getState() != State.DOWN) {\n          allDown = false;\n        }\n      }\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, shard, cloudClient.getZkStateReader().getZkClient())) {\n      for (Replica notLeader : notLeaders) {\n        assertTrue(zkShardTerms.getTerm(leader.getName()) > zkShardTerms.getTerm(notLeader.getName()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":5,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica],SolrClient).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica]).mjava","sourceNew":"  private void putNonLeadersIntoLowerTerm(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders, SolrClient solrClient) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n    getProxyForReplica(leader).close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    sendDoc(2, null, leaderJetty);\n    \n    for (Replica replica : notLeaders) {\n      waitForState(collectionName, replica.getName(), State.DOWN, 60000);\n    }\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    leaderJetty.stop();\n\n    // Wait for a steady state, till the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (Replica replica : clusterState.getCollection(collectionName).getSlice(shard).getReplicas()) {\n        if (replica.getState() != State.DOWN) {\n          allDown = false;\n        }\n      }\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, shard, cloudClient.getZkStateReader().getZkClient())) {\n      for (Replica notLeader : notLeaders) {\n        assertTrue(zkShardTerms.getTerm(leader.getName()) > zkShardTerms.getTerm(notLeader.getName()));\n      }\n    }\n  }\n\n","sourceOld":"  private void putNonLeadersIntoLowerTerm(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n    getProxyForReplica(leader).close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    sendDoc(2, null, leaderJetty);\n    \n    for (Replica replica : notLeaders) {\n      waitForState(collectionName, replica.getName(), State.DOWN, 60000);\n    }\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    leaderJetty.stop();\n\n    // Wait for a steady state, till the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (Replica replica : clusterState.getCollection(collectionName).getSlice(shard).getReplicas()) {\n        if (replica.getState() != State.DOWN) {\n          allDown = false;\n        }\n      }\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, shard, cloudClient.getZkStateReader().getZkClient())) {\n      for (Replica notLeader : notLeaders) {\n        assertTrue(zkShardTerms.getTerm(leader.getName()) > zkShardTerms.getTerm(notLeader.getName()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["23899910c6ea46c4aff96056cfae91d3e31b262a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"23899910c6ea46c4aff96056cfae91d3e31b262a":["84f20f331d8001864545c7021812d8c6509c7593"],"84f20f331d8001864545c7021812d8c6509c7593":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84f20f331d8001864545c7021812d8c6509c7593"],"23899910c6ea46c4aff96056cfae91d3e31b262a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"84f20f331d8001864545c7021812d8c6509c7593":["23899910c6ea46c4aff96056cfae91d3e31b262a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}