{"path":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof Fieldable) {\n      Fieldable f = (Fieldable)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof Fieldable) {\n      Fieldable f = (Fieldable)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof Fieldable) {\n      Fieldable f = (Fieldable)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof Fieldable) {\n      Fieldable f = (Fieldable)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof Fieldable) {\n      Fieldable f = (Fieldable)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof Fieldable) {\n      Fieldable f = (Fieldable)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof Fieldable) {\n      Fieldable f = (Fieldable)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14fd29e977ffb76db89d8ecd4fd70fbd9a51d390","date":1318552491,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      if( returnFields.getTransformer() != null ) {\n        returnFields.getTransformer().transform( doc, -1 );\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b68df8b95f3ea758a8dc21cb20a50a01db973e8e","date":1321650433,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      if( returnFields.getTransformer() != null ) {\n        returnFields.getTransformer().transform( doc, -1 );\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5892bdf887aeb6dcc06096dd9b4a7363513eff7","date":1327699677,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":["0c0e301b711811c6aaee90440cc1a7925fdd1a1e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7","date":1327763052,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Integer) {\n      writeInt(name, val.toString());\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Long) {\n      writeLong(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Float) {\n      // we pass the float instead of using toString() because\n      // it may need special formatting. same for double.\n      writeFloat(name, ((Float)val).floatValue());\n    } else if (val instanceof Double) {\n      writeDouble(name, ((Double)val).doubleValue());\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7e4907084808af8fdb14b9809e6dceaccf6867b","date":1343473006,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d028314cced5858683a1bb4741423d0f934257b","date":1346596535,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = toSolrDocument( (Document)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91814ce09be68efd0626969632e79ae47d8876d4","date":1425951537,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d12bbc45d641864ffe03291bc30f178eb34e434c","date":1426001646,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name,(Iterator)val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7a0594ac6740a20a5f8d6ab8d7d881f5283c61a","date":1429073859,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9","date":1434467834,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = DocsStreamer.getDoc((StoredDocument) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = toSolrDocument( (StoredDocument)val );\n      DocTransformer transformer = returnFields.getTransformer();\n      if( transformer != null ) {\n        TransformContext context = new TransformContext();\n        context.req = req;\n        transformer.setContext(context);\n        transformer.transform(doc, -1);\n      }\n      writeSolrDocument(name, doc, returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be73df8ac65c8f1ebef4eed2c0bd3a3b8167e235","date":1435150219,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = DocsStreamer.getDoc((StoredDocument) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      if (val instanceof Integer) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Long) {\n        writeLong(name, val.toString());\n      } else if (val instanceof Float) {\n        // we pass the float instead of using toString() because\n        // it may need special formatting. same for double.\n        writeFloat(name, ((Float)val).floatValue());\n      } else if (val instanceof Double) {\n        writeDouble(name, ((Double)val).doubleValue());        \n      } else if (val instanceof Short) {\n        writeInt(name, val.toString());\n      } else if (val instanceof Byte) {\n        writeInt(name, val.toString());\n      } else {\n        // default... for debugging only\n        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n      }\n    } else if (val instanceof Boolean) {\n      writeBool(name, val.toString());\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = DocsStreamer.getDoc((StoredDocument) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc","date":1440797084,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = DocsStreamer.getDoc((StoredDocument) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = DocsStreamer.getDoc((StoredDocument) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val, returnFields);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new ResultContext();\n      ctx.docs = (DocList)val;\n      writeDocuments(name, ctx, returnFields);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a626ec4d1c92e59fe390724d6220081047b03ce7","date":1448021525,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = DocsStreamer.getDoc((StoredDocument) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = DocsStreamer.getDoc((StoredDocument) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof StorableField) {\n      StorableField f = (StorableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof StoredDocument) {\n      SolrDocument doc = DocsStreamer.getDoc((StoredDocument) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e81b63c9ecb10b3cb98b3cc5e255b8d91021b941","date":1461079048,"type":3,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b71fe681187ac8552caaff9d5a7f1f3cac47b56","date":1461081992,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f1f31880696765d6aec499d3b01fa501129af45","date":1474287317,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new NamedList().asShallowMap()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new NamedList().asShallowMap()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new NamedList().asShallowMap()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val==null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a6fbf1484b3c2b38b75d59998de5fe4330b6b40","date":1478163495,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new NamedList().asShallowMap()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9720b151fde2073f4e401450f4574e5f31c2d0ff","date":1478184029,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof TupleStream) {\n      writeTupleStream((TupleStream) val);\n    } else if (val instanceof Explanation){\n      writeExplanation((Explanation) val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new NamedList().asShallowMap()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50f05d6b69cfaabd51b5d26cba4e3122f51fff83","date":1478603228,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number)val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean)val);\n    } else if (val instanceof Date) {\n      writeDate(name,(Date)val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc,returnFields, 0 );\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext)val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63a9344cff6a72bc4c1ef080c69e10ad0635b811","date":1490410892,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":["b5d3613911d665344055ef7970e1783b3348b5c0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de548de3ce5405595899f548152d4b93ac9eb9cc","date":1490594650,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a513b6a92751e54c76fb5447948c9e7d437163a7","date":1496136565,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74aea047dff7f7c38a2d766827bd20d356f98c6a","date":1496721416,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b5d3613911d665344055ef7970e1783b3348b5c0","date":1521487734,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a1c70b003d9abbd2ce7878bce14b6ec28fb05e4","date":1523635523,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n    //    (see a patch on LUCENE-3041 for inspiration)\n\n    // go in order of most common to least common, however some of the more general types like Map belong towards the end\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof Iterator) { // very generic; keep towards the end\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof Iterable) { // very generic; keep towards the end\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only.  Would be nice to \"assert false\" ?\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cc17990871fe421019acbdd0ed59c8644b9154c","date":1523636883,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n    //    (see a patch on LUCENE-3041 for inspiration)\n\n    // go in order of most common to least common, however some of the more general types like Map belong towards the end\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof Iterator) { // very generic; keep towards the end\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof Iterable) { // very generic; keep towards the end\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only.  Would be nice to \"assert false\" ?\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n\n    // go in order of most common to least common\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof Iterable) {\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof Iterator) {\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else {\n      // default... for debugging only\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"26dad91f15019714a045b4d8c5f40162b2058b54","date":1528551655,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n    //    (see a patch on LUCENE-3041 for inspiration)\n\n    // go in order of most common to least common, however some of the more general types like Map belong towards the end\n    if (val == null) {\n      writeNull(name);\n      return;\n    }\n\n    if(val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      TextWriter.super.writeVal(name, val);\n    }\n  }\n  // names are passed when writing primitives like writeInt to allow many different\n  // types of formats, including those where the name may come after the value (like\n  // some XML formats).\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n    //    (see a patch on LUCENE-3041 for inspiration)\n\n    // go in order of most common to least common, however some of the more general types like Map belong towards the end\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof Iterator) { // very generic; keep towards the end\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof Iterable) { // very generic; keep towards the end\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only.  Would be nice to \"assert false\" ?\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n    //    (see a patch on LUCENE-3041 for inspiration)\n\n    // go in order of most common to least common, however some of the more general types like Map belong towards the end\n    if (val == null) {\n      writeNull(name);\n      return;\n    }\n\n    if(val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      TextWriter.super.writeVal(name, val);\n    }\n  }\n  // names are passed when writing primitives like writeInt to allow many different\n  // types of formats, including those where the name may come after the value (like\n  // some XML formats).\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n    //    (see a patch on LUCENE-3041 for inspiration)\n\n    // go in order of most common to least common, however some of the more general types like Map belong towards the end\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof Iterator) { // very generic; keep towards the end\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof Iterable) { // very generic; keep towards the end\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only.  Would be nice to \"assert false\" ?\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/TextResponseWriter#writeVal(String,Object).mjava","sourceNew":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n    //    (see a patch on LUCENE-3041 for inspiration)\n\n    // go in order of most common to least common, however some of the more general types like Map belong towards the end\n    if (val == null) {\n      writeNull(name);\n      return;\n    }\n\n    if(val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else {\n      TextWriter.super.writeVal(name, val);\n    }\n  }\n  // names are passed when writing primitives like writeInt to allow many different\n  // types of formats, including those where the name may come after the value (like\n  // some XML formats).\n\n","sourceOld":"  public final void writeVal(String name, Object val) throws IOException {\n\n    // if there get to be enough types, perhaps hashing on the type\n    // to get a handler might be faster (but types must be exact to do that...)\n    //    (see a patch on LUCENE-3041 for inspiration)\n\n    // go in order of most common to least common, however some of the more general types like Map belong towards the end\n    if (val == null) {\n      writeNull(name);\n    } else if (val instanceof String) {\n      writeStr(name, val.toString(), true);\n      // micro-optimization... using toString() avoids a cast first\n    } else if (val instanceof IndexableField) {\n      IndexableField f = (IndexableField)val;\n      SchemaField sf = schema.getFieldOrNull( f.name() );\n      if( sf != null ) {\n        sf.getType().write(this, name, f);\n      }\n      else {\n        writeStr(name, f.stringValue(), true);\n      }\n    } else if (val instanceof Number) {\n      writeNumber(name, (Number) val);\n    } else if (val instanceof Boolean) {\n      writeBool(name, (Boolean) val);\n    } else if (val instanceof AtomicBoolean)  {\n      writeBool(name, ((AtomicBoolean) val).get());\n    } else if (val instanceof Date) {\n      writeDate(name, (Date) val);\n    } else if (val instanceof Document) {\n      SolrDocument doc = DocsStreamer.convertLuceneDocToSolrDoc((Document) val, schema, returnFields);\n      writeSolrDocument(name, doc, returnFields, 0);\n    } else if (val instanceof SolrDocument) {\n      writeSolrDocument(name, (SolrDocument) val, returnFields, 0);\n    } else if (val instanceof ResultContext) {\n      // requires access to IndexReader\n      writeDocuments(name, (ResultContext) val);\n    } else if (val instanceof DocList) {\n      // Should not happen normally\n      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);\n      writeDocuments(name, ctx);\n    // }\n    // else if (val instanceof DocSet) {\n    // how do we know what fields to read?\n    // todo: have a DocList/DocSet wrapper that\n    // restricts the fields to write...?\n    } else if (val instanceof SolrDocumentList) {\n      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);\n    } else if (val instanceof NamedList) {\n      writeNamedList(name, (NamedList)val);\n    } else if (val instanceof Path) {\n      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);\n    } else if (val instanceof IteratorWriter) {\n      writeIterator((IteratorWriter) val);\n    } else if (val instanceof MapWriter) {\n      writeMap((MapWriter) val);\n    } else if (val instanceof MapSerializable) {\n      //todo find a better way to reuse the map more efficiently\n      writeMap(name, ((MapSerializable) val).toMap(new LinkedHashMap<>()), false, true);\n    } else if (val instanceof Map) {\n      writeMap(name, (Map)val, false, true);\n    } else if (val instanceof Iterator) { // very generic; keep towards the end\n      writeArray(name, (Iterator) val);\n    } else if (val instanceof Iterable) { // very generic; keep towards the end\n      writeArray(name,((Iterable)val).iterator());\n    } else if (val instanceof Object[]) {\n      writeArray(name,(Object[])val);\n    } else if (val instanceof byte[]) {\n      byte[] arr = (byte[])val;\n      writeByteArr(name, arr, 0, arr.length);\n    } else if (val instanceof BytesRef) {\n      BytesRef arr = (BytesRef)val;\n      writeByteArr(name, arr.bytes, arr.offset, arr.length);\n    } else if (val instanceof EnumFieldValue) {\n      writeStr(name, val.toString(), true);\n    } else if (val instanceof WriteableValue) {\n      ((WriteableValue)val).write(name, this);\n    } else {\n      // default... for debugging only.  Would be nice to \"assert false\" ?\n      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b5d3613911d665344055ef7970e1783b3348b5c0":["28288370235ed02234a64753cdbf0c6ec096304a"],"3b71fe681187ac8552caaff9d5a7f1f3cac47b56":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","e81b63c9ecb10b3cb98b3cc5e255b8d91021b941"],"8a1c70b003d9abbd2ce7878bce14b6ec28fb05e4":["b5d3613911d665344055ef7970e1783b3348b5c0"],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["50f05d6b69cfaabd51b5d26cba4e3122f51fff83"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3a6fbf1484b3c2b38b75d59998de5fe4330b6b40"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["b68df8b95f3ea758a8dc21cb20a50a01db973e8e","c5892bdf887aeb6dcc06096dd9b4a7363513eff7"],"91814ce09be68efd0626969632e79ae47d8876d4":["1d028314cced5858683a1bb4741423d0f934257b"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["9720b151fde2073f4e401450f4574e5f31c2d0ff","50f05d6b69cfaabd51b5d26cba4e3122f51fff83"],"e81b63c9ecb10b3cb98b3cc5e255b8d91021b941":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc":["be73df8ac65c8f1ebef4eed2c0bd3a3b8167e235"],"50f05d6b69cfaabd51b5d26cba4e3122f51fff83":["3a6fbf1484b3c2b38b75d59998de5fe4330b6b40"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["de548de3ce5405595899f548152d4b93ac9eb9cc","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["1d028314cced5858683a1bb4741423d0f934257b","d12bbc45d641864ffe03291bc30f178eb34e434c"],"1d028314cced5858683a1bb4741423d0f934257b":["c5892bdf887aeb6dcc06096dd9b4a7363513eff7","a7e4907084808af8fdb14b9809e6dceaccf6867b"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["1cc17990871fe421019acbdd0ed59c8644b9154c","26dad91f15019714a045b4d8c5f40162b2058b54"],"14fd29e977ffb76db89d8ecd4fd70fbd9a51d390":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"a626ec4d1c92e59fe390724d6220081047b03ce7":["7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["63a9344cff6a72bc4c1ef080c69e10ad0635b811","a513b6a92751e54c76fb5447948c9e7d437163a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["3b71fe681187ac8552caaff9d5a7f1f3cac47b56","1f1f31880696765d6aec499d3b01fa501129af45"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["c26f00b574427b55127e869b935845554afde1fa"],"b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9":["c7a0594ac6740a20a5f8d6ab8d7d881f5283c61a"],"a7e4907084808af8fdb14b9809e6dceaccf6867b":["c5892bdf887aeb6dcc06096dd9b4a7363513eff7"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["a626ec4d1c92e59fe390724d6220081047b03ce7"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["1cc17990871fe421019acbdd0ed59c8644b9154c","26dad91f15019714a045b4d8c5f40162b2058b54"],"c7a0594ac6740a20a5f8d6ab8d7d881f5283c61a":["d12bbc45d641864ffe03291bc30f178eb34e434c"],"26dad91f15019714a045b4d8c5f40162b2058b54":["1cc17990871fe421019acbdd0ed59c8644b9154c"],"de548de3ce5405595899f548152d4b93ac9eb9cc":["50f05d6b69cfaabd51b5d26cba4e3122f51fff83"],"1f1f31880696765d6aec499d3b01fa501129af45":["3b71fe681187ac8552caaff9d5a7f1f3cac47b56"],"3a6fbf1484b3c2b38b75d59998de5fe4330b6b40":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"be73df8ac65c8f1ebef4eed2c0bd3a3b8167e235":["b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9"],"28288370235ed02234a64753cdbf0c6ec096304a":["63a9344cff6a72bc4c1ef080c69e10ad0635b811","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3b71fe681187ac8552caaff9d5a7f1f3cac47b56","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7":["b68df8b95f3ea758a8dc21cb20a50a01db973e8e","c5892bdf887aeb6dcc06096dd9b4a7363513eff7"],"b68df8b95f3ea758a8dc21cb20a50a01db973e8e":["14fd29e977ffb76db89d8ecd4fd70fbd9a51d390"],"1cc17990871fe421019acbdd0ed59c8644b9154c":["b5d3613911d665344055ef7970e1783b3348b5c0","8a1c70b003d9abbd2ce7878bce14b6ec28fb05e4"],"c5892bdf887aeb6dcc06096dd9b4a7363513eff7":["b68df8b95f3ea758a8dc21cb20a50a01db973e8e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d12bbc45d641864ffe03291bc30f178eb34e434c":["91814ce09be68efd0626969632e79ae47d8876d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["26dad91f15019714a045b4d8c5f40162b2058b54"]},"commit2Childs":{"b5d3613911d665344055ef7970e1783b3348b5c0":["8a1c70b003d9abbd2ce7878bce14b6ec28fb05e4","1cc17990871fe421019acbdd0ed59c8644b9154c"],"3b71fe681187ac8552caaff9d5a7f1f3cac47b56":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","1f1f31880696765d6aec499d3b01fa501129af45","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"8a1c70b003d9abbd2ce7878bce14b6ec28fb05e4":["1cc17990871fe421019acbdd0ed59c8644b9154c"],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["74aea047dff7f7c38a2d766827bd20d356f98c6a","28288370235ed02234a64753cdbf0c6ec096304a","a513b6a92751e54c76fb5447948c9e7d437163a7"],"c26f00b574427b55127e869b935845554afde1fa":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":["199dfa410f1fdbfd3294106b04096cce5ed34b21"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"91814ce09be68efd0626969632e79ae47d8876d4":["d12bbc45d641864ffe03291bc30f178eb34e434c"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"e81b63c9ecb10b3cb98b3cc5e255b8d91021b941":["3b71fe681187ac8552caaff9d5a7f1f3cac47b56"],"7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc":["a626ec4d1c92e59fe390724d6220081047b03ce7"],"50f05d6b69cfaabd51b5d26cba4e3122f51fff83":["63a9344cff6a72bc4c1ef080c69e10ad0635b811","199dfa410f1fdbfd3294106b04096cce5ed34b21","de548de3ce5405595899f548152d4b93ac9eb9cc"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"1d028314cced5858683a1bb4741423d0f934257b":["91814ce09be68efd0626969632e79ae47d8876d4","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"14fd29e977ffb76db89d8ecd4fd70fbd9a51d390":["b68df8b95f3ea758a8dc21cb20a50a01db973e8e"],"a626ec4d1c92e59fe390724d6220081047b03ce7":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["3a6fbf1484b3c2b38b75d59998de5fe4330b6b40","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["14fd29e977ffb76db89d8ecd4fd70fbd9a51d390"],"a7e4907084808af8fdb14b9809e6dceaccf6867b":["1d028314cced5858683a1bb4741423d0f934257b"],"b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9":["be73df8ac65c8f1ebef4eed2c0bd3a3b8167e235"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["3b71fe681187ac8552caaff9d5a7f1f3cac47b56","e81b63c9ecb10b3cb98b3cc5e255b8d91021b941"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"c7a0594ac6740a20a5f8d6ab8d7d881f5283c61a":["b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9"],"de548de3ce5405595899f548152d4b93ac9eb9cc":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"26dad91f15019714a045b4d8c5f40162b2058b54":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1f1f31880696765d6aec499d3b01fa501129af45":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"3a6fbf1484b3c2b38b75d59998de5fe4330b6b40":["9720b151fde2073f4e401450f4574e5f31c2d0ff","50f05d6b69cfaabd51b5d26cba4e3122f51fff83"],"be73df8ac65c8f1ebef4eed2c0bd3a3b8167e235":["7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc"],"28288370235ed02234a64753cdbf0c6ec096304a":["b5d3613911d665344055ef7970e1783b3348b5c0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9720b151fde2073f4e401450f4574e5f31c2d0ff"],"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7":[],"b68df8b95f3ea758a8dc21cb20a50a01db973e8e":["fd92b8bcc88e969302510acf77bd6970da3994c4","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7","c5892bdf887aeb6dcc06096dd9b4a7363513eff7"],"1cc17990871fe421019acbdd0ed59c8644b9154c":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","26dad91f15019714a045b4d8c5f40162b2058b54"],"c5892bdf887aeb6dcc06096dd9b4a7363513eff7":["fd92b8bcc88e969302510acf77bd6970da3994c4","1d028314cced5858683a1bb4741423d0f934257b","a7e4907084808af8fdb14b9809e6dceaccf6867b","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"d12bbc45d641864ffe03291bc30f178eb34e434c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","c7a0594ac6740a20a5f8d6ab8d7d881f5283c61a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fd92b8bcc88e969302510acf77bd6970da3994c4","199dfa410f1fdbfd3294106b04096cce5ed34b21","e9017cf144952056066919f1ebc7897ff9bd71b1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}