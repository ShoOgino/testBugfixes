{"path":"modules/grouping/src/java/org/apache/lucene/search/grouping/CachingCollector#collect(int).mjava","commits":[{"id":"307cff5af2b00f126fdf9d3435b75d5ed4d0f402","date":1305370109,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/CachingCollector#collect(int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    if (curDocs == null) {\n      // Cache was too large\n      if (curScores != null) {\n        score = scorer.score();\n      }\n      this.doc = doc;\n      other.collect(doc);\n      return;\n    }\n\n    if (upto == curDocs.length) {\n      base += upto;\n      final int nextLength;\n      // Max out at 512K arrays:\n      if (curDocs.length < 524288) {\n        nextLength = 8*curDocs.length;\n      } else {\n        nextLength = curDocs.length;\n      }\n\n      if (base + nextLength > maxDocsToCache) {\n        // Too many docs to collect -- clear cache\n        curDocs = null;\n        if (curScores != null) {\n          score = scorer.score();\n        }\n        this.doc = doc;\n        other.collect(doc);\n        cachedDocs.clear();\n        cachedScores.clear();\n        return;\n      }\n      curDocs = new int[nextLength];\n      cachedDocs.add(curDocs);\n      if (curScores != null) {\n        curScores = new float[nextLength];\n        cachedScores.add(curScores);\n      }\n      upto = 0;\n    }\n    curDocs[upto] = doc;\n    // TODO: maybe specialize private subclass so we don't\n    // null check per collect...\n    if (curScores != null) {\n      score = curScores[upto] = scorer.score();\n    }\n    upto++;\n    this.doc = doc;\n    other.collect(doc);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e77feb4ffb7321af961c838aeafdd07ef1f307d4","date":1305577750,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/CachingCollector#collect(int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/CachingCollector#collect(int).mjava","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    if (curDocs == null) {\n      // Cache was too large\n      if (cacheScores) {\n        cachedScorer.score = scorer.score();\n      }\n      cachedScorer.doc = doc;\n      other.collect(doc);\n      return;\n    }\n\n    // Allocate a bigger array or abort caching\n    if (upto == curDocs.length) {\n      base += upto;\n      \n      // Compute next array length - don't allocate too big arrays\n      int nextLength = 8*curDocs.length;\n      if (nextLength > MAX_ARRAY_SIZE) {\n        nextLength = MAX_ARRAY_SIZE;\n      }\n\n      if (base + nextLength > maxDocsToCache) {\n        // try to allocate a smaller array\n        nextLength = maxDocsToCache - base;\n        if (nextLength <= 0) {\n          // Too many docs to collect -- clear cache\n          curDocs = null;\n          curScores = null;\n          cachedSegs.clear();\n          cachedDocs.clear();\n          cachedScores.clear();\n          if (cacheScores) {\n            cachedScorer.score = scorer.score();\n          }\n          cachedScorer.doc = doc;\n          other.collect(doc);\n          return;\n        }\n      }\n      \n      curDocs = new int[nextLength];\n      cachedDocs.add(curDocs);\n      if (cacheScores) {\n        curScores = new float[nextLength];\n        cachedScores.add(curScores);\n      }\n      upto = 0;\n    }\n    \n    curDocs[upto] = doc;\n    // TODO: maybe specialize private subclass so we don't\n    // null check per collect...\n    if (cacheScores) {\n      cachedScorer.score = curScores[upto] = scorer.score();\n    }\n    upto++;\n    cachedScorer.doc = doc;\n    other.collect(doc);\n  }\n\n","sourceOld":"  @Override\n  public void collect(int doc) throws IOException {\n\n    if (curDocs == null) {\n      // Cache was too large\n      if (curScores != null) {\n        score = scorer.score();\n      }\n      this.doc = doc;\n      other.collect(doc);\n      return;\n    }\n\n    if (upto == curDocs.length) {\n      base += upto;\n      final int nextLength;\n      // Max out at 512K arrays:\n      if (curDocs.length < 524288) {\n        nextLength = 8*curDocs.length;\n      } else {\n        nextLength = curDocs.length;\n      }\n\n      if (base + nextLength > maxDocsToCache) {\n        // Too many docs to collect -- clear cache\n        curDocs = null;\n        if (curScores != null) {\n          score = scorer.score();\n        }\n        this.doc = doc;\n        other.collect(doc);\n        cachedDocs.clear();\n        cachedScores.clear();\n        return;\n      }\n      curDocs = new int[nextLength];\n      cachedDocs.add(curDocs);\n      if (curScores != null) {\n        curScores = new float[nextLength];\n        cachedScores.add(curScores);\n      }\n      upto = 0;\n    }\n    curDocs[upto] = doc;\n    // TODO: maybe specialize private subclass so we don't\n    // null check per collect...\n    if (curScores != null) {\n      score = curScores[upto] = scorer.score();\n    }\n    upto++;\n    this.doc = doc;\n    other.collect(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e77feb4ffb7321af961c838aeafdd07ef1f307d4":["307cff5af2b00f126fdf9d3435b75d5ed4d0f402"],"307cff5af2b00f126fdf9d3435b75d5ed4d0f402":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e77feb4ffb7321af961c838aeafdd07ef1f307d4"]},"commit2Childs":{"e77feb4ffb7321af961c838aeafdd07ef1f307d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"307cff5af2b00f126fdf9d3435b75d5ed4d0f402":["e77feb4ffb7321af961c838aeafdd07ef1f307d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["307cff5af2b00f126fdf9d3435b75d5ed4d0f402"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}