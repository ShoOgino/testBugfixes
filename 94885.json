{"path":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","commits":[{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f","date":1464187721,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs, numSubScorers);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores, numSubScorers);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs, numSubScorers);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores, numSubScorers);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs, numSubScorers);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores, numSubScorers);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs, numSubScorers);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores, numSubScorers);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d9452e13e015fa1187b0b1bed1a1d08b9c96241","date":1485723373,"type":4,"author":"Martijn van Groningen","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs, numSubScorers);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores, numSubScorers);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public LeafCollector getLeafCollector(final LeafReaderContext context)\n      throws IOException {\n    final LeafFieldComparator[] comparators = queue.getComparators(context);\n    final int[] reverseMul = queue.getReverseMul();\n    final int docBase = context.docBase;\n    return new LeafCollector() {\n\n      private Scorer scorer;\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        //System.out.println(\"C.setScorer scorer=\" + scorer);\n        // Since we invoke .score(), and the comparators likely\n        // do as well, cache it so it's only \"really\" computed\n        // once:\n        if (scorer instanceof ScoreCachingWrappingScorer == false) {\n          scorer = new ScoreCachingWrappingScorer(scorer);\n        }\n        this.scorer = scorer;\n        for (LeafFieldComparator comparator : comparators) {\n          comparator.setScorer(scorer);\n        }\n        Arrays.fill(joinScorers, null);\n\n        Queue<Scorer> queue = new LinkedList<>();\n        //System.out.println(\"\\nqueue: add top scorer=\" + scorer);\n        queue.add(scorer);\n        while ((scorer = queue.poll()) != null) {\n          //System.out.println(\"  poll: \" + scorer + \"; \" + scorer.getWeight().getQuery());\n          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {\n            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);\n          }\n\n          for (ChildScorer sub : scorer.getChildren()) {\n            //System.out.println(\"  add sub: \" + sub.child + \"; \" + sub.child.getWeight().getQuery());\n            queue.add(sub.child);\n          }\n        }\n      }\n      \n      @Override\n      public void collect(int parentDoc) throws IOException {\n      //System.out.println(\"\\nC parentDoc=\" + parentDoc);\n        totalHitCount++;\n\n        float score = Float.NaN;\n\n        if (trackMaxScore) {\n          score = scorer.score();\n          maxScore = Math.max(maxScore, score);\n        }\n\n        // TODO: we could sweep all joinScorers here and\n        // aggregate total child hit count, so we can fill this\n        // in getTopGroups (we wire it to 0 now)\n\n        if (queueFull) {\n          //System.out.println(\"  queueFull\");\n          // Fastmatch: return if this hit is not competitive\n          int c = 0;\n          for (int i = 0; i < comparators.length; ++i) {\n            c = reverseMul[i] * comparators[i].compareBottom(parentDoc);\n            if (c != 0) {\n              break;\n            }\n          }\n          if (c <= 0) { // in case of equality, this hit is not competitive as docs are visited in order\n            // Definitely not competitive.\n            //System.out.println(\"    skip\");\n            return;\n          }\n\n          //System.out.println(\"    competes!  doc=\" + (docBase + parentDoc));\n\n          // This hit is competitive - replace bottom element in queue & adjustTop\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(bottom.slot, parentDoc);\n          }\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          bottom.doc = docBase + parentDoc;\n          bottom.readerContext = context;\n          bottom.score = score;\n          copyGroups(bottom);\n          bottom = queue.updateTop();\n\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.setBottom(bottom.slot);\n          }\n        } else {\n          // Startup transient: queue is not yet full:\n          final int comparatorSlot = totalHitCount - 1;\n\n          // Copy hit into queue\n          for (LeafFieldComparator comparator : comparators) {\n            comparator.copy(comparatorSlot, parentDoc);\n          }\n          //System.out.println(\"  startup: new OG doc=\" + (docBase+parentDoc));\n          if (!trackMaxScore && trackScores) {\n            score = scorer.score();\n          }\n          final OneGroup og = new OneGroup(comparatorSlot, docBase+parentDoc, score, joinScorers.length, trackScores);\n          og.readerContext = context;\n          copyGroups(og);\n          bottom = queue.add(og);\n          queueFull = totalHitCount == numParentHits;\n          if (queueFull) {\n            // End of startup transient: queue just filled up:\n            for (LeafFieldComparator comparator : comparators) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      }\n      \n      // Pulls out child doc and scores for all join queries:\n      private void copyGroups(OneGroup og) {\n        // While rare, it's possible top arrays could be too\n        // short if join query had null scorer on first\n        // segment(s) but then became non-null on later segments\n        final int numSubScorers = joinScorers.length;\n        if (og.docs.length < numSubScorers) {\n          // While rare, this could happen if join query had\n          // null scorer on first segment(s) but then became\n          // non-null on later segments\n          og.docs = ArrayUtil.grow(og.docs, numSubScorers);\n        }\n        if (og.counts.length < numSubScorers) {\n          og.counts = ArrayUtil.grow(og.counts);\n        }\n        if (trackScores && og.scores.length < numSubScorers) {\n          og.scores = ArrayUtil.grow(og.scores, numSubScorers);\n        }\n\n        //System.out.println(\"\\ncopyGroups parentDoc=\" + og.doc);\n        for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {\n          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];\n          //System.out.println(\"  scorer=\" + joinScorer);\n          if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {\n            og.counts[scorerIDX] = joinScorer.getChildCount();\n            //System.out.println(\"    count=\" + og.counts[scorerIDX]);\n            og.docs[scorerIDX] = joinScorer.swapChildDocs(og.docs[scorerIDX]);\n            assert og.docs[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.docs[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            //System.out.println(\"    len=\" + og.docs[scorerIDX].length);\n            /*\n              for(int idx=0;idx<og.counts[scorerIDX];idx++) {\n              System.out.println(\"    docs[\" + idx + \"]=\" + og.docs[scorerIDX][idx]);\n              }\n            */\n            if (trackScores) {\n              //System.out.println(\"    copy scores\");\n              og.scores[scorerIDX] = joinScorer.swapChildScores(og.scores[scorerIDX]);\n              assert og.scores[scorerIDX].length >= og.counts[scorerIDX]: \"length=\" + og.scores[scorerIDX].length + \" vs count=\" + og.counts[scorerIDX];\n            }\n          } else {\n            og.counts[scorerIDX] = 0;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["901e951cec2e6af4e503209a6721c8834db23279"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","9d9452e13e015fa1187b0b1bed1a1d08b9c96241"],"901e951cec2e6af4e503209a6721c8834db23279":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"83870855d82aba6819217abeff5a40779dbb28b4":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","0e121d43b5a10f2df530f406f935102656e9c4e8"],"9d9452e13e015fa1187b0b1bed1a1d08b9c96241":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","0e121d43b5a10f2df530f406f935102656e9c4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9d9452e13e015fa1187b0b1bed1a1d08b9c96241"]},"commit2Childs":{"bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["83870855d82aba6819217abeff5a40779dbb28b4","9d9452e13e015fa1187b0b1bed1a1d08b9c96241","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["901e951cec2e6af4e503209a6721c8834db23279"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"901e951cec2e6af4e503209a6721c8834db23279":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"9d9452e13e015fa1187b0b1bed1a1d08b9c96241":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","83870855d82aba6819217abeff5a40779dbb28b4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}