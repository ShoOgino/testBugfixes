{"path":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","commits":[{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link #CURSOR_MARK_START} \n   * and then continuously walks the results using {@link #CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      QueryResponse rsp = cloudClient.query(p(params, CURSOR_MARK_PARAM, cursorMark));\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        assertFalse(\"walk already seen: \" + id, ids.exists(id));\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"061e4e5ab16e47a7037ed5caeaba669e66f67d1f","date":1389911910,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link #CURSOR_MARK_START} \n   * and then continuously walks the results using {@link #CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      QueryResponse rsp = cloudClient.query(p(params, CURSOR_MARK_PARAM, cursorMark));\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link #CURSOR_MARK_START} \n   * and then continuously walks the results using {@link #CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      QueryResponse rsp = cloudClient.query(p(params, CURSOR_MARK_PARAM, cursorMark));\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        assertFalse(\"walk already seen: \" + id, ids.exists(id));\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbd6d2ce12ab9b3bef6559744b54e95242cf5747","date":1390347163,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link #CURSOR_MARK_START} \n   * and then continuously walks the results using {@link #CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    return assertFullWalkNoDups(false, maxSize, params);\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link #CURSOR_MARK_START} \n   * and then continuously walks the results using {@link #CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      QueryResponse rsp = cloudClient.query(p(params, CURSOR_MARK_PARAM, cursorMark));\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","bugFix":null,"bugIntro":["df168f752ac3120a6e38cebfc8fc77722d6b2d20"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"df168f752ac3120a6e38cebfc8fc77722d6b2d20","date":1392501538,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link #CURSOR_MARK_START} \n   * and then continuously walks the results using {@link #CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link #CURSOR_MARK_START} \n   * and then continuously walks the results using {@link #CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    return assertFullWalkNoDups(false, maxSize, params);\n  }\n\n","bugFix":["cbd6d2ce12ab9b3bef6559744b54e95242cf5747"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","date":1423508552,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link #CURSOR_MARK_START} \n   * and then continuously walks the results using {@link #CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","bugFix":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasiński","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be positive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicitly uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * against both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in different scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be positive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicitly uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * against both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in different scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be positive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicitly uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * against both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in different scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be postive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicily uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * aainst both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in differnent scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a71f63026529f3c1f03cfdd664910873ab2369ae","date":1497543264,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be positive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicitly uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * against both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in different scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = Integer.parseInt(doc.getFieldValue(\"id\").toString());\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be positive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicitly uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * against both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in different scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be positive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicitly uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * against both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in different scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = Integer.parseInt(doc.getFieldValue(\"id\").toString());\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be positive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicitly uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * against both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in different scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribCursorPagingTest#assertFullWalkNoDups(int,SolrParams).mjava","sourceNew":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be positive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicitly uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * against both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in different scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = Integer.parseInt(doc.getFieldValue(\"id\").toString());\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a set of params, executes a cursor query using {@link CursorMarkParams#CURSOR_MARK_START} \n   * and then continuously walks the results using {@link CursorMarkParams#CURSOR_MARK_START} as long \n   * as a non-0 number of docs ar returned.  This method records the the set of all id's\n   * (must be positive ints) encountered and throws an assertion failure if any id is \n   * encountered more then once, or if the set grows above maxSize\n   * </p>\n   *\n   * <p>\n   * Note that this method explicitly uses the \"cloudClient\" for executing the queries, \n   * instead of relying on the test infrastructure to execute the queries redundently\n   * against both the cloud client as well as a control client.  This is because term stat \n   * differences in a sharded setup can result in different scores for documents compared \n   * to the control index -- which can affect the sorting in some cases and cause false \n   * negatives in the response comparisons (even if we don't include \"score\" in the \"fl\")\n   * </p>\n   */\n  public SentinelIntSet assertFullWalkNoDups(int maxSize, SolrParams params) throws Exception {\n    SentinelIntSet ids = new SentinelIntSet(maxSize, -1);\n    String cursorMark = CURSOR_MARK_START;\n    int docsOnThisPage = Integer.MAX_VALUE;\n    while (0 < docsOnThisPage) {\n      final SolrParams p = p(params, CURSOR_MARK_PARAM, cursorMark);\n      QueryResponse rsp = cloudClient.query(p);\n      String nextCursorMark = assertHashNextCursorMark(rsp);\n      SolrDocumentList docs = extractDocList(rsp);\n      docsOnThisPage = docs.size();\n      if (null != params.getInt(CommonParams.ROWS)) {\n        int rows = params.getInt(CommonParams.ROWS);\n        assertTrue(\"Too many docs on this page: \" + rows + \" < \" + docsOnThisPage,\n                   docsOnThisPage <= rows);\n      }\n      if (0 == docsOnThisPage) {\n        assertEquals(\"no more docs, but \"+CURSOR_MARK_NEXT+\" isn't same\",\n                     cursorMark, nextCursorMark);\n      }\n\n      for (SolrDocument doc : docs) {\n        int id = ((Integer)doc.get(\"id\")).intValue();\n        if (ids.exists(id)) {\n          String msg = \"(\" + p + \") walk already seen: \" + id;\n          try {\n            queryAndCompareShards(params(\"distrib\",\"false\",\n                                         \"q\",\"id:\"+id));\n          } catch (AssertionError ae) {\n            throw new AssertionError(msg + \", found shard inconsistency that would explain it...\", ae);\n          }\n          rsp = cloudClient.query(params(\"q\",\"id:\"+id));\n          throw new AssertionError(msg + \", don't know why; q=id:\"+id+\" gives: \" + rsp.toString());\n        }\n        ids.put(id);\n        assertFalse(\"id set bigger then max allowed (\"+maxSize+\"): \" + ids.size(),\n                    maxSize < ids.size());\n      }\n      cursorMark = nextCursorMark;\n    }\n    return ids;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"df168f752ac3120a6e38cebfc8fc77722d6b2d20":["cbd6d2ce12ab9b3bef6559744b54e95242cf5747"],"28288370235ed02234a64753cdbf0c6ec096304a":["d470c8182e92b264680e34081b75e70a9f2b3c89","a71f63026529f3c1f03cfdd664910873ab2369ae"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","0158ced21948b6626f733c1c42c1e18d94449789"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"061e4e5ab16e47a7037ed5caeaba669e66f67d1f":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["df168f752ac3120a6e38cebfc8fc77722d6b2d20"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["d470c8182e92b264680e34081b75e70a9f2b3c89","a71f63026529f3c1f03cfdd664910873ab2369ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"],"cbd6d2ce12ab9b3bef6559744b54e95242cf5747":["061e4e5ab16e47a7037ed5caeaba669e66f67d1f"],"0158ced21948b6626f733c1c42c1e18d94449789":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"]},"commit2Childs":{"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["061e4e5ab16e47a7037ed5caeaba669e66f67d1f"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"df168f752ac3120a6e38cebfc8fc77722d6b2d20":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a71f63026529f3c1f03cfdd664910873ab2369ae","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"061e4e5ab16e47a7037ed5caeaba669e66f67d1f":["cbd6d2ce12ab9b3bef6559744b54e95242cf5747"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cbd6d2ce12ab9b3bef6559744b54e95242cf5747":["df168f752ac3120a6e38cebfc8fc77722d6b2d20"],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}