{"path":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","commits":[{"id":"733e01764d06768700a194141bccb026ff24bb29","date":1357643774,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","pathOld":"/dev/null","sourceNew":"  private void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    final int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      final PackedInts.Encoder encoder = PackedInts.getEncoder(PackedInts.Format.PACKED, PackedInts.VERSION_CURRENT, bitsRequired);\n      final int iterations = values.length / encoder.valueCount();\n      final int blockSize = encoder.blockCount() * 8 * iterations;\n      if (blocks == null || blocks.length < blockSize) {\n        blocks = new byte[blockSize];\n      }\n      if (off < values.length) {\n        Arrays.fill(values, off, values.length, 0L);\n      }\n      encoder.encode(values, 0, blocks, 0, iterations);\n      final int blockCount = (int) PackedInts.Format.PACKED.byteCount(PackedInts.VERSION_CURRENT, off, bitsRequired);\n      out.writeBytes(blocks, blockCount);\n    }\n\n    off = 0;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","pathOld":"/dev/null","sourceNew":"  private void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    final int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      final PackedInts.Encoder encoder = PackedInts.getEncoder(PackedInts.Format.PACKED, PackedInts.VERSION_CURRENT, bitsRequired);\n      final int iterations = values.length / encoder.valueCount();\n      final int blockSize = encoder.blockCount() * 8 * iterations;\n      if (blocks == null || blocks.length < blockSize) {\n        blocks = new byte[blockSize];\n      }\n      if (off < values.length) {\n        Arrays.fill(values, off, values.length, 0L);\n      }\n      encoder.encode(values, 0, blocks, 0, iterations);\n      final int blockCount = (int) PackedInts.Format.PACKED.byteCount(PackedInts.VERSION_CURRENT, off, bitsRequired);\n      out.writeBytes(blocks, blockCount);\n    }\n\n    off = 0;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e76d3450662dab47d54e3f462c7b3eba4e38b9ac","date":1358866496,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","sourceNew":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    final int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","sourceOld":"  private void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    final int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      final PackedInts.Encoder encoder = PackedInts.getEncoder(PackedInts.Format.PACKED, PackedInts.VERSION_CURRENT, bitsRequired);\n      final int iterations = values.length / encoder.valueCount();\n      final int blockSize = encoder.blockCount() * 8 * iterations;\n      if (blocks == null || blocks.length < blockSize) {\n        blocks = new byte[blockSize];\n      }\n      if (off < values.length) {\n        Arrays.fill(values, off, values.length, 0L);\n      }\n      encoder.encode(values, 0, blocks, 0, iterations);\n      final int blockCount = (int) PackedInts.Format.PACKED.byteCount(PackedInts.VERSION_CURRENT, off, bitsRequired);\n      out.writeBytes(blocks, blockCount);\n    }\n\n    off = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e29d4d91327929d477b701d3ef2f5b3457d26ec5","date":1359465689,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","sourceNew":"  private void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    final int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      final PackedInts.Encoder encoder = PackedInts.getEncoder(PackedInts.Format.PACKED, PackedInts.VERSION_CURRENT, bitsRequired);\n      final int iterations = values.length / encoder.byteValueCount();\n      final int blockSize = encoder.byteBlockCount() * iterations;\n      if (blocks == null || blocks.length < blockSize) {\n        blocks = new byte[blockSize];\n      }\n      if (off < values.length) {\n        Arrays.fill(values, off, values.length, 0L);\n      }\n      encoder.encode(values, 0, blocks, 0, iterations);\n      final int blockCount = (int) PackedInts.Format.PACKED.byteCount(PackedInts.VERSION_CURRENT, off, bitsRequired);\n      out.writeBytes(blocks, blockCount);\n    }\n\n    off = 0;\n  }\n\n","sourceOld":"  private void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    final int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      final PackedInts.Encoder encoder = PackedInts.getEncoder(PackedInts.Format.PACKED, PackedInts.VERSION_CURRENT, bitsRequired);\n      final int iterations = values.length / encoder.valueCount();\n      final int blockSize = encoder.blockCount() * 8 * iterations;\n      if (blocks == null || blocks.length < blockSize) {\n        blocks = new byte[blockSize];\n      }\n      if (off < values.length) {\n        Arrays.fill(values, off, values.length, 0L);\n      }\n      encoder.encode(values, 0, blocks, 0, iterations);\n      final int blockCount = (int) PackedInts.Format.PACKED.byteCount(PackedInts.VERSION_CURRENT, off, bitsRequired);\n      out.writeBytes(blocks, blockCount);\n    }\n\n    off = 0;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","sourceNew":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    final int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","sourceOld":"  private void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    final int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      final PackedInts.Encoder encoder = PackedInts.getEncoder(PackedInts.Format.PACKED, PackedInts.VERSION_CURRENT, bitsRequired);\n      final int iterations = values.length / encoder.byteValueCount();\n      final int blockSize = encoder.byteBlockCount() * iterations;\n      if (blocks == null || blocks.length < blockSize) {\n        blocks = new byte[blockSize];\n      }\n      if (off < values.length) {\n        Arrays.fill(values, off, values.length, 0L);\n      }\n      encoder.encode(values, 0, blocks, 0, iterations);\n      final int blockCount = (int) PackedInts.Format.PACKED.byteCount(PackedInts.VERSION_CURRENT, off, bitsRequired);\n      out.writeBytes(blocks, blockCount);\n    }\n\n    off = 0;\n  }\n\n","bugFix":["733e01764d06768700a194141bccb026ff24bb29","e29d4d91327929d477b701d3ef2f5b3457d26ec5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3","date":1401710950,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","sourceNew":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    bitsRequired = PackedInts.fastestDirectBits(bitsRequired, acceptableOverheadRatio);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","sourceOld":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    final int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","bugFix":null,"bugIntro":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8106bc60c7452250f84c65cdb43ab6b1d8eb1534","date":1401906364,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","sourceNew":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","sourceOld":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    bitsRequired = PackedInts.fastestDirectBits(bitsRequired, acceptableOverheadRatio);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","bugFix":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dff0cb4eabd8bb5c27d3a284e18c812a89958a66","date":1402928522,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","sourceNew":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    int bitsRequired = delta == 0 ? 0 : PackedInts.unsignedBitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","sourceOld":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/BlockPackedWriter#flush().mjava","sourceNew":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    int bitsRequired = delta == 0 ? 0 : PackedInts.unsignedBitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","sourceOld":"  protected void flush() throws IOException {\n    assert off > 0;\n    long min = Long.MAX_VALUE, max = Long.MIN_VALUE;\n    for (int i = 0; i < off; ++i) {\n      min = Math.min(values[i], min);\n      max = Math.max(values[i], max);\n    }\n\n    final long delta = max - min;\n    int bitsRequired = delta < 0 ? 64 : delta == 0L ? 0 : PackedInts.bitsRequired(delta);\n    if (bitsRequired == 64) {\n      // no need to delta-encode\n      min = 0L;\n    } else if (min > 0L) {\n      // make min as small as possible so that writeVLong requires fewer bytes\n      min = Math.max(0L, max - PackedInts.maxValue(bitsRequired));\n    }\n\n    final int token = (bitsRequired << BPV_SHIFT) | (min == 0 ? MIN_VALUE_EQUALS_0 : 0);\n    out.writeByte((byte) token);\n\n    if (min != 0) {\n      writeVLong(out, zigZagEncode(min) - 1);\n    }\n\n    if (bitsRequired > 0) {\n      if (min != 0) {\n        for (int i = 0; i < off; ++i) {\n          values[i] -= min;\n        }\n      }\n      writeValues(bitsRequired);\n    }\n\n    off = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e29d4d91327929d477b701d3ef2f5b3457d26ec5":["733e01764d06768700a194141bccb026ff24bb29"],"e76d3450662dab47d54e3f462c7b3eba4e38b9ac":["4e6354dd7c71fe122926fc53d7d29f715b1283db"],"dff0cb4eabd8bb5c27d3a284e18c812a89958a66":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["e29d4d91327929d477b701d3ef2f5b3457d26ec5","e76d3450662dab47d54e3f462c7b3eba4e38b9ac"],"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"733e01764d06768700a194141bccb026ff24bb29":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534","dff0cb4eabd8bb5c27d3a284e18c812a89958a66"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","733e01764d06768700a194141bccb026ff24bb29"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dff0cb4eabd8bb5c27d3a284e18c812a89958a66"]},"commit2Childs":{"e29d4d91327929d477b701d3ef2f5b3457d26ec5":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"e76d3450662dab47d54e3f462c7b3eba4e38b9ac":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"dff0cb4eabd8bb5c27d3a284e18c812a89958a66":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"733e01764d06768700a194141bccb026ff24bb29":["e29d4d91327929d477b701d3ef2f5b3457d26ec5","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["733e01764d06768700a194141bccb026ff24bb29","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["dff0cb4eabd8bb5c27d3a284e18c812a89958a66","c6f080a2ab37c464dd98db173f6cbf10dc74f211"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["e76d3450662dab47d54e3f462c7b3eba4e38b9ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}