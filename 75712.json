{"path":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","pathOld":"modules/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","sourceNew":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, null);\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","sourceOld":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, null);\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b538dc75c275415cfba029900b48590b36b3b68","date":1339713606,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","sourceNew":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, null);\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null\n          || parents.iterator().docID() == DocIdSetIterator.NO_MORE_DOCS) { // <-- means DocIdSet#EMPTY_DOCIDSET\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","sourceOld":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, null);\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9960231c0d2fe8b22f626e517d4cbca37be4a6a","date":1351702608,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","sourceNew":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub and the live docs:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, readerContext.reader().getLiveDocs());\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null\n          || parents.iterator().docID() == DocIdSetIterator.NO_MORE_DOCS) { // <-- means DocIdSet#EMPTY_DOCIDSET\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","sourceOld":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, null);\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null\n          || parents.iterator().docID() == DocIdSetIterator.NO_MORE_DOCS) { // <-- means DocIdSet#EMPTY_DOCIDSET\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","bugFix":["b5a3548d95924aea5ee6d88499a7d166498a8e49","97e30c53fd81463c6ccd52402c91a6548cf42acb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eae735a9830ffc762967099f30deb101fd9a939","date":1366271714,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","sourceNew":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub and the live docs:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, readerContext.reader().getLiveDocs());\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null || parents == DocIdSet.EMPTY_DOCIDSET) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","sourceOld":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub and the live docs:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, readerContext.reader().getLiveDocs());\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null\n          || parents.iterator().docID() == DocIdSetIterator.NO_MORE_DOCS) { // <-- means DocIdSet#EMPTY_DOCIDSET\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc06632ede7e48a5ddc6917badec25c8336feedc","date":1366983006,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","sourceNew":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub and the live docs:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, readerContext.reader().getLiveDocs());\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","sourceOld":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub and the live docs:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, readerContext.reader().getLiveDocs());\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null || parents == DocIdSet.EMPTY_DOCIDSET) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e18c86f811939bfa8cd24046c96ed026f2e9b34","date":1393893071,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","sourceNew":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, Bits acceptDocs) throws IOException {\n\n      final Scorer childScorer = childWeight.scorer(readerContext, readerContext.reader().getLiveDocs());\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","sourceOld":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub and the live docs:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, readerContext.reader().getLiveDocs());\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acf00221f44c5f08ccea014f2492b53af15ecd66","date":1394568293,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","sourceNew":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, Bits acceptDocs) throws IOException {\n\n      final Scorer childScorer = childWeight.scorer(readerContext, readerContext.reader().getLiveDocs());\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","sourceOld":"    // NOTE: acceptDocs applies (and is checked) only in the\n    // parent document space\n    @Override\n    public Scorer scorer(AtomicReaderContext readerContext, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs) throws IOException {\n\n      // Pass scoreDocsInOrder true, topScorer false to our sub and the live docs:\n      final Scorer childScorer = childWeight.scorer(readerContext, true, false, readerContext.reader().getLiveDocs());\n\n      if (childScorer == null) {\n        // No matches\n        return null;\n      }\n\n      final int firstChildDoc = childScorer.nextDoc();\n      if (firstChildDoc == DocIdSetIterator.NO_MORE_DOCS) {\n        // No matches\n        return null;\n      }\n\n      // NOTE: we cannot pass acceptDocs here because this\n      // will (most likely, justifiably) cause the filter to\n      // not return a FixedBitSet but rather a\n      // BitsFilteredDocIdSet.  Instead, we filter by\n      // acceptDocs when we score:\n      final DocIdSet parents = parentsFilter.getDocIdSet(readerContext, null);\n\n      if (parents == null) {\n        // No matches\n        return null;\n      }\n      if (!(parents instanceof FixedBitSet)) {\n        throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n      }\n\n      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dc06632ede7e48a5ddc6917badec25c8336feedc":["1eae735a9830ffc762967099f30deb101fd9a939"],"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["dc06632ede7e48a5ddc6917badec25c8336feedc"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a9960231c0d2fe8b22f626e517d4cbca37be4a6a":["6b538dc75c275415cfba029900b48590b36b3b68"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eae735a9830ffc762967099f30deb101fd9a939":["a9960231c0d2fe8b22f626e517d4cbca37be4a6a"],"6b538dc75c275415cfba029900b48590b36b3b68":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["dc06632ede7e48a5ddc6917badec25c8336feedc","2e18c86f811939bfa8cd24046c96ed026f2e9b34"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["acf00221f44c5f08ccea014f2492b53af15ecd66"]},"commit2Childs":{"dc06632ede7e48a5ddc6917badec25c8336feedc":["2e18c86f811939bfa8cd24046c96ed026f2e9b34","acf00221f44c5f08ccea014f2492b53af15ecd66"],"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["6b538dc75c275415cfba029900b48590b36b3b68"],"a9960231c0d2fe8b22f626e517d4cbca37be4a6a":["1eae735a9830ffc762967099f30deb101fd9a939"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"1eae735a9830ffc762967099f30deb101fd9a939":["dc06632ede7e48a5ddc6917badec25c8336feedc"],"6b538dc75c275415cfba029900b48590b36b3b68":["a9960231c0d2fe8b22f626e517d4cbca37be4a6a"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}