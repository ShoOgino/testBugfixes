{"path":"lucene/core/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,int,TopDocs[]).mjava","commits":[{"id":"a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5","date":1395042605,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,int,TopDocs[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Same as {@link #merge(Sort, int, TopDocs[])} but also slices the result at the same time based\n   * on the provided start and size. The return TopDocs will always have a scoreDocs with length of at most size.\n   */\n  public static TopDocs merge(Sort sort, int start, int size, TopDocs[] shardHits) throws IOException {\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.pop();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        hit.shardIndex = ref.shardIndex;\n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        //System.out.println(\"  hitUpto=\" + hitUpto);\n        //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.add(ref);\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#mergeAux(Sort,int,int,TopDocs[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,int,TopDocs[]).mjava","sourceNew":"  /** Auxiliary method used by the {@link #merge} impls. A sort value of null\n   *  is used to indicate that docs should be sorted by score. */\n  private static TopDocs mergeAux(Sort sort, int start, int size, TopDocs[] shardHits) throws IOException {\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.pop();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        hit.shardIndex = ref.shardIndex;\n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        //System.out.println(\"  hitUpto=\" + hitUpto);\n        //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.add(ref);\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /**\n   * Same as {@link #merge(Sort, int, TopDocs[])} but also slices the result at the same time based\n   * on the provided start and size. The return TopDocs will always have a scoreDocs with length of at most size.\n   */\n  public static TopDocs merge(Sort sort, int start, int size, TopDocs[] shardHits) throws IOException {\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits;\n    if (availHitCount <= start) {\n      hits = new ScoreDoc[0];\n    } else {\n      hits = new ScoreDoc[Math.min(size, availHitCount - start)];\n      int requestedResultWindow = start + size;\n      int numIterOnHits = Math.min(availHitCount, requestedResultWindow);\n      int hitUpto = 0;\n      while (hitUpto < numIterOnHits) {\n        assert queue.size() > 0;\n        ShardRef ref = queue.pop();\n        final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n        hit.shardIndex = ref.shardIndex;\n        if (hitUpto >= start) {\n          hits[hitUpto - start] = hit;\n        }\n\n        //System.out.println(\"  hitUpto=\" + hitUpto);\n        //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n        hitUpto++;\n\n        if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n          // Not done with this these TopDocs yet:\n          queue.add(ref);\n        }\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fb17639909a369c1e64866842e5c213440acc17e":["a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb17639909a369c1e64866842e5c213440acc17e"]},"commit2Childs":{"a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5":["fb17639909a369c1e64866842e5c213440acc17e"],"fb17639909a369c1e64866842e5c213440acc17e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}