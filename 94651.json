{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","commits":[{"id":"110125c995236a7f61057dd04b039ed2d267f3a1","date":1521014987,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,Term).mjava","sourceNew":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException, AbortingException {\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delNode);\n      } catch (AbortingException ae) {\n        flushControl.doOnAbort(perThread);\n        dwpt.abort();\n        throw ae;\n      } finally {\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","sourceOld":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final Term delTerm) throws IOException, AbortingException {\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delTerm);\n      } catch (AbortingException ae) {\n        flushControl.doOnAbort(perThread);\n        dwpt.abort();\n        throw ae;\n      } finally {\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delTerm != null;\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","sourceNew":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delNode);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","sourceOld":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException, AbortingException {\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delNode);\n      } catch (AbortingException ae) {\n        flushControl.doOnAbort(perThread);\n        dwpt.abort();\n        throw ae;\n      } finally {\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","sourceNew":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delNode, flushNotifications);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","sourceOld":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delNode);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","sourceNew":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final DocumentsWriterPerThread dwpt = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the DWPT because IW.close\n      // waits for all DWPT to be released:\n      ensureOpen();\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delNode, flushNotifications);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(dwpt);\n        }\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(dwpt, isUpdate);\n    } finally {\n      if (dwpt.isFlushPending() || dwpt.isAborted()) {\n        dwpt.unlock();\n      } else {\n        perThreadPool.marksAsFreeAndUnlock(dwpt);\n      }\n      assert dwpt.isHeldByCurrentThread() == false : \"we didn't release the dwpt even on abort\";\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","sourceOld":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delNode, flushNotifications);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2","date":1588002560,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],DocumentsWriterDeleteQueue.Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","sourceNew":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final DocumentsWriterPerThread dwpt = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the DWPT because IW.close\n      // waits for all DWPT to be released:\n      ensureOpen();\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, delNode, flushNotifications);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(dwpt);\n        }\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(dwpt, isUpdate);\n    } finally {\n      if (dwpt.isFlushPending() || dwpt.isAborted()) {\n        dwpt.unlock();\n      } else {\n        perThreadPool.marksAsFreeAndUnlock(dwpt);\n      }\n      assert dwpt.isHeldByCurrentThread() == false : \"we didn't release the dwpt even on abort\";\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","sourceOld":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final DocumentsWriterPerThread dwpt = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the DWPT because IW.close\n      // waits for all DWPT to be released:\n      ensureOpen();\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delNode, flushNotifications);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(dwpt);\n        }\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(dwpt, isUpdate);\n    } finally {\n      if (dwpt.isFlushPending() || dwpt.isAborted()) {\n        dwpt.unlock();\n      } else {\n        perThreadPool.marksAsFreeAndUnlock(dwpt);\n      }\n      assert dwpt.isHeldByCurrentThread() == false : \"we didn't release the dwpt even on abort\";\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"264935965977b4a9e2f3920420647072c9c49176":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["110125c995236a7f61057dd04b039ed2d267f3a1"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["264935965977b4a9e2f3920420647072c9c49176"],"110125c995236a7f61057dd04b039ed2d267f3a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"]},"commit2Childs":{"264935965977b4a9e2f3920420647072c9c49176":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["264935965977b4a9e2f3920420647072c9c49176"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["110125c995236a7f61057dd04b039ed2d267f3a1"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"110125c995236a7f61057dd04b039ed2d267f3a1":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}