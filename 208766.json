{"path":"solr/solrj/src/java/org/apache/solr/common/SimpleZkMap#recursiveRead(String,List[String],BiFunction[String,#-super-Resource,Boolean]).mjava","commits":[{"id":"48499be433b284c562fb2418fe7b858e1ac3b031","date":1597289664,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/SimpleZkMap#recursiveRead(String,List[String],BiFunction[String,#-super-Resource,Boolean]).mjava","pathOld":"/dev/null","sourceNew":"    private boolean recursiveRead(String parent, List<String> childrenList, BiFunction<String, ? super Resource, Boolean> fun) {\n        if(childrenList == null || childrenList.isEmpty()) return true;\n        try {\n            Map<String, List<String>> withKids = new LinkedHashMap<>();\n            for (String child : childrenList) {\n                String relativePath =  parent.isBlank() ? child: parent+\"/\"+child;\n                if(!fun.apply(relativePath, readZkNode(relativePath))) return false;\n                List<String> l1 =  zkStateReader.getZkClient().getChildren(basePath+ \"/\"+ relativePath, null, true);\n                if(l1 != null && !l1.isEmpty()) {\n                    withKids.put(relativePath, l1);\n                }\n            }\n            //now we iterate through all nodes with sub paths\n            for (Map.Entry<String, List<String>> e : withKids.entrySet()) {\n                //has children\n                if(!recursiveRead(e.getKey(), e.getValue(), fun)) {\n                    return false;\n                }\n            }\n        } catch (KeeperException | InterruptedException e) {\n            throwZkExp(e);\n        }\n        return true;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"64ca3f44a396c294398d81101e739d0f961d9a06","date":1597290785,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/SimpleZkMap#recursiveRead(String,List[String],BiFunction[String,#-super-Resource,Boolean]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/SimpleZkMap#recursiveRead(String,List[String],BiFunction[String,#-super-Resource,Boolean]).mjava","sourceNew":"    private boolean recursiveRead(String parent, List<String> childrenList, BiFunction<String, ? super Resource, Boolean> fun) {\n        if(childrenList == null || childrenList.isEmpty()) return true;\n        try {\n            Map<String, List<String>> withKids = new LinkedHashMap<>();\n            for (String child : childrenList) {\n                String relativePath =  parent.isEmpty() ? child: parent+\"/\"+child;\n                if(!fun.apply(relativePath, readZkNode(relativePath))) return false;\n                List<String> l1 =  zkStateReader.getZkClient().getChildren(basePath+ \"/\"+ relativePath, null, true);\n                if(l1 != null && !l1.isEmpty()) {\n                    withKids.put(relativePath, l1);\n                }\n            }\n            //now we iterate through all nodes with sub paths\n            for (Map.Entry<String, List<String>> e : withKids.entrySet()) {\n                //has children\n                if(!recursiveRead(e.getKey(), e.getValue(), fun)) {\n                    return false;\n                }\n            }\n        } catch (KeeperException | InterruptedException e) {\n            throwZkExp(e);\n        }\n        return true;\n    }\n\n","sourceOld":"    private boolean recursiveRead(String parent, List<String> childrenList, BiFunction<String, ? super Resource, Boolean> fun) {\n        if(childrenList == null || childrenList.isEmpty()) return true;\n        try {\n            Map<String, List<String>> withKids = new LinkedHashMap<>();\n            for (String child : childrenList) {\n                String relativePath =  parent.isBlank() ? child: parent+\"/\"+child;\n                if(!fun.apply(relativePath, readZkNode(relativePath))) return false;\n                List<String> l1 =  zkStateReader.getZkClient().getChildren(basePath+ \"/\"+ relativePath, null, true);\n                if(l1 != null && !l1.isEmpty()) {\n                    withKids.put(relativePath, l1);\n                }\n            }\n            //now we iterate through all nodes with sub paths\n            for (Map.Entry<String, List<String>> e : withKids.entrySet()) {\n                //has children\n                if(!recursiveRead(e.getKey(), e.getValue(), fun)) {\n                    return false;\n                }\n            }\n        } catch (KeeperException | InterruptedException e) {\n            throwZkExp(e);\n        }\n        return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"48499be433b284c562fb2418fe7b858e1ac3b031":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"64ca3f44a396c294398d81101e739d0f961d9a06":["48499be433b284c562fb2418fe7b858e1ac3b031"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["64ca3f44a396c294398d81101e739d0f961d9a06"]},"commit2Childs":{"48499be433b284c562fb2418fe7b858e1ac3b031":["64ca3f44a396c294398d81101e739d0f961d9a06"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["48499be433b284c562fb2418fe7b858e1ac3b031"],"64ca3f44a396c294398d81101e739d0f961d9a06":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}