{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","commits":[{"id":"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e","date":1415435053,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"/dev/null","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79700663e164dece87bed4adfd3e28bab6cb1385","date":1425241849,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>());\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"299a2348fa24151d150182211b6208a38e5e3450","date":1425304608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>());\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>());\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, null);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>());\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2464b43ee422a496b9232278eb1ab77ea36ba0c3","date":1508151941,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"165c905a42bedc7c7d1acb37b177498306b7e866","date":1518704038,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeba0a4d0845889a402dd225793d62f009d029c9","date":1527938093,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final boolean isSoftDeletesField = name.equals(globalFieldNumbers.softDeletesFieldName);\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab548c8f96022b4780f7500a30b19b4f4a5feeb6","date":1527940044,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final boolean isSoftDeletesField = name.equals(globalFieldNumbers.softDeletesFieldName);\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7e4ca6dc9612ff741d8713743e2bccfae5eadac","date":1528093718,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final boolean isSoftDeletesField = name.equals(globalFieldNumbers.softDeletesFieldName);\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final boolean isSoftDeletesField = name.equals(globalFieldNumbers.softDeletesFieldName);\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final boolean isSoftDeletesField = name.equals(globalFieldNumbers.softDeletesFieldName);\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#getOrAdd(String).mjava","sourceNew":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final boolean isSoftDeletesField = name.equals(globalFieldNumbers.softDeletesFieldName);\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0, 0, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0, 0, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","sourceOld":"    /** Create a new field, or return existing one. */\n    public FieldInfo getOrAdd(String name) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        assert assertNotFinished();\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final boolean isSoftDeletesField = name.equals(globalFieldNumbers.softDeletesFieldName);\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, -1, IndexOptions.NONE, DocValuesType.NONE, 0, 0, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, new HashMap<>(), 0, 0, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, DocValuesType.NONE);\n        byName.put(fi.name, fi);\n      }\n\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f6652c943595e92c187ee904c382863013eae28f":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"165c905a42bedc7c7d1acb37b177498306b7e866":["2464b43ee422a496b9232278eb1ab77ea36ba0c3"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e","79700663e164dece87bed4adfd3e28bab6cb1385"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["eeba0a4d0845889a402dd225793d62f009d029c9"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["79700663e164dece87bed4adfd3e28bab6cb1385"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["165c905a42bedc7c7d1acb37b177498306b7e866","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"eeba0a4d0845889a402dd225793d62f009d029c9":["165c905a42bedc7c7d1acb37b177498306b7e866"],"79700663e164dece87bed4adfd3e28bab6cb1385":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e"],"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2464b43ee422a496b9232278eb1ab77ea36ba0c3":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"f592209545c71895260367152601e9200399776d":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"299a2348fa24151d150182211b6208a38e5e3450":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e","79700663e164dece87bed4adfd3e28bab6cb1385"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f6652c943595e92c187ee904c382863013eae28f"]},"commit2Childs":{"f6652c943595e92c187ee904c382863013eae28f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"165c905a42bedc7c7d1acb37b177498306b7e866":["b70042a8a492f7054d480ccdd2be9796510d4327","eeba0a4d0845889a402dd225793d62f009d029c9"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac","f592209545c71895260367152601e9200399776d"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["2464b43ee422a496b9232278eb1ab77ea36ba0c3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["f6652c943595e92c187ee904c382863013eae28f","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"79700663e164dece87bed4adfd3e28bab6cb1385":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ca792c26af46bd6c4a08d81117c60440cf6a7e3d","299a2348fa24151d150182211b6208a38e5e3450"],"eeba0a4d0845889a402dd225793d62f009d029c9":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","79700663e164dece87bed4adfd3e28bab6cb1385","299a2348fa24151d150182211b6208a38e5e3450"],"2464b43ee422a496b9232278eb1ab77ea36ba0c3":["165c905a42bedc7c7d1acb37b177498306b7e866"],"f592209545c71895260367152601e9200399776d":[],"299a2348fa24151d150182211b6208a38e5e3450":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","299a2348fa24151d150182211b6208a38e5e3450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}