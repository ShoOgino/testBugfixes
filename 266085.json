{"path":"lucene/core/src/java/org/apache/lucene/codecs/pfor/ForUtil#decompressCore(IntBuffer,int[],int).mjava","commits":[{"id":"5373bc7574123da55ae25e216b6d768ccb1dcd91","date":1342013351,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/ForUtil#decompressCore(IntBuffer,int[],int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * IntBuffer will not be rewinded in this method, therefore\n   * caller should ensure that the position is set to the first\n   * encoded int before decoding.\n   */\n  static void decompressCore(IntBuffer intBuffer, int[] data, int numBits) {\n    assert numBits<=32;\n    assert numBits>=1;\n\n    // TODO: PackedIntsDecompress is hardewired to size==129 only\n    switch(numBits) {\n      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;\n      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;\n      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;\n      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;\n      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;\n      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;\n      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;\n      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;\n      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;\n      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;\n      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;\n      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;\n      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;\n      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;\n      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;\n      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;\n      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;\n      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;\n      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;\n      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;\n      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;\n      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;\n      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;\n      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;\n      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;\n      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;\n      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;\n      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;\n      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;\n      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;\n      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;\n      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b","date":1342134079,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/ForUtil#decompressCore(IntBuffer,int[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/ForUtil#decompressCore(IntBuffer,int[],int).mjava","sourceNew":"  /**\n   * IntBuffer will not be rewinded in this method, therefore\n   * caller should ensure that the position is set to the first\n   * encoded int before decoding.\n   */\n  static void decompressCore(IntBuffer intBuffer, int[] data, int numBits) {\n    assert numBits<=32;\n    assert numBits>=0;\n\n    // TODO: PackedIntsDecompress is hardewired to size==128 only\n    switch(numBits) {\n      case 0: PackedIntsDecompress.decode0(intBuffer, data); break;\n      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;\n      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;\n      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;\n      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;\n      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;\n      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;\n      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;\n      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;\n      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;\n      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;\n      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;\n      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;\n      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;\n      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;\n      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;\n      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;\n      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;\n      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;\n      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;\n      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;\n      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;\n      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;\n      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;\n      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;\n      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;\n      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;\n      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;\n      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;\n      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;\n      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;\n      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;\n      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;\n    }\n  }\n\n","sourceOld":"  /**\n   * IntBuffer will not be rewinded in this method, therefore\n   * caller should ensure that the position is set to the first\n   * encoded int before decoding.\n   */\n  static void decompressCore(IntBuffer intBuffer, int[] data, int numBits) {\n    assert numBits<=32;\n    assert numBits>=1;\n\n    // TODO: PackedIntsDecompress is hardewired to size==129 only\n    switch(numBits) {\n      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;\n      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;\n      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;\n      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;\n      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;\n      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;\n      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;\n      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;\n      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;\n      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;\n      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;\n      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;\n      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;\n      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;\n      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;\n      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;\n      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;\n      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;\n      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;\n      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;\n      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;\n      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;\n      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;\n      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;\n      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;\n      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;\n      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;\n      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;\n      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;\n      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;\n      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;\n      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7250f5f8fbbaeebf817404fb2b3ce3b26161d5df","date":1343686506,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil#decompressCore(IntBuffer,int[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/ForUtil#decompressCore(IntBuffer,int[],int).mjava","sourceNew":"  /**\n   * IntBuffer will not be rewinded in this method, therefore\n   * caller should ensure that the position is set to the first\n   * encoded int before decoding.\n   */\n  static void decompressCore(IntBuffer intBuffer, int[] data, int numBits) {\n    assert numBits<=32;\n    assert numBits>=0;\n\n    // TODO: PackedIntsDecompress is hardewired to size==128 only\n    switch(numBits) {\n      case 0: PackedIntsDecompress.decode0(intBuffer, data); break;\n      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;\n      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;\n      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;\n      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;\n      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;\n      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;\n      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;\n      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;\n      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;\n      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;\n      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;\n      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;\n      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;\n      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;\n      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;\n      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;\n      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;\n      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;\n      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;\n      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;\n      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;\n      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;\n      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;\n      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;\n      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;\n      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;\n      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;\n      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;\n      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;\n      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;\n      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;\n      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;\n    }\n  }\n\n","sourceOld":"  /**\n   * IntBuffer will not be rewinded in this method, therefore\n   * caller should ensure that the position is set to the first\n   * encoded int before decoding.\n   */\n  static void decompressCore(IntBuffer intBuffer, int[] data, int numBits) {\n    assert numBits<=32;\n    assert numBits>=0;\n\n    // TODO: PackedIntsDecompress is hardewired to size==128 only\n    switch(numBits) {\n      case 0: PackedIntsDecompress.decode0(intBuffer, data); break;\n      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;\n      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;\n      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;\n      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;\n      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;\n      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;\n      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;\n      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;\n      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;\n      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;\n      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;\n      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;\n      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;\n      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;\n      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;\n      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;\n      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;\n      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;\n      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;\n      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;\n      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;\n      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;\n      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;\n      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;\n      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;\n      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;\n      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;\n      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;\n      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;\n      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;\n      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;\n      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7250f5f8fbbaeebf817404fb2b3ce3b26161d5df":["48d40647dc87c7b55ffe4d9dca73f63a3cebc58b"],"5373bc7574123da55ae25e216b6d768ccb1dcd91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b":["5373bc7574123da55ae25e216b6d768ccb1dcd91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"7250f5f8fbbaeebf817404fb2b3ce3b26161d5df":[],"5373bc7574123da55ae25e216b6d768ccb1dcd91":["48d40647dc87c7b55ffe4d9dca73f63a3cebc58b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5373bc7574123da55ae25e216b6d768ccb1dcd91","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b":["7250f5f8fbbaeebf817404fb2b3ce3b26161d5df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7250f5f8fbbaeebf817404fb2b3ce3b26161d5df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}