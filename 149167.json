{"path":"lucene/core/src/java/org/apache/lucene/util/BroadWord#select9(long,int).mjava","commits":[{"id":"0debe908d97b40345a206ca1671a9fd299833558","date":1373663120,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BroadWord#select9(long,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Select a 1-bit from a long.\n   * @return The index of the r-th 1 bit in x, or if no such bit exists, 72.\n   */\n  public static int select9(long x, int r) {\n    long s = x - ((x & 0xAAAAAAAAAAAAAAAAL) >>> 1); // Step 0, pairwise bitsums\n\n    // Correct a small mistake in algorithm 2:\n    // Use s instead of x the second time in right shift 2, compare to Algorithm 1 in rank9 above.\n    s = (s & 0x3333333333333333L) + ((s >>> 2) & 0x3333333333333333L); // Step 1, nibblewise bitsums\n\n    s = ((s + (s >>> 4)) & 0x0F0F0F0F0F0F0F0FL) * L8_L; // Step 2, bytewise bitsums\n\n    long b = ((smallerUpTo7_8(s, (r * L8_L)) >>> 7) * L8_L) >>> 53; // & (~7L); // Step 3, side ways addition for byte number times 8\n\n    long l = r - (((s << 8) >>> b) & 0xFFL); // Step 4, byte wise rank, subtract the rank with byte at b-8, or zero for b=0;\n    assert 0L <= l : l;\n    //assert l < 8 : l; //fails when bit r is not available.\n\n    // Select bit l from byte (x >>> b):\n    long spr = (((x >>> b) & 0xFFL) * L8_L) & L9_L; // spread the 8 bits of the byte at b over the long at L9 positions\n\n    // long spr_bigger8_zero = smaller8(0L, spr); // inlined smaller8 with 0L argument:\n    // FIXME: replace by biggerequal8_one formula from article page 6, line 9. four operators instead of five here.\n    long spr_bigger8_zero = ( ( H8_L - (spr & (~H8_L)) ) ^ (~spr) ) & H8_L;\n    s = (spr_bigger8_zero >>> 7) * L8_L; // Step 5, sideways byte add the 8 bits towards the high byte\n\n    int res = (int) (b + (((smallerUpTo7_8(s, (l * L8_L)) >>> 7) * L8_L) >>> 56)); // Step 6\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BroadWord#select9(long,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Select a 1-bit from a long.\n   * @return The index of the r-th 1 bit in x, or if no such bit exists, 72.\n   */\n  public static int select9(long x, int r) {\n    long s = x - ((x & 0xAAAAAAAAAAAAAAAAL) >>> 1); // Step 0, pairwise bitsums\n\n    // Correct a small mistake in algorithm 2:\n    // Use s instead of x the second time in right shift 2, compare to Algorithm 1 in rank9 above.\n    s = (s & 0x3333333333333333L) + ((s >>> 2) & 0x3333333333333333L); // Step 1, nibblewise bitsums\n\n    s = ((s + (s >>> 4)) & 0x0F0F0F0F0F0F0F0FL) * L8_L; // Step 2, bytewise bitsums\n\n    long b = ((smallerUpTo7_8(s, (r * L8_L)) >>> 7) * L8_L) >>> 53; // & (~7L); // Step 3, side ways addition for byte number times 8\n\n    long l = r - (((s << 8) >>> b) & 0xFFL); // Step 4, byte wise rank, subtract the rank with byte at b-8, or zero for b=0;\n    assert 0L <= l : l;\n    //assert l < 8 : l; //fails when bit r is not available.\n\n    // Select bit l from byte (x >>> b):\n    long spr = (((x >>> b) & 0xFFL) * L8_L) & L9_L; // spread the 8 bits of the byte at b over the long at L9 positions\n\n    // long spr_bigger8_zero = smaller8(0L, spr); // inlined smaller8 with 0L argument:\n    // FIXME: replace by biggerequal8_one formula from article page 6, line 9. four operators instead of five here.\n    long spr_bigger8_zero = ( ( H8_L - (spr & (~H8_L)) ) ^ (~spr) ) & H8_L;\n    s = (spr_bigger8_zero >>> 7) * L8_L; // Step 5, sideways byte add the 8 bits towards the high byte\n\n    int res = (int) (b + (((smallerUpTo7_8(s, (l * L8_L)) >>> 7) * L8_L) >>> 56)); // Step 6\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"423470dff9e19aa0db92590e282e2ca12e34d65a","date":1381851051,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BroadWord#select(long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BroadWord#select9(long,int).mjava","sourceNew":"  /** Select a 1-bit from a long.\n   * @return The index of the r-th 1 bit in x, or if no such bit exists, 72.\n   */\n  public static int select(long x, int r) {\n    long s = x - ((x & 0xAAAAAAAAAAAAAAAAL) >>> 1); // Step 0, pairwise bitsums\n\n    // Correct a small mistake in algorithm 2:\n    // Use s instead of x the second time in right shift 2, compare to Algorithm 1 in rank9 above.\n    s = (s & 0x3333333333333333L) + ((s >>> 2) & 0x3333333333333333L); // Step 1, nibblewise bitsums\n\n    s = ((s + (s >>> 4)) & 0x0F0F0F0F0F0F0F0FL) * L8_L; // Step 2, bytewise bitsums\n\n    long b = ((smallerUpTo7_8(s, (r * L8_L)) >>> 7) * L8_L) >>> 53; // & (~7L); // Step 3, side ways addition for byte number times 8\n\n    long l = r - (((s << 8) >>> b) & 0xFFL); // Step 4, byte wise rank, subtract the rank with byte at b-8, or zero for b=0;\n    assert 0L <= l : l;\n    //assert l < 8 : l; //fails when bit r is not available.\n\n    // Select bit l from byte (x >>> b):\n    long spr = (((x >>> b) & 0xFFL) * L8_L) & L9_L; // spread the 8 bits of the byte at b over the long at L9 positions\n\n    // long spr_bigger8_zero = smaller8(0L, spr); // inlined smaller8 with 0L argument:\n    // FIXME: replace by biggerequal8_one formula from article page 6, line 9. four operators instead of five here.\n    long spr_bigger8_zero = ( ( H8_L - (spr & (~H8_L)) ) ^ (~spr) ) & H8_L;\n    s = (spr_bigger8_zero >>> 7) * L8_L; // Step 5, sideways byte add the 8 bits towards the high byte\n\n    int res = (int) (b + (((smallerUpTo7_8(s, (l * L8_L)) >>> 7) * L8_L) >>> 56)); // Step 6\n    return res;\n  }\n\n","sourceOld":"  /** Select a 1-bit from a long.\n   * @return The index of the r-th 1 bit in x, or if no such bit exists, 72.\n   */\n  public static int select9(long x, int r) {\n    long s = x - ((x & 0xAAAAAAAAAAAAAAAAL) >>> 1); // Step 0, pairwise bitsums\n\n    // Correct a small mistake in algorithm 2:\n    // Use s instead of x the second time in right shift 2, compare to Algorithm 1 in rank9 above.\n    s = (s & 0x3333333333333333L) + ((s >>> 2) & 0x3333333333333333L); // Step 1, nibblewise bitsums\n\n    s = ((s + (s >>> 4)) & 0x0F0F0F0F0F0F0F0FL) * L8_L; // Step 2, bytewise bitsums\n\n    long b = ((smallerUpTo7_8(s, (r * L8_L)) >>> 7) * L8_L) >>> 53; // & (~7L); // Step 3, side ways addition for byte number times 8\n\n    long l = r - (((s << 8) >>> b) & 0xFFL); // Step 4, byte wise rank, subtract the rank with byte at b-8, or zero for b=0;\n    assert 0L <= l : l;\n    //assert l < 8 : l; //fails when bit r is not available.\n\n    // Select bit l from byte (x >>> b):\n    long spr = (((x >>> b) & 0xFFL) * L8_L) & L9_L; // spread the 8 bits of the byte at b over the long at L9 positions\n\n    // long spr_bigger8_zero = smaller8(0L, spr); // inlined smaller8 with 0L argument:\n    // FIXME: replace by biggerequal8_one formula from article page 6, line 9. four operators instead of five here.\n    long spr_bigger8_zero = ( ( H8_L - (spr & (~H8_L)) ) ^ (~spr) ) & H8_L;\n    s = (spr_bigger8_zero >>> 7) * L8_L; // Step 5, sideways byte add the 8 bits towards the high byte\n\n    int res = (int) (b + (((smallerUpTo7_8(s, (l * L8_L)) >>> 7) * L8_L) >>> 56)); // Step 6\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0debe908d97b40345a206ca1671a9fd299833558"],"423470dff9e19aa0db92590e282e2ca12e34d65a":["0debe908d97b40345a206ca1671a9fd299833558"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["423470dff9e19aa0db92590e282e2ca12e34d65a"],"0debe908d97b40345a206ca1671a9fd299833558":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"423470dff9e19aa0db92590e282e2ca12e34d65a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","0debe908d97b40345a206ca1671a9fd299833558"],"0debe908d97b40345a206ca1671a9fd299833558":["37a0f60745e53927c4c876cfe5b5a58170f0646c","423470dff9e19aa0db92590e282e2ca12e34d65a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}