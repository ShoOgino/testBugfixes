{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","commits":[{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientDataProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    return data.computeIfAbsent(node, s -> Collections.emptyMap());//todo fill other details\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    return data.computeIfAbsent(node, s -> Collections.emptyMap());//todo fill other details\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bbcda32e5cd37ef61ea1190bacd080308e22070","date":1508850553,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          keyVsReplica.put(\"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\" + key, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    return data.computeIfAbsent(node, s -> Collections.emptyMap());//todo fill other details\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33ae23947c41339ea2b352422bb762dfb4a17077","date":1524235117,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          keyVsReplica.put(\"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\" + key, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          keyVsReplica.put(\"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\" + key, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c7c6f6f0da6860cdb9281d465d7189825f0440f","date":1528775232,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          String perReplicaAttrKeyPrefix = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          if(tagType == null) continue;\n          String perReplicaValue = tagType.metricsAttribute;\n          perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          perReplicaAttrKeyPrefix += perReplicaValue;\n          keyVsReplica.put(perReplicaAttrKeyPrefix, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          keyVsReplica.put(\"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\" + key, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8972c9f22193dd2a876d8bd6418457bc5b9dcd7","date":1528898850,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          String perReplicaAttrKeyPrefix = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaAttrKeyPrefix += perReplicaValue;\n          keyVsReplica.put(perReplicaAttrKeyPrefix, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          String perReplicaAttrKeyPrefix = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          if(tagType == null) continue;\n          String perReplicaValue = tagType.metricsAttribute;\n          perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          perReplicaAttrKeyPrefix += perReplicaValue;\n          keyVsReplica.put(perReplicaAttrKeyPrefix, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d6bec22994bec86702ad05304ae983f7be5b5a7","date":1530715192,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          String perReplicaAttrKeyPrefix = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaAttrKeyPrefix += perReplicaValue;\n          keyVsReplica.put(perReplicaAttrKeyPrefix, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        Map<String, Object> tags = fetchReplicaMetrics(node,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        tags.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          String perReplicaAttrKeyPrefix = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaAttrKeyPrefix += perReplicaValue;\n          keyVsReplica.put(perReplicaAttrKeyPrefix, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          String perReplicaAttrKeyPrefix = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaAttrKeyPrefix += perReplicaValue;\n          keyVsReplica.put(perReplicaAttrKeyPrefix, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        Map<String, Object> tags = fetchReplicaMetrics(node,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        tags.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          keyVsReplica.put(\"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\" + key, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          String perReplicaAttrKeyPrefix = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaAttrKeyPrefix += perReplicaValue;\n          keyVsReplica.put(perReplicaAttrKeyPrefix, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        Map<String, Object> tags = fetchReplicaMetrics(node,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        tags.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          keyVsReplica.put(\"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\" + key, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        ClientSnitchCtx ctx = new ClientSnitchCtx(null, null, emptyMap(), solrClient);\n        fetchMetrics(node, ctx,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        ctx.getTags().forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733","date":1532604765,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = metricsKeyVsTagReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> keyVsReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;\n          String perReplicaAttrKeyPrefix = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaAttrKeyPrefix += perReplicaValue;\n          keyVsReplica.put(perReplicaAttrKeyPrefix, new Pair<>(key, r));\n        }\n      });\n\n      if (!keyVsReplica.isEmpty()) {\n        Map<String, Object> tags = fetchReplicaMetrics(node,\n            keyVsReplica.entrySet().stream()\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getKey)));\n        tags.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = keyVsReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"427edb17549d4bb82462a16eec4ee0533d12d5b7","date":1533006754,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Type tagType = VariableBase.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = metricsKeyVsTagReplica.get(k);\n          Type validator = VariableBase.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Suggestion.ConditionType tagType = Suggestion.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = metricsKeyVsTagReplica.get(k);\n          Suggestion.ConditionType validator = Suggestion.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58e890cd5653ae8550bc6088d739f4eaaf950aff","date":1547036285,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, Utils.NEW_HASHMAP_FUN);\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Type tagType = VariableBase.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = metricsKeyVsTagReplica.get(k);\n          Type validator = VariableBase.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, s -> emptyMap());\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Type tagType = VariableBase.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = metricsKeyVsTagReplica.get(k);\n          Type validator = VariableBase.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d","date":1592006776,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, Utils.NEW_HASHMAP_FUN);\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Type tagType = VariableBase.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = metricsKeyVsTagReplica.get(k);\n          Type validator = VariableBase.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, Utils.NEW_HASHMAP_FUN);\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Type tagType = VariableBase.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = metricsKeyVsTagReplica.get(k);\n          Type validator = VariableBase.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<Replica>>> getReplicaInfo(String node, Collection<String> keys) {\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Map<String, List<Replica>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, Utils.NEW_HASHMAP_FUN);\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, Replica>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getProperties().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCoreName()) + \":\";\n          Type tagType = VariableBase.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, Replica> p = metricsKeyVsTagReplica.get(k);\n          Type validator = VariableBase.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getProperties().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Map<String, List<ReplicaInfo>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, Utils.NEW_HASHMAP_FUN);\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, ReplicaInfo>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getVariables().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCore()) + \":\";\n          Type tagType = VariableBase.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, ReplicaInfo> p = metricsKeyVsTagReplica.get(k);\n          Type validator = VariableBase.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getVariables().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<Replica>>> getReplicaInfo(String node, Collection<String> keys) {\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Map<String, List<Replica>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, Utils.NEW_HASHMAP_FUN);\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, Replica>> metricsKeyVsTagReplica = new HashMap<>();\n      forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getProperties().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCoreName()) + \":\";\n          String perReplicaValue = key;\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, Replica> p = metricsKeyVsTagReplica.get(k);\n          if (p.second() != null) p.second().getProperties().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<Replica>>> getReplicaInfo(String node, Collection<String> keys) {\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Map<String, List<Replica>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, Utils.NEW_HASHMAP_FUN);\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, Replica>> metricsKeyVsTagReplica = new HashMap<>();\n      Row.forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getProperties().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCoreName()) + \":\";\n          Type tagType = VariableBase.getTagType(key);\n          String perReplicaValue = key;\n          if (tagType != null) {\n            perReplicaValue = tagType.metricsAttribute;\n            perReplicaValue = perReplicaValue == null ? key : perReplicaValue;\n          }\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, Replica> p = metricsKeyVsTagReplica.get(k);\n          Type validator = VariableBase.getTagType(p.first());\n          if (validator != null) o = validator.convertVal(o);\n          if (p.second() != null) p.second().getProperties().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5143a137c6366836cdc47feaad23a1f86ba50c3b","date":1599311985,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/SolrClientNodeStateProvider#getReplicaInfo(String,Collection[String]).mjava","sourceNew":"  @Override\n  public Map<String, Map<String, List<Replica>>> getReplicaInfo(String node, Collection<String> keys) {\n    Map<String, Map<String, List<Replica>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, o -> new HashMap<>());    if (!keys.isEmpty()) {\n      Map<String, Pair<String, Replica>> metricsKeyVsTagReplica = new HashMap<>();\n      forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getProperties().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCoreName()) + \":\";\n          String perReplicaValue = key;\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, Replica> p = metricsKeyVsTagReplica.get(k);\n          if (p.second() != null) p.second().getProperties().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Map<String, List<Replica>>> getReplicaInfo(String node, Collection<String> keys) {\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Map<String, List<Replica>>> result = nodeVsCollectionVsShardVsReplicaInfo.computeIfAbsent(node, Utils.NEW_HASHMAP_FUN);\n    if (!keys.isEmpty()) {\n      Map<String, Pair<String, Replica>> metricsKeyVsTagReplica = new HashMap<>();\n      forEachReplica(result, r -> {\n        for (String key : keys) {\n          if (r.getProperties().containsKey(key)) continue;// it's already collected\n          String perReplicaMetricsKey = \"solr.core.\" + r.getCollection() + \".\" + r.getShard() + \".\" + Utils.parseMetricsReplicaName(r.getCollection(), r.getCoreName()) + \":\";\n          String perReplicaValue = key;\n          perReplicaMetricsKey += perReplicaValue;\n          metricsKeyVsTagReplica.put(perReplicaMetricsKey, new Pair<>(key, r));\n        }\n      });\n\n      if (!metricsKeyVsTagReplica.isEmpty()) {\n        Map<String, Object> tagValues = fetchReplicaMetrics(node, metricsKeyVsTagReplica);\n        tagValues.forEach((k, o) -> {\n          Pair<String, Replica> p = metricsKeyVsTagReplica.get(k);\n          if (p.second() != null) p.second().getProperties().put(p.first(), o);\n        });\n\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["58e890cd5653ae8550bc6088d739f4eaaf950aff"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733":["7d6bec22994bec86702ad05304ae983f7be5b5a7"],"7d6bec22994bec86702ad05304ae983f7be5b5a7":["e8972c9f22193dd2a876d8bd6418457bc5b9dcd7"],"5143a137c6366836cdc47feaad23a1f86ba50c3b":["3f504512a03d978990cbff30db0522b354e846db"],"58e890cd5653ae8550bc6088d739f4eaaf950aff":["427edb17549d4bb82462a16eec4ee0533d12d5b7"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["33ae23947c41339ea2b352422bb762dfb4a17077","7d6bec22994bec86702ad05304ae983f7be5b5a7"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"427edb17549d4bb82462a16eec4ee0533d12d5b7":["7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8c7c6f6f0da6860cdb9281d465d7189825f0440f":["33ae23947c41339ea2b352422bb762dfb4a17077"],"33ae23947c41339ea2b352422bb762dfb4a17077":["1bbcda32e5cd37ef61ea1190bacd080308e22070"],"1bbcda32e5cd37ef61ea1190bacd080308e22070":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"e8972c9f22193dd2a876d8bd6418457bc5b9dcd7":["8c7c6f6f0da6860cdb9281d465d7189825f0440f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5143a137c6366836cdc47feaad23a1f86ba50c3b"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["33ae23947c41339ea2b352422bb762dfb4a17077","7d6bec22994bec86702ad05304ae983f7be5b5a7"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["5143a137c6366836cdc47feaad23a1f86ba50c3b"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["1bbcda32e5cd37ef61ea1190bacd080308e22070"],"7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733":["427edb17549d4bb82462a16eec4ee0533d12d5b7"],"7d6bec22994bec86702ad05304ae983f7be5b5a7":["7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"5143a137c6366836cdc47feaad23a1f86ba50c3b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"58e890cd5653ae8550bc6088d739f4eaaf950aff":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"427edb17549d4bb82462a16eec4ee0533d12d5b7":["58e890cd5653ae8550bc6088d739f4eaaf950aff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"8c7c6f6f0da6860cdb9281d465d7189825f0440f":["e8972c9f22193dd2a876d8bd6418457bc5b9dcd7"],"33ae23947c41339ea2b352422bb762dfb4a17077":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","8c7c6f6f0da6860cdb9281d465d7189825f0440f","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"1bbcda32e5cd37ef61ea1190bacd080308e22070":["33ae23947c41339ea2b352422bb762dfb4a17077"],"e8972c9f22193dd2a876d8bd6418457bc5b9dcd7":["7d6bec22994bec86702ad05304ae983f7be5b5a7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}