{"path":"lucene/queries/src/test/org/apache/lucene/queries/intervals/TestIntervalQuery#testScoring().mjava","commits":[{"id":"97ee2282ff806e9bc9d705f389cf40451ab81c3e","date":1561721333,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/intervals/TestIntervalQuery#testScoring().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestIntervalQuery#testScoring().mjava","sourceNew":"  public void testScoring() throws IOException {\n\n    IntervalsSource source = Intervals.ordered(Intervals.or(Intervals.term(\"w1\"), Intervals.term(\"w2\")), Intervals.term(\"w3\"));\n\n    Query q = new IntervalQuery(field, source);\n    TopDocs td = searcher.search(q, 10);\n    assertEquals(5, td.totalHits.value);\n    assertEquals(1, td.scoreDocs[0].doc);\n    assertEquals(3, td.scoreDocs[1].doc);\n    assertEquals(0, td.scoreDocs[2].doc);\n    assertEquals(5, td.scoreDocs[3].doc);\n    assertEquals(2, td.scoreDocs[4].doc);\n\n    Query boostQ = new BoostQuery(q, 2);\n    TopDocs boostTD = searcher.search(boostQ, 10);\n    assertEquals(5, boostTD.totalHits.value);\n    for (int i = 0; i < 5; i++) {\n      assertEquals(td.scoreDocs[i].score * 2, boostTD.scoreDocs[i].score, 0);\n    }\n\n    // change the pivot - order should remain the same\n    Query q1 = new IntervalQuery(field, source, 2);\n    TopDocs td1 = searcher.search(q1, 10);\n    assertEquals(5, td1.totalHits.value);\n    assertEquals(0.5f, td1.scoreDocs[0].score, 0);  // freq=pivot\n    for (int i = 0; i < 5; i++) {\n      assertEquals(td.scoreDocs[i].doc, td1.scoreDocs[i].doc);\n    }\n\n    // increase the exp, docs higher than pivot should get a higher score, and vice versa\n    Query q2 = new IntervalQuery(field, source, 1.2f, 2f);\n    TopDocs td2 = searcher.search(q2, 10);\n    assertEquals(5, td2.totalHits.value);\n    for (int i = 0; i < 5; i++) {\n      assertEquals(td.scoreDocs[i].doc, td2.scoreDocs[i].doc);\n      if (i < 2) {\n        assertTrue(td.scoreDocs[i].score < td2.scoreDocs[i].score);\n      }\n      else {\n        assertTrue(td.scoreDocs[i].score > td2.scoreDocs[i].score);\n      }\n    }\n\n    // check valid bounds\n    expectThrows(IllegalArgumentException.class, () -> new IntervalQuery(field, source, -1));\n    expectThrows(IllegalArgumentException.class, () -> new IntervalQuery(field, source, 1, -1f));\n  }\n\n","sourceOld":"  public void testScoring() throws IOException {\n\n    IntervalsSource source = Intervals.ordered(Intervals.or(Intervals.term(\"w1\"), Intervals.term(\"w2\")), Intervals.term(\"w3\"));\n\n    Query q = new IntervalQuery(field, source);\n    TopDocs td = searcher.search(q, 10);\n    assertEquals(5, td.totalHits.value);\n    assertEquals(1, td.scoreDocs[0].doc);\n    assertEquals(3, td.scoreDocs[1].doc);\n    assertEquals(0, td.scoreDocs[2].doc);\n    assertEquals(5, td.scoreDocs[3].doc);\n    assertEquals(2, td.scoreDocs[4].doc);\n\n    Query boostQ = new BoostQuery(q, 2);\n    TopDocs boostTD = searcher.search(boostQ, 10);\n    assertEquals(5, boostTD.totalHits.value);\n    for (int i = 0; i < 5; i++) {\n      assertEquals(td.scoreDocs[i].score * 2, boostTD.scoreDocs[i].score, 0);\n    }\n\n    // change the pivot - order should remain the same\n    Query q1 = new IntervalQuery(field, source, 2);\n    TopDocs td1 = searcher.search(q1, 10);\n    assertEquals(5, td1.totalHits.value);\n    assertEquals(0.5f, td1.scoreDocs[0].score, 0);  // freq=pivot\n    for (int i = 0; i < 5; i++) {\n      assertEquals(td.scoreDocs[i].doc, td1.scoreDocs[i].doc);\n    }\n\n    // increase the exp, docs higher than pivot should get a higher score, and vice versa\n    Query q2 = new IntervalQuery(field, source, 1.2f, 2f);\n    TopDocs td2 = searcher.search(q2, 10);\n    assertEquals(5, td2.totalHits.value);\n    for (int i = 0; i < 5; i++) {\n      assertEquals(td.scoreDocs[i].doc, td2.scoreDocs[i].doc);\n      if (i < 2) {\n        assertTrue(td.scoreDocs[i].score < td2.scoreDocs[i].score);\n      }\n      else {\n        assertTrue(td.scoreDocs[i].score > td2.scoreDocs[i].score);\n      }\n    }\n\n    // check valid bounds\n    expectThrows(IllegalArgumentException.class, () -> new IntervalQuery(field, source, -1));\n    expectThrows(IllegalArgumentException.class, () -> new IntervalQuery(field, source, 1, -1f));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"97ee2282ff806e9bc9d705f389cf40451ab81c3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["97ee2282ff806e9bc9d705f389cf40451ab81c3e"]},"commit2Childs":{"97ee2282ff806e9bc9d705f389cf40451ab81c3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["97ee2282ff806e9bc9d705f389cf40451ab81c3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}