{"path":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","commits":[{"id":"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51","date":1431446228,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, rewrittenFromQuery, min, max, indexReader);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["49295167555d1b1d83b7804d3f1c9727d1edbce2","1fc14bd6876a2b56962e850fadc6036b09b24660"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1fc14bd6876a2b56962e850fadc6036b09b24660","date":1438759112,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, indexReader);\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, indexReader);\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, rewrittenFromQuery, min, max, indexReader);\n  }\n\n","bugFix":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51"],"bugIntro":["49295167555d1b1d83b7804d3f1c9727d1edbce2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4778b794a897685e2f6c62caa1ac04983d1e69f","date":1467997674,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, indexReader);\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, indexReader);\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, indexReader);\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, indexReader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, indexReader);\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, indexReader);\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, indexReader);\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, indexReader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00dac8c26b1d79065732dc2d4fba46b9d0e4a26d","date":1490879512,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, searcher.getTopReaderContext());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, searcher.getTopReaderContext());\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, indexReader);\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, indexReader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"49295167555d1b1d83b7804d3f1c9727d1edbce2","date":1490968656,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, searcher.getTopReaderContext());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, searcher.getTopReaderContext());\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, indexReader);\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, indexReader);\n  }\n\n","bugFix":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51","1fc14bd6876a2b56962e850fadc6036b09b24660"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7","date":1495529154,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, searcher.getTopReaderContext());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, searcher.getTopReaderContext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, searcher.getTopReaderContext());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, rewrittenToQuery, rewrittenFromQuery, min, max, searcher.getTopReaderContext());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"957c610636f393a85a38f1af670540028db13e6b","date":1500044517,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":5,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"00dac8c26b1d79065732dc2d4fba46b9d0e4a26d":["f4778b794a897685e2f6c62caa1ac04983d1e69f"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["49295167555d1b1d83b7804d3f1c9727d1edbce2","00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7"],"957c610636f393a85a38f1af670540028db13e6b":["00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7"],"00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7":["00dac8c26b1d79065732dc2d4fba46b9d0e4a26d"],"49295167555d1b1d83b7804d3f1c9727d1edbce2":["f4778b794a897685e2f6c62caa1ac04983d1e69f"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["e9017cf144952056066919f1ebc7897ff9bd71b1","957c610636f393a85a38f1af670540028db13e6b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f4778b794a897685e2f6c62caa1ac04983d1e69f":["1fc14bd6876a2b56962e850fadc6036b09b24660"],"1fc14bd6876a2b56962e850fadc6036b09b24660":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["1fc14bd6876a2b56962e850fadc6036b09b24660","f4778b794a897685e2f6c62caa1ac04983d1e69f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["957c610636f393a85a38f1af670540028db13e6b"],"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"00dac8c26b1d79065732dc2d4fba46b9d0e4a26d":["00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["aaf90fc29510e72665ac7934f34c3d1c25efad64"],"00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7":["e9017cf144952056066919f1ebc7897ff9bd71b1","957c610636f393a85a38f1af670540028db13e6b"],"957c610636f393a85a38f1af670540028db13e6b":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"49295167555d1b1d83b7804d3f1c9727d1edbce2":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51"],"f4778b794a897685e2f6c62caa1ac04983d1e69f":["00dac8c26b1d79065732dc2d4fba46b9d0e4a26d","49295167555d1b1d83b7804d3f1c9727d1edbce2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"1fc14bd6876a2b56962e850fadc6036b09b24660":["f4778b794a897685e2f6c62caa1ac04983d1e69f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51":["1fc14bd6876a2b56962e850fadc6036b09b24660"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}