{"path":"lucene/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","commits":[{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<Integer>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          Transition[] transitions = sortedTransitions[state];\n          if (transitions.length == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else if (label-1 < transitions[0].min) {\n\n            if (runAutomaton.isAccept(state)) {\n              output.length = idx;\n              //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n              return output;\n            }\n            // pop\n            if (stack.size() == 0) {\n              //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n              return null;\n            } else {\n              state = stack.remove(stack.size()-1);\n              idx--;\n              //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n              label = input.bytes[input.offset + idx] & 0xff;\n            }\n\n          } else {\n            //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n            break;\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<Integer>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          Transition[] transitions = sortedTransitions[state];\n          if (transitions.length == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else if (label-1 < transitions[0].min) {\n\n            if (runAutomaton.isAccept(state)) {\n              output.length = idx;\n              //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n              return output;\n            }\n            // pop\n            if (stack.size() == 0) {\n              //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n              return null;\n            } else {\n              state = stack.remove(stack.size()-1);\n              idx--;\n              //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n              label = input.bytes[input.offset + idx] & 0xff;\n            }\n\n          } else {\n            //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n            break;\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<Integer>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          Transition[] transitions = sortedTransitions[state];\n          if (transitions.length == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else if (label-1 < transitions[0].min) {\n\n            if (runAutomaton.isAccept(state)) {\n              output.length = idx;\n              //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n              return output;\n            }\n            // pop\n            if (stack.size() == 0) {\n              //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n              return null;\n            } else {\n              state = stack.remove(stack.size()-1);\n              idx--;\n              //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n              label = input.bytes[input.offset + idx] & 0xff;\n            }\n\n          } else {\n            //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n            break;\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}