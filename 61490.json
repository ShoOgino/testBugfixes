{"path":"solr/core/src/java/org/apache/solr/search/facet/BlockJoin#toChildren(DocSet,BitDocSet,DocSet,QueryContext).mjava","commits":[{"id":"9e47fba8dd946896c408eb448f6199f5a9f0da2d","date":1434234768,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/BlockJoin#toChildren(DocSet,BitDocSet,DocSet,QueryContext).mjava","pathOld":"/dev/null","sourceNew":"  /** acceptDocs will normally be used to avoid deleted documents from being generated as part of the answer DocSet (just use *:*)\n   *  although it can be used to further constrain the generated documents.\n   */\n  public static DocSet toChildren(DocSet parentInput, BitDocSet parentList, DocSet acceptDocs, QueryContext qcontext) throws IOException {\n    FixedBitSet parentBits = parentList.getBits();\n    DocSetCollector collector = new DocSetCollector(qcontext.searcher().maxDoc()>>6, qcontext.searcher().maxDoc());\n    DocIterator iter = parentInput.iterator();\n    while (iter.hasNext()) {\n      int parentDoc = iter.nextDoc();\n      if (!parentList.exists(parentDoc) || parentDoc == 0) { // test for parentDoc==0 here to avoid passing -1 to prevSetBit later on\n        // not a parent, or parent has no children\n        continue;\n      }\n      int prevParent = parentBits.prevSetBit(parentDoc - 1);\n      for (int childDoc = prevParent+1; childDoc<parentDoc; childDoc++) {\n        if (acceptDocs != null && !acceptDocs.exists(childDoc)) continue;  // only select live docs\n        collector.collect(childDoc);\n      }\n    }\n    return collector.getDocSet();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0","date":1442027674,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/BlockJoin#toChildren(DocSet,BitDocSet,DocSet,QueryContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/BlockJoin#toChildren(DocSet,BitDocSet,DocSet,QueryContext).mjava","sourceNew":"  /** acceptDocs will normally be used to avoid deleted documents from being generated as part of the answer DocSet (just use *:*)\n   *  although it can be used to further constrain the generated documents.\n   */\n  public static DocSet toChildren(DocSet parentInput, BitDocSet parentList, DocSet acceptDocs, QueryContext qcontext) throws IOException {\n    FixedBitSet parentBits = parentList.getBits();\n    DocSetCollector collector = new DocSetCollector(qcontext.searcher().maxDoc());\n    DocIterator iter = parentInput.iterator();\n    while (iter.hasNext()) {\n      int parentDoc = iter.nextDoc();\n      if (!parentList.exists(parentDoc) || parentDoc == 0) { // test for parentDoc==0 here to avoid passing -1 to prevSetBit later on\n        // not a parent, or parent has no children\n        continue;\n      }\n      int prevParent = parentBits.prevSetBit(parentDoc - 1);\n      for (int childDoc = prevParent+1; childDoc<parentDoc; childDoc++) {\n        if (acceptDocs != null && !acceptDocs.exists(childDoc)) continue;  // only select live docs\n        collector.collect(childDoc);\n      }\n    }\n    return collector.getDocSet();\n  }\n\n","sourceOld":"  /** acceptDocs will normally be used to avoid deleted documents from being generated as part of the answer DocSet (just use *:*)\n   *  although it can be used to further constrain the generated documents.\n   */\n  public static DocSet toChildren(DocSet parentInput, BitDocSet parentList, DocSet acceptDocs, QueryContext qcontext) throws IOException {\n    FixedBitSet parentBits = parentList.getBits();\n    DocSetCollector collector = new DocSetCollector(qcontext.searcher().maxDoc()>>6, qcontext.searcher().maxDoc());\n    DocIterator iter = parentInput.iterator();\n    while (iter.hasNext()) {\n      int parentDoc = iter.nextDoc();\n      if (!parentList.exists(parentDoc) || parentDoc == 0) { // test for parentDoc==0 here to avoid passing -1 to prevSetBit later on\n        // not a parent, or parent has no children\n        continue;\n      }\n      int prevParent = parentBits.prevSetBit(parentDoc - 1);\n      for (int childDoc = prevParent+1; childDoc<parentDoc; childDoc++) {\n        if (acceptDocs != null && !acceptDocs.exists(childDoc)) continue;  // only select live docs\n        collector.collect(childDoc);\n      }\n    }\n    return collector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9e47fba8dd946896c408eb448f6199f5a9f0da2d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["9e47fba8dd946896c408eb448f6199f5a9f0da2d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"]},"commit2Childs":{"9e47fba8dd946896c408eb448f6199f5a9f0da2d":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9e47fba8dd946896c408eb448f6199f5a9f0da2d"],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}