{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","commits":[{"id":"d907c28c7fe6305eaec1756d51365f5149e1e41d","date":1512533044,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","pathOld":"/dev/null","sourceNew":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            TimeUnit.SECONDS.convert(System.nanoTime() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(MILLISECONDS), timeElapsed(waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            //the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","sourceNew":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            TimeUnit.SECONDS.convert(timeSource.getTime() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            //the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            TimeUnit.SECONDS.convert(System.nanoTime() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(MILLISECONDS), timeElapsed(waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            //the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4412883c12067d8a4e2a354aa8adc58c32be1d6","date":1521129281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","sourceNew":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            //the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            TimeUnit.SECONDS.convert(timeSource.getTime() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            //the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27639bb5e041490ce599065875dd2f6d8beef62a","date":1532829373,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","sourceNew":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            // the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            //the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8854763f018feadbb30c35a83fd9599adb51ef63","date":1534341747,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","sourceNew":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            // the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            // the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","sourceNew":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            if (log.isDebugEnabled()) {\n              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            }\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            if (log.isDebugEnabled()) {\n              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            }\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            // the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            log.debug(\"out of waiting curr-time:{} time-elapsed {}\", time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            // the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e17627eb9673daf01d17fdfb583c621c55c34208","date":1593028963,"type":4,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#get(SolrCloudManager).mjava","sourceNew":null,"sourceOld":"    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n      TimeSource timeSource = cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        if (sessionWrapper.status == Status.NULL ||\n            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n          //no session available or the session is expired\n          return createSession(cloudManager);\n        } else {\n          long waitStart = time(timeSource, MILLISECONDS);\n          //the session is not expired\n          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n            this.sessionWrapper.status = Status.COMPUTING;\n            return sessionWrapper;\n          } else {\n            //status= COMPUTING it's being used for computing. computing is\n            if (log.isDebugEnabled()) {\n              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n            }\n            try {\n              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n            } catch (InterruptedException e) {\n              log.info(\"interrupted... \");\n            }\n            if (log.isDebugEnabled()) {\n              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n            }\n            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n            // the session was returned from another COMPUTING operation\n            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n              log.debug(\"Wait over. reusing the existing session \");\n              this.sessionWrapper.status = Status.COMPUTING;\n              return sessionWrapper;\n            } else {\n              //create a new Session\n              return createSession(cloudManager);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e17627eb9673daf01d17fdfb583c621c55c34208":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["8854763f018feadbb30c35a83fd9599adb51ef63"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"8854763f018feadbb30c35a83fd9599adb51ef63":["27639bb5e041490ce599065875dd2f6d8beef62a"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["d907c28c7fe6305eaec1756d51365f5149e1e41d"],"27639bb5e041490ce599065875dd2f6d8beef62a":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e17627eb9673daf01d17fdfb583c621c55c34208"],"d907c28c7fe6305eaec1756d51365f5149e1e41d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"e17627eb9673daf01d17fdfb583c621c55c34208":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["e17627eb9673daf01d17fdfb583c621c55c34208"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d907c28c7fe6305eaec1756d51365f5149e1e41d"],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["27639bb5e041490ce599065875dd2f6d8beef62a"],"8854763f018feadbb30c35a83fd9599adb51ef63":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"27639bb5e041490ce599065875dd2f6d8beef62a":["8854763f018feadbb30c35a83fd9599adb51ef63"],"d907c28c7fe6305eaec1756d51365f5149e1e41d":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}