{"path":"lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier#getWordFreqForClassess(String).mjava","commits":[{"id":"f42902644d0afd11c1be38fd0b0e8237bf4f4d7e","date":1408694655,"type":0,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier#getWordFreqForClassess(String).mjava","pathOld":"/dev/null","sourceNew":"  private Map<BytesRef, Integer> getWordFreqForClassess(String word) throws IOException {\n\n    Map<BytesRef, Integer> insertPoint;\n    insertPoint = termCClassHitCache.get(word);\n\n    // if we get the answer from the cache\n    if (insertPoint != null) {\n      if (!insertPoint.isEmpty()) {\n        return insertPoint;\n      }\n    }\n\n    Map<BytesRef, Integer> searched = new ConcurrentHashMap<>();\n\n    // if we dont get the answer, but its relevant we must search it and insert to the cache\n    if (insertPoint != null || !justCachedTerms) {\n      for (BytesRef cclass : cclasses) {\n        BooleanQuery booleanQuery = new BooleanQuery();\n        BooleanQuery subQuery = new BooleanQuery();\n        for (String textFieldName : textFieldNames) {\n          subQuery.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));\n        }\n        booleanQuery.add(new BooleanClause(subQuery, BooleanClause.Occur.MUST));\n        booleanQuery.add(new BooleanClause(new TermQuery(new Term(classFieldName, cclass)), BooleanClause.Occur.MUST));\n        if (query != null) {\n          booleanQuery.add(query, BooleanClause.Occur.MUST);\n        }\n        TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n        indexSearcher.search(booleanQuery, totalHitCountCollector);\n\n        int ret = totalHitCountCollector.getTotalHits();\n        if (ret != 0) {\n          searched.put(cclass, ret);\n        }\n      }\n      if (insertPoint != null) {\n        // threadsafe and concurent write\n        termCClassHitCache.put(word, searched);\n      }\n    }\n\n    return searched;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier#getWordFreqForClassess(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier#getWordFreqForClassess(String).mjava","sourceNew":"  private Map<BytesRef, Integer> getWordFreqForClassess(String word) throws IOException {\n\n    Map<BytesRef, Integer> insertPoint;\n    insertPoint = termCClassHitCache.get(word);\n\n    // if we get the answer from the cache\n    if (insertPoint != null) {\n      if (!insertPoint.isEmpty()) {\n        return insertPoint;\n      }\n    }\n\n    Map<BytesRef, Integer> searched = new ConcurrentHashMap<>();\n\n    // if we dont get the answer, but it's relevant we must search it and insert to the cache\n    if (insertPoint != null || !justCachedTerms) {\n      for (BytesRef cclass : cclasses) {\n        BooleanQuery booleanQuery = new BooleanQuery();\n        BooleanQuery subQuery = new BooleanQuery();\n        for (String textFieldName : textFieldNames) {\n          subQuery.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));\n        }\n        booleanQuery.add(new BooleanClause(subQuery, BooleanClause.Occur.MUST));\n        booleanQuery.add(new BooleanClause(new TermQuery(new Term(classFieldName, cclass)), BooleanClause.Occur.MUST));\n        if (query != null) {\n          booleanQuery.add(query, BooleanClause.Occur.MUST);\n        }\n        TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n        indexSearcher.search(booleanQuery, totalHitCountCollector);\n\n        int ret = totalHitCountCollector.getTotalHits();\n        if (ret != 0) {\n          searched.put(cclass, ret);\n        }\n      }\n      if (insertPoint != null) {\n        // threadsafe and concurent write\n        termCClassHitCache.put(word, searched);\n      }\n    }\n\n    return searched;\n  }\n\n","sourceOld":"  private Map<BytesRef, Integer> getWordFreqForClassess(String word) throws IOException {\n\n    Map<BytesRef, Integer> insertPoint;\n    insertPoint = termCClassHitCache.get(word);\n\n    // if we get the answer from the cache\n    if (insertPoint != null) {\n      if (!insertPoint.isEmpty()) {\n        return insertPoint;\n      }\n    }\n\n    Map<BytesRef, Integer> searched = new ConcurrentHashMap<>();\n\n    // if we dont get the answer, but its relevant we must search it and insert to the cache\n    if (insertPoint != null || !justCachedTerms) {\n      for (BytesRef cclass : cclasses) {\n        BooleanQuery booleanQuery = new BooleanQuery();\n        BooleanQuery subQuery = new BooleanQuery();\n        for (String textFieldName : textFieldNames) {\n          subQuery.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));\n        }\n        booleanQuery.add(new BooleanClause(subQuery, BooleanClause.Occur.MUST));\n        booleanQuery.add(new BooleanClause(new TermQuery(new Term(classFieldName, cclass)), BooleanClause.Occur.MUST));\n        if (query != null) {\n          booleanQuery.add(query, BooleanClause.Occur.MUST);\n        }\n        TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n        indexSearcher.search(booleanQuery, totalHitCountCollector);\n\n        int ret = totalHitCountCollector.getTotalHits();\n        if (ret != 0) {\n          searched.put(cclass, ret);\n        }\n      }\n      if (insertPoint != null) {\n        // threadsafe and concurent write\n        termCClassHitCache.put(word, searched);\n      }\n    }\n\n    return searched;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier#getWordFreqForClassess(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier#getWordFreqForClassess(String).mjava","sourceNew":"  private Map<BytesRef, Integer> getWordFreqForClassess(String word) throws IOException {\n\n    Map<BytesRef, Integer> insertPoint;\n    insertPoint = termCClassHitCache.get(word);\n\n    // if we get the answer from the cache\n    if (insertPoint != null) {\n      if (!insertPoint.isEmpty()) {\n        return insertPoint;\n      }\n    }\n\n    Map<BytesRef, Integer> searched = new ConcurrentHashMap<>();\n\n    // if we dont get the answer, but it's relevant we must search it and insert to the cache\n    if (insertPoint != null || !justCachedTerms) {\n      for (BytesRef cclass : cclasses) {\n        BooleanQuery.Builder booleanQuery = new BooleanQuery.Builder();\n        BooleanQuery.Builder subQuery = new BooleanQuery.Builder();\n        for (String textFieldName : textFieldNames) {\n          subQuery.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));\n        }\n        booleanQuery.add(new BooleanClause(subQuery.build(), BooleanClause.Occur.MUST));\n        booleanQuery.add(new BooleanClause(new TermQuery(new Term(classFieldName, cclass)), BooleanClause.Occur.MUST));\n        if (query != null) {\n          booleanQuery.add(query, BooleanClause.Occur.MUST);\n        }\n        TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n        indexSearcher.search(booleanQuery.build(), totalHitCountCollector);\n\n        int ret = totalHitCountCollector.getTotalHits();\n        if (ret != 0) {\n          searched.put(cclass, ret);\n        }\n      }\n      if (insertPoint != null) {\n        // threadsafe and concurent write\n        termCClassHitCache.put(word, searched);\n      }\n    }\n\n    return searched;\n  }\n\n","sourceOld":"  private Map<BytesRef, Integer> getWordFreqForClassess(String word) throws IOException {\n\n    Map<BytesRef, Integer> insertPoint;\n    insertPoint = termCClassHitCache.get(word);\n\n    // if we get the answer from the cache\n    if (insertPoint != null) {\n      if (!insertPoint.isEmpty()) {\n        return insertPoint;\n      }\n    }\n\n    Map<BytesRef, Integer> searched = new ConcurrentHashMap<>();\n\n    // if we dont get the answer, but it's relevant we must search it and insert to the cache\n    if (insertPoint != null || !justCachedTerms) {\n      for (BytesRef cclass : cclasses) {\n        BooleanQuery booleanQuery = new BooleanQuery();\n        BooleanQuery subQuery = new BooleanQuery();\n        for (String textFieldName : textFieldNames) {\n          subQuery.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));\n        }\n        booleanQuery.add(new BooleanClause(subQuery, BooleanClause.Occur.MUST));\n        booleanQuery.add(new BooleanClause(new TermQuery(new Term(classFieldName, cclass)), BooleanClause.Occur.MUST));\n        if (query != null) {\n          booleanQuery.add(query, BooleanClause.Occur.MUST);\n        }\n        TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n        indexSearcher.search(booleanQuery, totalHitCountCollector);\n\n        int ret = totalHitCountCollector.getTotalHits();\n        if (ret != 0) {\n          searched.put(cclass, ret);\n        }\n      }\n      if (insertPoint != null) {\n        // threadsafe and concurent write\n        termCClassHitCache.put(word, searched);\n      }\n    }\n\n    return searched;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ba9b7b122d927a15ff4837e3d72876c609fef1b","date":1441232513,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier#getWordFreqForClassess(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/CachingNaiveBayesClassifier#getWordFreqForClassess(String).mjava","sourceNew":"  private Map<BytesRef, Integer> getWordFreqForClassess(String word) throws IOException {\n\n    Map<BytesRef, Integer> insertPoint;\n    insertPoint = termCClassHitCache.get(word);\n\n    // if we get the answer from the cache\n    if (insertPoint != null) {\n      if (!insertPoint.isEmpty()) {\n        return insertPoint;\n      }\n    }\n\n    Map<BytesRef, Integer> searched = new ConcurrentHashMap<>();\n\n    // if we dont get the answer, but it's relevant we must search it and insert to the cache\n    if (insertPoint != null || !justCachedTerms) {\n      for (BytesRef cclass : cclasses) {\n        BooleanQuery.Builder booleanQuery = new BooleanQuery.Builder();\n        BooleanQuery.Builder subQuery = new BooleanQuery.Builder();\n        for (String textFieldName : textFieldNames) {\n          subQuery.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));\n        }\n        booleanQuery.add(new BooleanClause(subQuery.build(), BooleanClause.Occur.MUST));\n        booleanQuery.add(new BooleanClause(new TermQuery(new Term(classFieldName, cclass)), BooleanClause.Occur.MUST));\n        if (query != null) {\n          booleanQuery.add(query, BooleanClause.Occur.MUST);\n        }\n        TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n        indexSearcher.search(booleanQuery.build(), totalHitCountCollector);\n\n        int ret = totalHitCountCollector.getTotalHits();\n        if (ret != 0) {\n          searched.put(cclass, ret);\n        }\n      }\n      if (insertPoint != null) {\n        // threadsafe and concurrent write\n        termCClassHitCache.put(word, searched);\n      }\n    }\n\n    return searched;\n  }\n\n","sourceOld":"  private Map<BytesRef, Integer> getWordFreqForClassess(String word) throws IOException {\n\n    Map<BytesRef, Integer> insertPoint;\n    insertPoint = termCClassHitCache.get(word);\n\n    // if we get the answer from the cache\n    if (insertPoint != null) {\n      if (!insertPoint.isEmpty()) {\n        return insertPoint;\n      }\n    }\n\n    Map<BytesRef, Integer> searched = new ConcurrentHashMap<>();\n\n    // if we dont get the answer, but it's relevant we must search it and insert to the cache\n    if (insertPoint != null || !justCachedTerms) {\n      for (BytesRef cclass : cclasses) {\n        BooleanQuery.Builder booleanQuery = new BooleanQuery.Builder();\n        BooleanQuery.Builder subQuery = new BooleanQuery.Builder();\n        for (String textFieldName : textFieldNames) {\n          subQuery.add(new BooleanClause(new TermQuery(new Term(textFieldName, word)), BooleanClause.Occur.SHOULD));\n        }\n        booleanQuery.add(new BooleanClause(subQuery.build(), BooleanClause.Occur.MUST));\n        booleanQuery.add(new BooleanClause(new TermQuery(new Term(classFieldName, cclass)), BooleanClause.Occur.MUST));\n        if (query != null) {\n          booleanQuery.add(query, BooleanClause.Occur.MUST);\n        }\n        TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();\n        indexSearcher.search(booleanQuery.build(), totalHitCountCollector);\n\n        int ret = totalHitCountCollector.getTotalHits();\n        if (ret != 0) {\n          searched.put(cclass, ret);\n        }\n      }\n      if (insertPoint != null) {\n        // threadsafe and concurent write\n        termCClassHitCache.put(word, searched);\n      }\n    }\n\n    return searched;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ba9b7b122d927a15ff4837e3d72876c609fef1b":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"f42902644d0afd11c1be38fd0b0e8237bf4f4d7e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["f42902644d0afd11c1be38fd0b0e8237bf4f4d7e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ba9b7b122d927a15ff4837e3d72876c609fef1b"]},"commit2Childs":{"9ba9b7b122d927a15ff4837e3d72876c609fef1b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["9ba9b7b122d927a15ff4837e3d72876c609fef1b"],"f42902644d0afd11c1be38fd0b0e8237bf4f4d7e":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f42902644d0afd11c1be38fd0b0e8237bf4f4d7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}