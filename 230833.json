{"path":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","commits":[{"id":"042891089d57d0e6af18ea6cec15f9e9a7da7d25","date":1355271969,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(_TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(_TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext)) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(_TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n\n    log.info(\"Setting hostContext system property: \" + hostContext.toString());\n    System.setProperty(\"hostContext\", hostContext.toString());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ece860252a76fab30634d035713cb1412a84995","date":1355353340,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","sourceNew":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(_TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(_TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext)) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(_TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: \" + hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","sourceOld":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(_TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(_TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext)) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(_TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n\n    log.info(\"Setting hostContext system property: \" + hostContext.toString());\n    System.setProperty(\"hostContext\", hostContext.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(_TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(_TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext)) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(_TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: \" + hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c02e9bc43d4d3645636314e2a144951cc58ef90","date":1361133241,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","sourceNew":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(_TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(_TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext.toString())) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(_TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: \" + hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","sourceOld":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(_TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(_TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext)) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(_TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: \" + hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09c8567c25c02eeeb3e719841606a1269f3538ca","date":1361155063,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","sourceNew":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(_TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(_TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext.toString())) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(_TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: \" + hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","sourceOld":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(_TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(_TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext)) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(_TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: \" + hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","sourceNew":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext.toString())) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: \" + hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","sourceOld":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(_TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(_TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext.toString())) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(_TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: \" + hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#initHostContext().mjava","sourceNew":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext.toString())) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: {}\", hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","sourceOld":"  /**\n   * Set's the value of the \"hostContext\" system property to a random path \n   * like string (which may or may not contain sub-paths).  This is used \n   * in the default constructor for this test to help ensure no code paths have\n   * hardcoded assumptions about the servlet context used to run solr.\n   * <p>\n   * Test configs may use the <code>${hostContext}</code> variable to access \n   * this system property.\n   * </p>\n   * @see #BaseDistributedSearchTestCase()\n   * @see #clearHostContext\n   */\n  @BeforeClass\n  public static void initHostContext() {\n    // Can't use randomRealisticUnicodeString because unescaped unicode is \n    // not allowed in URL paths\n    // Can't use URLEncoder.encode(randomRealisticUnicodeString) because\n    // Jetty freaks out and returns 404's when the context uses escapes\n\n    StringBuilder hostContext = new StringBuilder(\"/\");\n    if (random().nextBoolean()) {\n      // half the time we use the root context, the other half...\n\n      // Remember: randomSimpleString might be the empty string\n      hostContext.append(TestUtil.randomSimpleString(random(), 2));\n      if (random().nextBoolean()) {\n        hostContext.append(\"_\");\n      }\n      hostContext.append(TestUtil.randomSimpleString(random(), 3));\n      if ( ! \"/\".equals(hostContext.toString())) {\n        // if our random string is empty, this might add a trailing slash, \n        // but our code should be ok with that\n        hostContext.append(\"/\").append(TestUtil.randomSimpleString(random(), 2));\n      } else {\n        // we got 'lucky' and still just have the root context,\n        // NOOP: don't try to add a subdir to nothing (ie \"//\" is bad)\n      }\n    }\n    // paranoia, we *really* don't want to ever get \"//\" in a path...\n    final String hc = hostContext.toString().replaceAll(\"\\\\/+\",\"/\");\n\n    log.info(\"Setting hostContext system property: \" + hc);\n    System.setProperty(\"hostContext\", hc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ece860252a76fab30634d035713cb1412a84995"],"042891089d57d0e6af18ea6cec15f9e9a7da7d25":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6613659748fe4411a7dcf85266e55db1f95f7315":["2c02e9bc43d4d3645636314e2a144951cc58ef90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["6613659748fe4411a7dcf85266e55db1f95f7315"],"2c02e9bc43d4d3645636314e2a144951cc58ef90":["0ece860252a76fab30634d035713cb1412a84995"],"0ece860252a76fab30634d035713cb1412a84995":["042891089d57d0e6af18ea6cec15f9e9a7da7d25"],"09c8567c25c02eeeb3e719841606a1269f3538ca":["0ece860252a76fab30634d035713cb1412a84995","2c02e9bc43d4d3645636314e2a144951cc58ef90"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"042891089d57d0e6af18ea6cec15f9e9a7da7d25":["0ece860252a76fab30634d035713cb1412a84995"],"6613659748fe4411a7dcf85266e55db1f95f7315":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","042891089d57d0e6af18ea6cec15f9e9a7da7d25"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ece860252a76fab30634d035713cb1412a84995":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","2c02e9bc43d4d3645636314e2a144951cc58ef90","09c8567c25c02eeeb3e719841606a1269f3538ca"],"2c02e9bc43d4d3645636314e2a144951cc58ef90":["6613659748fe4411a7dcf85266e55db1f95f7315","09c8567c25c02eeeb3e719841606a1269f3538ca"],"09c8567c25c02eeeb3e719841606a1269f3538ca":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","09c8567c25c02eeeb3e719841606a1269f3538ca","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}