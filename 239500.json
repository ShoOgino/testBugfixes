{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AbstractAnalysisFactory#lookupSPIName(Class[#-extends-AbstractAnalysisFactory]).mjava","commits":[{"id":"5bc9864ea60454f962db6e9f89d513bc9a6fffee","date":1561864788,"type":0,"author":"Tomoko Uchida","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AbstractAnalysisFactory#lookupSPIName(Class[#-extends-AbstractAnalysisFactory]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Looks up SPI name (static \"NAME\" field) with appropriate modifiers.\n   * Also it must be a String class and declared in the concrete class.\n   * @return the SPI name\n   * @throws NoSuchFieldException - if the \"NAME\" field is not defined.\n   * @throws IllegalAccessException - if the \"NAME\" field is inaccessible.\n   * @throws IllegalStateException - if the \"NAME\" field does not have appropriate modifiers or isn't a String field.\n   */\n  static String lookupSPIName(Class<? extends AbstractAnalysisFactory> service) throws NoSuchFieldException, IllegalAccessException, IllegalStateException {\n    final Field field = service.getField(\"NAME\");\n    int modifier = field.getModifiers();\n    if (Modifier.isStatic(modifier) && Modifier.isFinal(modifier) &&\n        field.getType().equals(String.class) &&\n        Objects.equals(field.getDeclaringClass(), service)) {\n      return ((String) field.get(null));\n      }\n    throw new IllegalStateException(\"No SPI name defined.\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32694fa3bbb984d3054955e48d946708e16110ff","date":1585155816,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#lookupSPIName(Class[#-extends-AbstractAnalysisFactory]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AbstractAnalysisFactory#lookupSPIName(Class[#-extends-AbstractAnalysisFactory]).mjava","sourceNew":"  /**\n   * Looks up SPI name (static \"NAME\" field) with appropriate modifiers.\n   * Also it must be a String class and declared in the concrete class.\n   * @return the SPI name\n   * @throws NoSuchFieldException - if the \"NAME\" field is not defined.\n   * @throws IllegalAccessException - if the \"NAME\" field is inaccessible.\n   * @throws IllegalStateException - if the \"NAME\" field does not have appropriate modifiers or isn't a String field.\n   */\n  public static String lookupSPIName(Class<? extends AbstractAnalysisFactory> service) throws NoSuchFieldException, IllegalAccessException, IllegalStateException {\n    final Field field = service.getDeclaredField(\"NAME\");\n    int modifier = field.getModifiers();\n    if (Modifier.isPublic(modifier) && Modifier.isStatic(modifier) &&\n        Modifier.isFinal(modifier) && Objects.equals(field.getType(), String.class)) {\n      return ((String) field.get(null));\n    }\n    throw new IllegalStateException(\"No SPI name defined.\");\n  }\n\n","sourceOld":"  /**\n   * Looks up SPI name (static \"NAME\" field) with appropriate modifiers.\n   * Also it must be a String class and declared in the concrete class.\n   * @return the SPI name\n   * @throws NoSuchFieldException - if the \"NAME\" field is not defined.\n   * @throws IllegalAccessException - if the \"NAME\" field is inaccessible.\n   * @throws IllegalStateException - if the \"NAME\" field does not have appropriate modifiers or isn't a String field.\n   */\n  static String lookupSPIName(Class<? extends AbstractAnalysisFactory> service) throws NoSuchFieldException, IllegalAccessException, IllegalStateException {\n    final Field field = service.getField(\"NAME\");\n    int modifier = field.getModifiers();\n    if (Modifier.isStatic(modifier) && Modifier.isFinal(modifier) &&\n        field.getType().equals(String.class) &&\n        Objects.equals(field.getDeclaringClass(), service)) {\n      return ((String) field.get(null));\n      }\n    throw new IllegalStateException(\"No SPI name defined.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"32694fa3bbb984d3054955e48d946708e16110ff":["5bc9864ea60454f962db6e9f89d513bc9a6fffee"],"5bc9864ea60454f962db6e9f89d513bc9a6fffee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["32694fa3bbb984d3054955e48d946708e16110ff"]},"commit2Childs":{"32694fa3bbb984d3054955e48d946708e16110ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5bc9864ea60454f962db6e9f89d513bc9a6fffee":["32694fa3bbb984d3054955e48d946708e16110ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5bc9864ea60454f962db6e9f89d513bc9a6fffee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}