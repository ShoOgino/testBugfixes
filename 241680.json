{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/NRTSuggester#lookup(CompletionScorer,TopSuggestDocsCollector).mjava","commits":[{"id":"8c33f6677a2078739058f81eca1df69d12cd62b0","date":1432799589,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/NRTSuggester#lookup(CompletionScorer,TopSuggestDocsCollector).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Collects at most {@link TopSuggestDocsCollector#getCountToCollect()} completions that\n   * match the provided {@link CompletionScorer}.\n   * <p>\n   * The {@link CompletionScorer#automaton} is intersected with the {@link #fst}.\n   * {@link CompletionScorer#weight} is used to compute boosts and/or extract context\n   * for each matched partial paths. A top N search is executed on {@link #fst} seeded with\n   * the matched partial paths. Upon reaching a completed path, {@link CompletionScorer#accept(int)}\n   * and {@link CompletionScorer#score(float, float)} is used on the document id, index weight\n   * and query boost to filter and score the entry, before being collected via\n   * {@link TopSuggestDocsCollector#collect(int, CharSequence, CharSequence, float)}\n   */\n  public void lookup(final CompletionScorer scorer, final TopSuggestDocsCollector collector) throws IOException {\n    final double liveDocsRatio = calculateLiveDocRatio(scorer.reader.numDocs(), scorer.reader.maxDoc());\n    if (liveDocsRatio == -1) {\n      return;\n    }\n    final List<FSTUtil.Path<Pair<Long, BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(scorer.automaton, fst);\n    final int queueSize = getMaxTopNSearcherQueueSize(collector.getCountToCollect() * prefixPaths.size(),\n        scorer.reader.numDocs(), liveDocsRatio, scorer.filtered);\n    Comparator<Pair<Long, BytesRef>> comparator = getComparator();\n    Util.TopNSearcher<Pair<Long, BytesRef>> searcher = new Util.TopNSearcher<Pair<Long, BytesRef>>(fst,\n        collector.getCountToCollect(), queueSize, comparator, new ScoringPathComparator(scorer)) {\n\n      private final CharsRefBuilder spare = new CharsRefBuilder();\n\n      @Override\n      protected boolean acceptResult(Util.FSTPath<Pair<Long, BytesRef>> path) {\n        int payloadSepIndex = parseSurfaceForm(path.cost.output2, payloadSep, spare);\n        int docID = parseDocID(path.cost.output2, payloadSepIndex);\n        if (!scorer.accept(docID)) {\n          return false;\n        }\n        try {\n          float score = scorer.score(decode(path.cost.output1), path.boost);\n          collector.collect(docID, spare.toCharsRef(), path.context, score);\n          return true;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {\n      scorer.weight.setNextMatch(path.input.get());\n      searcher.addStartPaths(path.fstNode, path.output, false, path.input, scorer.weight.boost(),\n          scorer.weight.context());\n    }\n    // hits are also returned by search()\n    // we do not use it, instead collect at acceptResult\n    Util.TopResults<Pair<Long, BytesRef>> search = searcher.search();\n    // search admissibility is not guaranteed\n    // see comment on getMaxTopNSearcherQueueSize\n    // assert  search.isComplete;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["509ddf2b18aec24f54a1cbabf7d15ed537d61ff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"66756ce4574b3c2fdc15740945140daf28792f5f","date":1433261481,"type":3,"author":"Areek Zillur","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/NRTSuggester#lookup(CompletionScorer,TopSuggestDocsCollector).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/NRTSuggester#lookup(CompletionScorer,TopSuggestDocsCollector).mjava","sourceNew":"  /**\n   * Collects at most {@link TopSuggestDocsCollector#getCountToCollect()} completions that\n   * match the provided {@link CompletionScorer}.\n   * <p>\n   * The {@link CompletionScorer#automaton} is intersected with the {@link #fst}.\n   * {@link CompletionScorer#weight} is used to compute boosts and/or extract context\n   * for each matched partial paths. A top N search is executed on {@link #fst} seeded with\n   * the matched partial paths. Upon reaching a completed path, {@link CompletionScorer#accept(int)}\n   * and {@link CompletionScorer#score(float, float)} is used on the document id, index weight\n   * and query boost to filter and score the entry, before being collected via\n   * {@link TopSuggestDocsCollector#collect(int, CharSequence, CharSequence, float)}\n   */\n  public void lookup(final CompletionScorer scorer, final TopSuggestDocsCollector collector) throws IOException {\n    final double liveDocsRatio = calculateLiveDocRatio(scorer.reader.numDocs(), scorer.reader.maxDoc());\n    if (liveDocsRatio == -1) {\n      return;\n    }\n    final List<FSTUtil.Path<Pair<Long, BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(scorer.automaton, fst);\n    final int queueSize = getMaxTopNSearcherQueueSize(collector.getCountToCollect() * prefixPaths.size(),\n        scorer.reader.numDocs(), liveDocsRatio, scorer.filtered);\n    Comparator<Pair<Long, BytesRef>> comparator = getComparator();\n    Util.TopNSearcher<Pair<Long, BytesRef>> searcher = new Util.TopNSearcher<Pair<Long, BytesRef>>(fst,\n        collector.getCountToCollect(), queueSize, comparator, new ScoringPathComparator(scorer)) {\n\n      private final CharsRefBuilder spare = new CharsRefBuilder();\n\n      @Override\n      protected boolean acceptResult(Util.FSTPath<Pair<Long, BytesRef>> path) {\n        int payloadSepIndex = parseSurfaceForm(path.cost.output2, payloadSep, spare);\n        int docID = parseDocID(path.cost.output2, payloadSepIndex);\n        if (!scorer.accept(docID)) {\n          return false;\n        }\n        try {\n          float score = scorer.score(decode(path.cost.output1), path.boost);\n          collector.collect(docID, spare.toCharsRef(), path.context, score);\n          return true;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {\n      scorer.weight.setNextMatch(path.input.get());\n      searcher.addStartPaths(path.fstNode, path.output, false, path.input, scorer.weight.boost(),\n          scorer.weight.context());\n    }\n    // hits are also returned by search()\n    // we do not use it, instead collect at acceptResult\n    searcher.search();\n    // search admissibility is not guaranteed\n    // see comment on getMaxTopNSearcherQueueSize\n    // assert  search.isComplete;\n  }\n\n","sourceOld":"  /**\n   * Collects at most {@link TopSuggestDocsCollector#getCountToCollect()} completions that\n   * match the provided {@link CompletionScorer}.\n   * <p>\n   * The {@link CompletionScorer#automaton} is intersected with the {@link #fst}.\n   * {@link CompletionScorer#weight} is used to compute boosts and/or extract context\n   * for each matched partial paths. A top N search is executed on {@link #fst} seeded with\n   * the matched partial paths. Upon reaching a completed path, {@link CompletionScorer#accept(int)}\n   * and {@link CompletionScorer#score(float, float)} is used on the document id, index weight\n   * and query boost to filter and score the entry, before being collected via\n   * {@link TopSuggestDocsCollector#collect(int, CharSequence, CharSequence, float)}\n   */\n  public void lookup(final CompletionScorer scorer, final TopSuggestDocsCollector collector) throws IOException {\n    final double liveDocsRatio = calculateLiveDocRatio(scorer.reader.numDocs(), scorer.reader.maxDoc());\n    if (liveDocsRatio == -1) {\n      return;\n    }\n    final List<FSTUtil.Path<Pair<Long, BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(scorer.automaton, fst);\n    final int queueSize = getMaxTopNSearcherQueueSize(collector.getCountToCollect() * prefixPaths.size(),\n        scorer.reader.numDocs(), liveDocsRatio, scorer.filtered);\n    Comparator<Pair<Long, BytesRef>> comparator = getComparator();\n    Util.TopNSearcher<Pair<Long, BytesRef>> searcher = new Util.TopNSearcher<Pair<Long, BytesRef>>(fst,\n        collector.getCountToCollect(), queueSize, comparator, new ScoringPathComparator(scorer)) {\n\n      private final CharsRefBuilder spare = new CharsRefBuilder();\n\n      @Override\n      protected boolean acceptResult(Util.FSTPath<Pair<Long, BytesRef>> path) {\n        int payloadSepIndex = parseSurfaceForm(path.cost.output2, payloadSep, spare);\n        int docID = parseDocID(path.cost.output2, payloadSepIndex);\n        if (!scorer.accept(docID)) {\n          return false;\n        }\n        try {\n          float score = scorer.score(decode(path.cost.output1), path.boost);\n          collector.collect(docID, spare.toCharsRef(), path.context, score);\n          return true;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {\n      scorer.weight.setNextMatch(path.input.get());\n      searcher.addStartPaths(path.fstNode, path.output, false, path.input, scorer.weight.boost(),\n          scorer.weight.context());\n    }\n    // hits are also returned by search()\n    // we do not use it, instead collect at acceptResult\n    Util.TopResults<Pair<Long, BytesRef>> search = searcher.search();\n    // search admissibility is not guaranteed\n    // see comment on getMaxTopNSearcherQueueSize\n    // assert  search.isComplete;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/NRTSuggester#lookup(CompletionScorer,Bits,TopSuggestDocsCollector).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/NRTSuggester#lookup(CompletionScorer,TopSuggestDocsCollector).mjava","sourceNew":"  /**\n   * Collects at most {@link TopSuggestDocsCollector#getCountToCollect()} completions that\n   * match the provided {@link CompletionScorer}.\n   * <p>\n   * The {@link CompletionScorer#automaton} is intersected with the {@link #fst}.\n   * {@link CompletionScorer#weight} is used to compute boosts and/or extract context\n   * for each matched partial paths. A top N search is executed on {@link #fst} seeded with\n   * the matched partial paths. Upon reaching a completed path, {@link CompletionScorer#accept(int, Bits)}\n   * and {@link CompletionScorer#score(float, float)} is used on the document id, index weight\n   * and query boost to filter and score the entry, before being collected via\n   * {@link TopSuggestDocsCollector#collect(int, CharSequence, CharSequence, float)}\n   */\n  public void lookup(final CompletionScorer scorer, Bits acceptDocs, final TopSuggestDocsCollector collector) throws IOException {\n    final double liveDocsRatio = calculateLiveDocRatio(scorer.reader.numDocs(), scorer.reader.maxDoc());\n    if (liveDocsRatio == -1) {\n      return;\n    }\n    final List<FSTUtil.Path<Pair<Long, BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(scorer.automaton, fst);\n    final int queueSize = getMaxTopNSearcherQueueSize(collector.getCountToCollect() * prefixPaths.size(),\n        scorer.reader.numDocs(), liveDocsRatio, scorer.filtered);\n    Comparator<Pair<Long, BytesRef>> comparator = getComparator();\n    Util.TopNSearcher<Pair<Long, BytesRef>> searcher = new Util.TopNSearcher<Pair<Long, BytesRef>>(fst,\n        collector.getCountToCollect(), queueSize, comparator, new ScoringPathComparator(scorer)) {\n\n      private final CharsRefBuilder spare = new CharsRefBuilder();\n\n      @Override\n      protected boolean acceptResult(Util.FSTPath<Pair<Long, BytesRef>> path) {\n        int payloadSepIndex = parseSurfaceForm(path.cost.output2, payloadSep, spare);\n        int docID = parseDocID(path.cost.output2, payloadSepIndex);\n        if (!scorer.accept(docID, acceptDocs)) {\n          return false;\n        }\n        try {\n          float score = scorer.score(decode(path.cost.output1), path.boost);\n          collector.collect(docID, spare.toCharsRef(), path.context, score);\n          return true;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {\n      scorer.weight.setNextMatch(path.input.get());\n      searcher.addStartPaths(path.fstNode, path.output, false, path.input, scorer.weight.boost(),\n          scorer.weight.context());\n    }\n    // hits are also returned by search()\n    // we do not use it, instead collect at acceptResult\n    searcher.search();\n    // search admissibility is not guaranteed\n    // see comment on getMaxTopNSearcherQueueSize\n    // assert  search.isComplete;\n  }\n\n","sourceOld":"  /**\n   * Collects at most {@link TopSuggestDocsCollector#getCountToCollect()} completions that\n   * match the provided {@link CompletionScorer}.\n   * <p>\n   * The {@link CompletionScorer#automaton} is intersected with the {@link #fst}.\n   * {@link CompletionScorer#weight} is used to compute boosts and/or extract context\n   * for each matched partial paths. A top N search is executed on {@link #fst} seeded with\n   * the matched partial paths. Upon reaching a completed path, {@link CompletionScorer#accept(int)}\n   * and {@link CompletionScorer#score(float, float)} is used on the document id, index weight\n   * and query boost to filter and score the entry, before being collected via\n   * {@link TopSuggestDocsCollector#collect(int, CharSequence, CharSequence, float)}\n   */\n  public void lookup(final CompletionScorer scorer, final TopSuggestDocsCollector collector) throws IOException {\n    final double liveDocsRatio = calculateLiveDocRatio(scorer.reader.numDocs(), scorer.reader.maxDoc());\n    if (liveDocsRatio == -1) {\n      return;\n    }\n    final List<FSTUtil.Path<Pair<Long, BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(scorer.automaton, fst);\n    final int queueSize = getMaxTopNSearcherQueueSize(collector.getCountToCollect() * prefixPaths.size(),\n        scorer.reader.numDocs(), liveDocsRatio, scorer.filtered);\n    Comparator<Pair<Long, BytesRef>> comparator = getComparator();\n    Util.TopNSearcher<Pair<Long, BytesRef>> searcher = new Util.TopNSearcher<Pair<Long, BytesRef>>(fst,\n        collector.getCountToCollect(), queueSize, comparator, new ScoringPathComparator(scorer)) {\n\n      private final CharsRefBuilder spare = new CharsRefBuilder();\n\n      @Override\n      protected boolean acceptResult(Util.FSTPath<Pair<Long, BytesRef>> path) {\n        int payloadSepIndex = parseSurfaceForm(path.cost.output2, payloadSep, spare);\n        int docID = parseDocID(path.cost.output2, payloadSepIndex);\n        if (!scorer.accept(docID)) {\n          return false;\n        }\n        try {\n          float score = scorer.score(decode(path.cost.output1), path.boost);\n          collector.collect(docID, spare.toCharsRef(), path.context, score);\n          return true;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    for (FSTUtil.Path<Pair<Long, BytesRef>> path : prefixPaths) {\n      scorer.weight.setNextMatch(path.input.get());\n      searcher.addStartPaths(path.fstNode, path.output, false, path.input, scorer.weight.boost(),\n          scorer.weight.context());\n    }\n    // hits are also returned by search()\n    // we do not use it, instead collect at acceptResult\n    searcher.search();\n    // search admissibility is not guaranteed\n    // see comment on getMaxTopNSearcherQueueSize\n    // assert  search.isComplete;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["66756ce4574b3c2fdc15740945140daf28792f5f"],"66756ce4574b3c2fdc15740945140daf28792f5f":["8c33f6677a2078739058f81eca1df69d12cd62b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8c33f6677a2078739058f81eca1df69d12cd62b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"66756ce4574b3c2fdc15740945140daf28792f5f":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8c33f6677a2078739058f81eca1df69d12cd62b0"],"8c33f6677a2078739058f81eca1df69d12cd62b0":["66756ce4574b3c2fdc15740945140daf28792f5f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}