{"path":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","commits":[{"id":"035130b0c342f404c027af8c8870587c3741cb1e","date":1342898805,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"/dev/null","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int nblocks = encoder.blocks();\n        final int nvalues = encoder.values();\n        assertEquals(nblocks, decoder.blocks());\n        assertEquals(nvalues, decoder.values());\n        final int iterations = _TestUtil.nextInt(random(), 1, 9);\n        assertEquals(format.nblocks(bpv, nvalues * iterations), nblocks * iterations);\n        final int blocksPosition = random().nextInt(10);\n        final int valuesPosition = random().nextInt(10);\n        final LongBuffer blocks = LongBuffer.allocate(blocksPosition + nblocks * iterations);\n        blocks.position(blocksPosition);\n        final LongBuffer values = LongBuffer.allocate(valuesPosition + nvalues * iterations);\n        values.position(valuesPosition);\n\n        for (int i = 0; i < iterations * nblocks; ++i) {\n          blocks.put(blocks.position() + i, random().nextLong());\n        }\n        decoder.decode(blocks, values, iterations);\n\n        final int restoredBlocksPosition = random().nextInt(10);\n        final LongBuffer restoredBlocks = LongBuffer.allocate(restoredBlocksPosition + nblocks * iterations);\n        values.position(valuesPosition);\n        restoredBlocks.position(restoredBlocksPosition);\n        encoder.encode(values, restoredBlocks, iterations);\n\n        blocks.position(blocksPosition);\n        blocks.limit(blocksPosition + nblocks * iterations);\n        restoredBlocks.position(restoredBlocksPosition);\n        restoredBlocks.limit(restoredBlocksPosition + nblocks * iterations);\n        assertEquals(blocks, restoredBlocks);\n\n        if (bpv <= 32) {\n          final IntBuffer intValues = IntBuffer.allocate(valuesPosition + nvalues * iterations);\n          intValues.position(valuesPosition);\n\n          blocks.position(blocksPosition);\n          decoder.decode(blocks, intValues, iterations);\n\n          intValues.position(valuesPosition);\n          restoredBlocks.position(restoredBlocksPosition);\n          encoder.encode(intValues, restoredBlocks, iterations);\n\n          blocks.position(blocksPosition);\n          blocks.limit(blocksPosition + nblocks * iterations);\n          restoredBlocks.position(restoredBlocksPosition);\n          restoredBlocks.limit(restoredBlocksPosition + nblocks * iterations);\n          assertEquals(blocks, restoredBlocks);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e3359210474c12c0b79e6400450313e3d7ef2bb","date":1344347790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        assertArrayEquals(msg, values, values2);\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int nblocks = encoder.blocks();\n        final int nvalues = encoder.values();\n        assertEquals(nblocks, decoder.blocks());\n        assertEquals(nvalues, decoder.values());\n        final int iterations = _TestUtil.nextInt(random(), 1, 9);\n        assertEquals(format.nblocks(bpv, nvalues * iterations), nblocks * iterations);\n        final int blocksPosition = random().nextInt(10);\n        final int valuesPosition = random().nextInt(10);\n        final LongBuffer blocks = LongBuffer.allocate(blocksPosition + nblocks * iterations);\n        blocks.position(blocksPosition);\n        final LongBuffer values = LongBuffer.allocate(valuesPosition + nvalues * iterations);\n        values.position(valuesPosition);\n\n        for (int i = 0; i < iterations * nblocks; ++i) {\n          blocks.put(blocks.position() + i, random().nextLong());\n        }\n        decoder.decode(blocks, values, iterations);\n\n        final int restoredBlocksPosition = random().nextInt(10);\n        final LongBuffer restoredBlocks = LongBuffer.allocate(restoredBlocksPosition + nblocks * iterations);\n        values.position(valuesPosition);\n        restoredBlocks.position(restoredBlocksPosition);\n        encoder.encode(values, restoredBlocks, iterations);\n\n        blocks.position(blocksPosition);\n        blocks.limit(blocksPosition + nblocks * iterations);\n        restoredBlocks.position(restoredBlocksPosition);\n        restoredBlocks.limit(restoredBlocksPosition + nblocks * iterations);\n        assertEquals(blocks, restoredBlocks);\n\n        if (bpv <= 32) {\n          final IntBuffer intValues = IntBuffer.allocate(valuesPosition + nvalues * iterations);\n          intValues.position(valuesPosition);\n\n          blocks.position(blocksPosition);\n          decoder.decode(blocks, intValues, iterations);\n\n          intValues.position(valuesPosition);\n          restoredBlocks.position(restoredBlocksPosition);\n          encoder.encode(intValues, restoredBlocks, iterations);\n\n          blocks.position(blocksPosition);\n          blocks.limit(blocksPosition + nblocks * iterations);\n          restoredBlocks.position(restoredBlocksPosition);\n          restoredBlocks.limit(restoredBlocksPosition + nblocks * iterations);\n          assertEquals(blocks, restoredBlocks);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6ade1bddc6668b62590efe9eb2a91876c85bd95","date":1344380068,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 - 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        assertArrayEquals(msg, values, values2);\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        assertArrayEquals(msg, values, values2);\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf88b0fdab72e7a3389fdd9a68ae252142c41511","date":1344435322,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 - 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        assertArrayEquals(msg, values, values2);\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ea5b1ca7a7274259b3946842c5e82435617b6e7","date":1344440788,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, iterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, iterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8615860cb50aefb8eebca1d1b3893dbe21cf126","date":1345550448,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"/dev/null","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, iterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, iterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"001b25b42373b22a52f399dbf072f1224632e8e6","date":1345889167,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"/dev/null","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, iterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, iterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e29d4d91327929d477b701d3ef2f5b3457d26ec5","date":1359465689,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, iterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, iterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de522d9303bd67c8473a269a1319125d1f3700e0","date":1359477856,"type":3,"author":"Adrien Grand","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int blockCount = encoder.blockCount();\n        final int valueCount = encoder.valueCount();\n        assertEquals(blockCount, decoder.blockCount());\n        assertEquals(valueCount, decoder.valueCount());\n\n        final int iterations = random().nextInt(100);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = iterations * blockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, iterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, iterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, iterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + iterations * valueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, iterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, iterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, iterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, iterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9798d0818e7a880546802b509792d3f3d57babd2","date":1528358901,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, ArrayUtil.copyOfSubArray(blocks, blocksOffset, blocks.length),\n            ArrayUtil.copyOfSubArray(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, ArrayUtil.copyOfSubArray(blocks, blocksOffset, blocks.length),\n            ArrayUtil.copyOfSubArray(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, ArrayUtil.copyOfSubArray(blocks, blocksOffset, blocks.length),\n            ArrayUtil.copyOfSubArray(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, Arrays.copyOfRange(blocks, blocksOffset, blocks.length),\n            Arrays.copyOfRange(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testEncodeDecode().mjava","sourceNew":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          @SuppressWarnings(\"deprecation\")\n          PackedInts.Format PACKED_SINGLE_BLOCK = PackedInts.Format.PACKED_SINGLE_BLOCK;\n          if (format == PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, ArrayUtil.copyOfSubArray(blocks, blocksOffset, blocks.length),\n            ArrayUtil.copyOfSubArray(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testEncodeDecode() {\n    for (PackedInts.Format format : PackedInts.Format.values()) {\n      for (int bpv = 1; bpv <= 64; ++bpv) {\n        if (!format.isSupported(bpv)) {\n          continue;\n        }\n        String msg = format + \" \" + bpv;\n\n        final PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, bpv);\n        final int longBlockCount = encoder.longBlockCount();\n        final int longValueCount = encoder.longValueCount();\n        final int byteBlockCount = encoder.byteBlockCount();\n        final int byteValueCount = encoder.byteValueCount();\n        assertEquals(longBlockCount, decoder.longBlockCount());\n        assertEquals(longValueCount, decoder.longValueCount());\n        assertEquals(byteBlockCount, decoder.byteBlockCount());\n        assertEquals(byteValueCount, decoder.byteValueCount());\n\n        final int longIterations = random().nextInt(100);\n        final int byteIterations = longIterations * longValueCount / byteValueCount;\n        assertEquals(longIterations * longValueCount, byteIterations * byteValueCount);\n        final int blocksOffset = random().nextInt(100);\n        final int valuesOffset = random().nextInt(100);\n        final int blocksOffset2 = random().nextInt(100);\n        final int blocksLen = longIterations * longBlockCount;\n\n        // 1. generate random inputs\n        final long[] blocks = new long[blocksOffset + blocksLen];\n        for (int i = 0; i < blocks.length; ++i) {\n          blocks[i] = random().nextLong();\n          if (format == PackedInts.Format.PACKED_SINGLE_BLOCK && 64 % bpv != 0) {\n            // clear highest bits for packed\n            final int toClear = 64 % bpv;\n            blocks[i] = (blocks[i] << toClear) >>> toClear;\n          }\n        }\n\n        // 2. decode\n        final long[] values = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(blocks, blocksOffset, values, valuesOffset, longIterations);\n        for (long value : values) {\n          assertTrue(value <= PackedInts.maxValue(bpv));\n        }\n        // test decoding to int[]\n        final int[] intValues;\n        if (bpv <= 32) {\n          intValues = new int[values.length];\n          decoder.decode(blocks, blocksOffset, intValues, valuesOffset, longIterations);\n          assertTrue(equals(intValues, values));\n        } else {\n          intValues = null;\n        }\n\n        // 3. re-encode\n        final long[] blocks2 = new long[blocksOffset2 + blocksLen];\n        encoder.encode(values, valuesOffset, blocks2, blocksOffset2, longIterations);\n        assertArrayEquals(msg, ArrayUtil.copyOfSubArray(blocks, blocksOffset, blocks.length),\n            ArrayUtil.copyOfSubArray(blocks2, blocksOffset2, blocks2.length));\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final long[] blocks3 = new long[blocks2.length];\n          encoder.encode(intValues, valuesOffset, blocks3, blocksOffset2, longIterations);\n          assertArrayEquals(msg, blocks2, blocks3);\n        }\n\n        // 4. byte[] decoding\n        final byte[] byteBlocks = new byte[8 * blocks.length];\n        ByteBuffer.wrap(byteBlocks).asLongBuffer().put(blocks);\n        final long[] values2 = new long[valuesOffset + longIterations * longValueCount];\n        decoder.decode(byteBlocks, blocksOffset * 8, values2, valuesOffset, byteIterations);\n        for (long value : values2) {\n          assertTrue(msg, value <= PackedInts.maxValue(bpv));\n        }\n        assertArrayEquals(msg, values, values2);\n        // test decoding to int[]\n        if (bpv <= 32) {\n          final int[] intValues2 = new int[values2.length];\n          decoder.decode(byteBlocks, blocksOffset * 8, intValues2, valuesOffset, byteIterations);\n          assertTrue(msg, equals(intValues2, values2));\n        }\n\n        // 5. byte[] encoding\n        final byte[] blocks3 = new byte[8 * (blocksOffset2 + blocksLen)];\n        encoder.encode(values, valuesOffset, blocks3, 8 * blocksOffset2, byteIterations);\n        assertEquals(msg, LongBuffer.wrap(blocks2), ByteBuffer.wrap(blocks3).asLongBuffer());\n        // test encoding from int[]\n        if (bpv <= 32) {\n          final byte[] blocks4 = new byte[blocks3.length];\n          encoder.encode(intValues, valuesOffset, blocks4, 8 * blocksOffset2, byteIterations);\n          assertArrayEquals(msg, blocks3, blocks4);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"001b25b42373b22a52f399dbf072f1224632e8e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"f8615860cb50aefb8eebca1d1b3893dbe21cf126":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7ea5b1ca7a7274259b3946842c5e82435617b6e7"],"de522d9303bd67c8473a269a1319125d1f3700e0":["f8615860cb50aefb8eebca1d1b3893dbe21cf126","e29d4d91327929d477b701d3ef2f5b3457d26ec5"],"cf88b0fdab72e7a3389fdd9a68ae252142c41511":["e6ade1bddc6668b62590efe9eb2a91876c85bd95"],"e29d4d91327929d477b701d3ef2f5b3457d26ec5":["f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e6ade1bddc6668b62590efe9eb2a91876c85bd95":["0e3359210474c12c0b79e6400450313e3d7ef2bb"],"b70042a8a492f7054d480ccdd2be9796510d4327":["e29d4d91327929d477b701d3ef2f5b3457d26ec5","9798d0818e7a880546802b509792d3f3d57babd2"],"0e3359210474c12c0b79e6400450313e3d7ef2bb":["035130b0c342f404c027af8c8870587c3741cb1e"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["9798d0818e7a880546802b509792d3f3d57babd2"],"035130b0c342f404c027af8c8870587c3741cb1e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9798d0818e7a880546802b509792d3f3d57babd2":["e29d4d91327929d477b701d3ef2f5b3457d26ec5"],"7ea5b1ca7a7274259b3946842c5e82435617b6e7":["cf88b0fdab72e7a3389fdd9a68ae252142c41511"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["e29d4d91327929d477b701d3ef2f5b3457d26ec5","9798d0818e7a880546802b509792d3f3d57babd2"]},"commit2Childs":{"001b25b42373b22a52f399dbf072f1224632e8e6":[],"f8615860cb50aefb8eebca1d1b3893dbe21cf126":["001b25b42373b22a52f399dbf072f1224632e8e6","de522d9303bd67c8473a269a1319125d1f3700e0","e29d4d91327929d477b701d3ef2f5b3457d26ec5"],"de522d9303bd67c8473a269a1319125d1f3700e0":[],"cf88b0fdab72e7a3389fdd9a68ae252142c41511":["7ea5b1ca7a7274259b3946842c5e82435617b6e7"],"e29d4d91327929d477b701d3ef2f5b3457d26ec5":["de522d9303bd67c8473a269a1319125d1f3700e0","b70042a8a492f7054d480ccdd2be9796510d4327","9798d0818e7a880546802b509792d3f3d57babd2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["001b25b42373b22a52f399dbf072f1224632e8e6","f8615860cb50aefb8eebca1d1b3893dbe21cf126","035130b0c342f404c027af8c8870587c3741cb1e"],"e6ade1bddc6668b62590efe9eb2a91876c85bd95":["cf88b0fdab72e7a3389fdd9a68ae252142c41511"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"0e3359210474c12c0b79e6400450313e3d7ef2bb":["e6ade1bddc6668b62590efe9eb2a91876c85bd95"],"035130b0c342f404c027af8c8870587c3741cb1e":["0e3359210474c12c0b79e6400450313e3d7ef2bb"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9798d0818e7a880546802b509792d3f3d57babd2":["b70042a8a492f7054d480ccdd2be9796510d4327","f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"7ea5b1ca7a7274259b3946842c5e82435617b6e7":["f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["001b25b42373b22a52f399dbf072f1224632e8e6","de522d9303bd67c8473a269a1319125d1f3700e0","b70042a8a492f7054d480ccdd2be9796510d4327","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}