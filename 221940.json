{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testCheckIntegrityReadsAllBytes().mjava","commits":[{"id":"a8ca1c1149d3818e44210900695de1d6f7f5f259","date":1582895996,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testCheckIntegrityReadsAllBytes().mjava","pathOld":"/dev/null","sourceNew":"  /** This test is a best effort at verifying that checkIntegrity doesn't miss any files. It tests that the\n   *  combination of opening a reader and calling checkIntegrity on it reads all bytes of all files. */\n  public void testCheckIntegrityReadsAllBytes() throws Exception {\n    assumeFalse(\"SimpleText doesn't store checksums of its files\", getCodec() instanceof SimpleTextCodec);\n    Directory dir = applyCreatedVersionMajor(newDirectory());\n\n    IndexWriterConfig cfg = new IndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w = new IndexWriter(dir, cfg);\n    final int numDocs = atLeast(100);\n    for (int i = 0; i < numDocs; ++i) {\n      Document d = new Document();\n      addRandomFields(d);\n      w.addDocument(d);\n    }\n    w.forceMerge(1);\n    w.commit();\n    w.close();\n\n    ReadBytesDirectoryWrapper readBytesWrapperDir = new ReadBytesDirectoryWrapper(dir);\n    IndexReader reader = DirectoryReader.open(readBytesWrapperDir);\n    LeafReader leafReader = getOnlyLeafReader(reader);\n    leafReader.checkIntegrity();\n\n    Map<String, FixedBitSet> readBytesMap = readBytesWrapperDir.getReadBytes();\n\n    Set<String> unreadFiles = new HashSet<>(Arrays.asList(readBytesWrapperDir.listAll()));\n    unreadFiles.removeAll(readBytesMap.keySet());\n    assertTrue(\"Some files have not been open: \" + unreadFiles, unreadFiles.isEmpty());\n\n    List<String> messages = new ArrayList<>();\n    for (Map.Entry<String, FixedBitSet> entry : readBytesMap.entrySet()) {\n      String name = entry.getKey();\n      FixedBitSet unreadBytes = entry.getValue().clone();\n      unreadBytes.flip(0, unreadBytes.length());\n      int unread = unreadBytes.nextSetBit(0);\n      if (unread != Integer.MAX_VALUE) {\n        messages.add(\"Offset \" + unread + \" of file \" + name + \"(\" + unreadBytes.length() + \"bytes) was not read.\");\n      }\n    }\n    assertTrue(String.join(\"\\n\", messages), messages.isEmpty());\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38715e90984bdb76d3a51baf16f8ecb39a33efc3","date":1582962376,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testCheckIntegrityReadsAllBytes().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testCheckIntegrityReadsAllBytes().mjava","sourceNew":"  /** This test is a best effort at verifying that checkIntegrity doesn't miss any files. It tests that the\n   *  combination of opening a reader and calling checkIntegrity on it reads all bytes of all files. */\n  public void testCheckIntegrityReadsAllBytes() throws Exception {\n    assumeFalse(\"SimpleText doesn't store checksums of its files\", getCodec() instanceof SimpleTextCodec);\n    Directory dir = applyCreatedVersionMajor(newDirectory());\n\n    IndexWriterConfig cfg = new IndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w = new IndexWriter(dir, cfg);\n    final int numDocs = atLeast(100);\n    for (int i = 0; i < numDocs; ++i) {\n      Document d = new Document();\n      addRandomFields(d);\n      w.addDocument(d);\n    }\n    w.forceMerge(1);\n    w.commit();\n    w.close();\n\n    ReadBytesDirectoryWrapper readBytesWrapperDir = new ReadBytesDirectoryWrapper(dir);\n    IndexReader reader = DirectoryReader.open(readBytesWrapperDir);\n    LeafReader leafReader = getOnlyLeafReader(reader);\n    leafReader.checkIntegrity();\n\n    Map<String, FixedBitSet> readBytesMap = readBytesWrapperDir.getReadBytes();\n\n    Set<String> unreadFiles = new HashSet<>(Arrays.asList(readBytesWrapperDir.listAll()));\n    unreadFiles.removeAll(readBytesMap.keySet());\n    unreadFiles.remove(IndexWriter.WRITE_LOCK_NAME);\n    assertTrue(\"Some files have not been open: \" + unreadFiles, unreadFiles.isEmpty());\n\n    List<String> messages = new ArrayList<>();\n    for (Map.Entry<String, FixedBitSet> entry : readBytesMap.entrySet()) {\n      String name = entry.getKey();\n      FixedBitSet unreadBytes = entry.getValue().clone();\n      unreadBytes.flip(0, unreadBytes.length());\n      int unread = unreadBytes.nextSetBit(0);\n      if (unread != Integer.MAX_VALUE) {\n        messages.add(\"Offset \" + unread + \" of file \" + name + \"(\" + unreadBytes.length() + \"bytes) was not read.\");\n      }\n    }\n    assertTrue(String.join(\"\\n\", messages), messages.isEmpty());\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** This test is a best effort at verifying that checkIntegrity doesn't miss any files. It tests that the\n   *  combination of opening a reader and calling checkIntegrity on it reads all bytes of all files. */\n  public void testCheckIntegrityReadsAllBytes() throws Exception {\n    assumeFalse(\"SimpleText doesn't store checksums of its files\", getCodec() instanceof SimpleTextCodec);\n    Directory dir = applyCreatedVersionMajor(newDirectory());\n\n    IndexWriterConfig cfg = new IndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w = new IndexWriter(dir, cfg);\n    final int numDocs = atLeast(100);\n    for (int i = 0; i < numDocs; ++i) {\n      Document d = new Document();\n      addRandomFields(d);\n      w.addDocument(d);\n    }\n    w.forceMerge(1);\n    w.commit();\n    w.close();\n\n    ReadBytesDirectoryWrapper readBytesWrapperDir = new ReadBytesDirectoryWrapper(dir);\n    IndexReader reader = DirectoryReader.open(readBytesWrapperDir);\n    LeafReader leafReader = getOnlyLeafReader(reader);\n    leafReader.checkIntegrity();\n\n    Map<String, FixedBitSet> readBytesMap = readBytesWrapperDir.getReadBytes();\n\n    Set<String> unreadFiles = new HashSet<>(Arrays.asList(readBytesWrapperDir.listAll()));\n    unreadFiles.removeAll(readBytesMap.keySet());\n    assertTrue(\"Some files have not been open: \" + unreadFiles, unreadFiles.isEmpty());\n\n    List<String> messages = new ArrayList<>();\n    for (Map.Entry<String, FixedBitSet> entry : readBytesMap.entrySet()) {\n      String name = entry.getKey();\n      FixedBitSet unreadBytes = entry.getValue().clone();\n      unreadBytes.flip(0, unreadBytes.length());\n      int unread = unreadBytes.nextSetBit(0);\n      if (unread != Integer.MAX_VALUE) {\n        messages.add(\"Offset \" + unread + \" of file \" + name + \"(\" + unreadBytes.length() + \"bytes) was not read.\");\n      }\n    }\n    assertTrue(String.join(\"\\n\", messages), messages.isEmpty());\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2949b9efa697cd94d2dba3e0b9f446879b7bfeaa","date":1583135953,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testCheckIntegrityReadsAllBytes().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseIndexFileFormatTestCase#testCheckIntegrityReadsAllBytes().mjava","sourceNew":"  /** This test is a best effort at verifying that checkIntegrity doesn't miss any files. It tests that the\n   *  combination of opening a reader and calling checkIntegrity on it reads all bytes of all files. */\n  public void testCheckIntegrityReadsAllBytes() throws Exception {\n    assumeFalse(\"SimpleText doesn't store checksums of its files\", getCodec() instanceof SimpleTextCodec);\n    FileTrackingDirectoryWrapper dir = new FileTrackingDirectoryWrapper(newDirectory());\n    applyCreatedVersionMajor(dir);\n\n    IndexWriterConfig cfg = new IndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w = new IndexWriter(dir, cfg);\n    final int numDocs = atLeast(100);\n    for (int i = 0; i < numDocs; ++i) {\n      Document d = new Document();\n      addRandomFields(d);\n      w.addDocument(d);\n    }\n    w.forceMerge(1);\n    w.commit();\n    w.close();\n\n    ReadBytesDirectoryWrapper readBytesWrapperDir = new ReadBytesDirectoryWrapper(dir);\n    IndexReader reader = DirectoryReader.open(readBytesWrapperDir);\n    LeafReader leafReader = getOnlyLeafReader(reader);\n    leafReader.checkIntegrity();\n\n    Map<String, FixedBitSet> readBytesMap = readBytesWrapperDir.getReadBytes();\n\n    Set<String> unreadFiles = new HashSet<>(dir.getFiles());System.out.println(Arrays.toString(dir.listAll()));\n    unreadFiles.removeAll(readBytesMap.keySet());\n    unreadFiles.remove(IndexWriter.WRITE_LOCK_NAME);\n    assertTrue(\"Some files have not been open: \" + unreadFiles, unreadFiles.isEmpty());\n\n    List<String> messages = new ArrayList<>();\n    for (Map.Entry<String, FixedBitSet> entry : readBytesMap.entrySet()) {\n      String name = entry.getKey();\n      FixedBitSet unreadBytes = entry.getValue().clone();\n      unreadBytes.flip(0, unreadBytes.length());\n      int unread = unreadBytes.nextSetBit(0);\n      if (unread != Integer.MAX_VALUE) {\n        messages.add(\"Offset \" + unread + \" of file \" + name + \"(\" + unreadBytes.length() + \"bytes) was not read.\");\n      }\n    }\n    assertTrue(String.join(\"\\n\", messages), messages.isEmpty());\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** This test is a best effort at verifying that checkIntegrity doesn't miss any files. It tests that the\n   *  combination of opening a reader and calling checkIntegrity on it reads all bytes of all files. */\n  public void testCheckIntegrityReadsAllBytes() throws Exception {\n    assumeFalse(\"SimpleText doesn't store checksums of its files\", getCodec() instanceof SimpleTextCodec);\n    Directory dir = applyCreatedVersionMajor(newDirectory());\n\n    IndexWriterConfig cfg = new IndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w = new IndexWriter(dir, cfg);\n    final int numDocs = atLeast(100);\n    for (int i = 0; i < numDocs; ++i) {\n      Document d = new Document();\n      addRandomFields(d);\n      w.addDocument(d);\n    }\n    w.forceMerge(1);\n    w.commit();\n    w.close();\n\n    ReadBytesDirectoryWrapper readBytesWrapperDir = new ReadBytesDirectoryWrapper(dir);\n    IndexReader reader = DirectoryReader.open(readBytesWrapperDir);\n    LeafReader leafReader = getOnlyLeafReader(reader);\n    leafReader.checkIntegrity();\n\n    Map<String, FixedBitSet> readBytesMap = readBytesWrapperDir.getReadBytes();\n\n    Set<String> unreadFiles = new HashSet<>(Arrays.asList(readBytesWrapperDir.listAll()));\n    unreadFiles.removeAll(readBytesMap.keySet());\n    unreadFiles.remove(IndexWriter.WRITE_LOCK_NAME);\n    assertTrue(\"Some files have not been open: \" + unreadFiles, unreadFiles.isEmpty());\n\n    List<String> messages = new ArrayList<>();\n    for (Map.Entry<String, FixedBitSet> entry : readBytesMap.entrySet()) {\n      String name = entry.getKey();\n      FixedBitSet unreadBytes = entry.getValue().clone();\n      unreadBytes.flip(0, unreadBytes.length());\n      int unread = unreadBytes.nextSetBit(0);\n      if (unread != Integer.MAX_VALUE) {\n        messages.add(\"Offset \" + unread + \" of file \" + name + \"(\" + unreadBytes.length() + \"bytes) was not read.\");\n      }\n    }\n    assertTrue(String.join(\"\\n\", messages), messages.isEmpty());\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a8ca1c1149d3818e44210900695de1d6f7f5f259":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"38715e90984bdb76d3a51baf16f8ecb39a33efc3":["a8ca1c1149d3818e44210900695de1d6f7f5f259"],"2949b9efa697cd94d2dba3e0b9f446879b7bfeaa":["38715e90984bdb76d3a51baf16f8ecb39a33efc3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2949b9efa697cd94d2dba3e0b9f446879b7bfeaa"]},"commit2Childs":{"a8ca1c1149d3818e44210900695de1d6f7f5f259":["38715e90984bdb76d3a51baf16f8ecb39a33efc3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a8ca1c1149d3818e44210900695de1d6f7f5f259"],"38715e90984bdb76d3a51baf16f8ecb39a33efc3":["2949b9efa697cd94d2dba3e0b9f446879b7bfeaa"],"2949b9efa697cd94d2dba3e0b9f446879b7bfeaa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}