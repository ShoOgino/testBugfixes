{"path":"solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.AbstractStatsValues#accumulate(NamedList).mjava","commits":[{"id":"248f6ecc900c3a5633fd5ca6f564ea8b717720da","date":1588863846,"type":0,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.AbstractStatsValues#accumulate(NamedList).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void accumulate(NamedList stv) {\n      if (computeCount) {\n        count += (Long) stv.get(\"count\");\n      }\n      if (computeMissing) {\n        missing += (Long) stv.get(\"missing\");\n      }\n      if (computeCalcDistinct) {\n        distinctValues.addAll((Collection<T>) stv.get(\"distinctValues\"));\n        countDistinct = distinctValues.size();\n      }\n\n      if (computeMinOrMax) {\n        updateMinMax((T) stv.get(\"min\"), (T) stv.get(\"max\"));\n      }\n\n      if (computeCardinality) {\n        byte[] data = (byte[]) stv.get(\"cardinality\");\n        HLL other = HLL.fromBytes(data);\n        if (hll.getType().equals(HLLType.EMPTY)) {\n          // The HLL.union method goes out of it's way not to modify the \"other\" HLL.\n          // Which means in the case of merging into an \"EMPTY\" HLL (garunteed to happen at\n          // least once in every coordination of shard requests) it always clones all\n          // of the internal storage -- but since we're going to throw \"other\" away after\n          // the merge, this just means a short term doubling of RAM that we can skip.\n          hll = other;\n        } else {\n          hll.union(other);\n        }\n      }\n\n      updateTypeSpecificStats(stv);\n\n      NamedList f = (NamedList) stv.get(FACETS);\n      if (f == null) {\n        return;\n      }\n\n      for (int i = 0; i < f.size(); i++) {\n        String field = f.getName(i);\n        NamedList vals = (NamedList) f.getVal(i);\n        Map<String, StatsValues> addTo = facets.get(field);\n        if (addTo == null) {\n          addTo = new HashMap<>();\n          facets.put(field, addTo);\n        }\n        for (int j = 0; j < vals.size(); j++) {\n          String val = vals.getName(j);\n          StatsValues vvals = addTo.get(val);\n          if (vvals == null) {\n            vvals = createStatsValues(statsField);\n            addTo.put(val, vvals);\n          }\n          vvals.accumulate((NamedList) vals.getVal(j));\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.AbstractStatsValues#accumulate(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.AbstractStatsValues#accumulate(NamedList).mjava","sourceNew":"    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public void accumulate(@SuppressWarnings({\"rawtypes\"})NamedList stv) {\n      if (computeCount) {\n        count += (Long) stv.get(\"count\");\n      }\n      if (computeMissing) {\n        missing += (Long) stv.get(\"missing\");\n      }\n      if (computeCalcDistinct) {\n        distinctValues.addAll((Collection<T>) stv.get(\"distinctValues\"));\n        countDistinct = distinctValues.size();\n      }\n\n      if (computeMinOrMax) {\n        updateMinMax((T) stv.get(\"min\"), (T) stv.get(\"max\"));\n      }\n\n      if (computeCardinality) {\n        byte[] data = (byte[]) stv.get(\"cardinality\");\n        HLL other = HLL.fromBytes(data);\n        if (hll.getType().equals(HLLType.EMPTY)) {\n          // The HLL.union method goes out of it's way not to modify the \"other\" HLL.\n          // Which means in the case of merging into an \"EMPTY\" HLL (garunteed to happen at\n          // least once in every coordination of shard requests) it always clones all\n          // of the internal storage -- but since we're going to throw \"other\" away after\n          // the merge, this just means a short term doubling of RAM that we can skip.\n          hll = other;\n        } else {\n          hll.union(other);\n        }\n      }\n\n      updateTypeSpecificStats(stv);\n\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList f = (NamedList) stv.get(FACETS);\n      if (f == null) {\n        return;\n      }\n\n      for (int i = 0; i < f.size(); i++) {\n        String field = f.getName(i);\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList vals = (NamedList) f.getVal(i);\n        Map<String, StatsValues> addTo = facets.get(field);\n        if (addTo == null) {\n          addTo = new HashMap<>();\n          facets.put(field, addTo);\n        }\n        for (int j = 0; j < vals.size(); j++) {\n          String val = vals.getName(j);\n          StatsValues vvals = addTo.get(val);\n          if (vvals == null) {\n            vvals = createStatsValues(statsField);\n            addTo.put(val, vvals);\n          }\n          vvals.accumulate((NamedList) vals.getVal(j));\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void accumulate(NamedList stv) {\n      if (computeCount) {\n        count += (Long) stv.get(\"count\");\n      }\n      if (computeMissing) {\n        missing += (Long) stv.get(\"missing\");\n      }\n      if (computeCalcDistinct) {\n        distinctValues.addAll((Collection<T>) stv.get(\"distinctValues\"));\n        countDistinct = distinctValues.size();\n      }\n\n      if (computeMinOrMax) {\n        updateMinMax((T) stv.get(\"min\"), (T) stv.get(\"max\"));\n      }\n\n      if (computeCardinality) {\n        byte[] data = (byte[]) stv.get(\"cardinality\");\n        HLL other = HLL.fromBytes(data);\n        if (hll.getType().equals(HLLType.EMPTY)) {\n          // The HLL.union method goes out of it's way not to modify the \"other\" HLL.\n          // Which means in the case of merging into an \"EMPTY\" HLL (garunteed to happen at\n          // least once in every coordination of shard requests) it always clones all\n          // of the internal storage -- but since we're going to throw \"other\" away after\n          // the merge, this just means a short term doubling of RAM that we can skip.\n          hll = other;\n        } else {\n          hll.union(other);\n        }\n      }\n\n      updateTypeSpecificStats(stv);\n\n      NamedList f = (NamedList) stv.get(FACETS);\n      if (f == null) {\n        return;\n      }\n\n      for (int i = 0; i < f.size(); i++) {\n        String field = f.getName(i);\n        NamedList vals = (NamedList) f.getVal(i);\n        Map<String, StatsValues> addTo = facets.get(field);\n        if (addTo == null) {\n          addTo = new HashMap<>();\n          facets.put(field, addTo);\n        }\n        for (int j = 0; j < vals.size(); j++) {\n          String val = vals.getName(j);\n          StatsValues vvals = addTo.get(val);\n          if (vvals == null) {\n            vvals = createStatsValues(statsField);\n            addTo.put(val, vvals);\n          }\n          vvals.accumulate((NamedList) vals.getVal(j));\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"]},"commit2Childs":{"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}