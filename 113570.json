{"path":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","commits":[{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"/dev/null","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        BKDUtil.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = BKDUtil.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = BKDUtil.bytesToInt(minPacked, 0);\n              int max = BKDUtil.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n              } else if (min >= queryMin && max <= queryMax) {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              } else {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        BKDUtil.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = BKDUtil.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = BKDUtil.bytesToInt(minPacked, 0);\n              int max = BKDUtil.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.QUERY_OUTSIDE_CELL;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.QUERY_CROSSES_CELL;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        BKDUtil.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = BKDUtil.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = BKDUtil.bytesToInt(minPacked, 0);\n              int max = BKDUtil.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n              } else if (min >= queryMin && max <= queryMax) {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              } else {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        BKDUtil.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = BKDUtil.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = BKDUtil.bytesToInt(minPacked, 0);\n              int max = BKDUtil.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        BKDUtil.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = BKDUtil.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = BKDUtil.bytesToInt(minPacked, 0);\n              int max = BKDUtil.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.QUERY_OUTSIDE_CELL;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.QUERY_CROSSES_CELL;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.bytesToInt(minPacked, 0);\n              int max = NumericUtils.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        BKDUtil.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = BKDUtil.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = BKDUtil.bytesToInt(minPacked, 0);\n              int max = BKDUtil.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"251c5b33f0a2c8988550b63c78ed22b0e84524e5","date":1456961997,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.bytesToInt(minPacked, 0);\n              int max = NumericUtils.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.bytesToInt(minPacked, 0);\n              int max = NumericUtils.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","date":1457059932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.bytesToInt(minPacked, 0);\n              int max = NumericUtils.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":["770342641f7b505eaa8dccdc666158bff2419109"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.bytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.bytesToInt(minPacked, 0);\n              int max = NumericUtils.bytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca","date":1457777566,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n        BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f, randomPointCount());\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"416f9e28900210be57b69bc12e2954fb98ed7ebe","date":1458479803,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n        BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f, randomPointCount(true), true);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n        BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f, randomPointCount());\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3d902d9e126b838f492796a117a4d9e532d597a","date":1458810839,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n        BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f, 100, true);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n        BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f, randomPointCount(true), true);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc57257d8a309205ebefdf9ee778da293673f599","date":1458828168,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f, 100, true);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n        BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f, 100, true);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100, true);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 4, 2, 1.0f, 100, true);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100, true);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbc55bb1f9b4422860b0f903e6af8082280e7b72","date":1571986943,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, randomBoolean());\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in, false);//randomBoolean());\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, randomBoolean());\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6b1fd50f847900ca47783ea832846d60e81f990","date":1591769592,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in, false);//randomBoolean());\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBasicInts1D().mjava","sourceNew":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", new BKDConfig(1, 1, 4, 2), 1.0f, 100);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testBasicInts1D() throws Exception {\n    try (Directory dir = getDirectory(100)) {\n      BKDWriter w = new BKDWriter(100, dir, \"tmp\", 1, 1, 4, 2, 1.0f, 100);\n      byte[] scratch = new byte[4];\n      for(int docID=0;docID<100;docID++) {\n        NumericUtils.intToSortableBytes(docID, scratch, 0);\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in);\n\n        // Simple 1D range query:\n        final int queryMin = 42;\n        final int queryMax = 87;\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID);\n              }\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              int x = NumericUtils.sortableBytesToInt(packedValue, 0);\n              if (VERBOSE) {\n                System.out.println(\"visit docID=\" + docID + \" x=\" + x);\n              }\n              if (x >= queryMin && x <= queryMax) {\n                hits.set(docID);\n              }\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              int min = NumericUtils.sortableBytesToInt(minPacked, 0);\n              int max = NumericUtils.sortableBytesToInt(maxPacked, 0);\n              assert max >= min;\n              if (VERBOSE) {\n                System.out.println(\"compare: min=\" + min + \" max=\" + max + \" vs queryMin=\" + queryMin + \" queryMax=\" + queryMax);\n              }\n\n              if (max < queryMin || min > queryMax) {\n                return Relation.CELL_OUTSIDE_QUERY;\n              } else if (min >= queryMin && max <= queryMax) {\n                return Relation.CELL_INSIDE_QUERY;\n              } else {\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<100;docID++) {\n          boolean expected = docID >= queryMin && docID <= queryMax;\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["d6b1fd50f847900ca47783ea832846d60e81f990"],"f6652c943595e92c187ee904c382863013eae28f":["bc57257d8a309205ebefdf9ee778da293673f599"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"bc57257d8a309205ebefdf9ee778da293673f599":["f3d902d9e126b838f492796a117a4d9e532d597a"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"770342641f7b505eaa8dccdc666158bff2419109":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["770342641f7b505eaa8dccdc666158bff2419109"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"d6b1fd50f847900ca47783ea832846d60e81f990":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["770342641f7b505eaa8dccdc666158bff2419109","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"f3d902d9e126b838f492796a117a4d9e532d597a":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["251c5b33f0a2c8988550b63c78ed22b0e84524e5"]},"commit2Childs":{"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"bc57257d8a309205ebefdf9ee778da293673f599":["f6652c943595e92c187ee904c382863013eae28f"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["770342641f7b505eaa8dccdc666158bff2419109"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"770342641f7b505eaa8dccdc666158bff2419109":["251c5b33f0a2c8988550b63c78ed22b0e84524e5","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"d6b1fd50f847900ca47783ea832846d60e81f990":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["d6b1fd50f847900ca47783ea832846d60e81f990"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["f3d902d9e126b838f492796a117a4d9e532d597a"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"f3d902d9e126b838f492796a117a4d9e532d597a":["bc57257d8a309205ebefdf9ee778da293673f599"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}