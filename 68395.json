{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoDegeneratePath#done().mjava","commits":[{"id":"45d96903d9a4f1788ca19cd283e5b2e7c196bcb6","date":1504887519,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoDegeneratePath#done().mjava","pathOld":"/dev/null","sourceNew":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final GeoPoint point = points.get(0);\n      \n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{point};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start,\n          new SidedPlane(currentSegment.startCutoffPlane));\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.start};\n        continue;\n      }\n      \n      endPoints.add(new SegmentEndpoint(currentSegment.start,\n        new SidedPlane(segments.get(i-1).endCutoffPlane),\n        new SidedPlane(currentSegment.startCutoffPlane)));\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      new SidedPlane(lastSegment.endCutoffPlane)));\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a827779f795a6643fca64532d4ea3895d12ba84","date":1505400644,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoDegeneratePath#done().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoDegeneratePath#done().mjava","sourceNew":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final GeoPoint point = points.get(0);\n      \n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{point};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start,\n          currentSegment.startCutoffPlane);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.start};\n        continue;\n      }\n      \n      endPoints.add(new SegmentEndpoint(currentSegment.start,\n        segments.get(i-1).endCutoffPlane,\n        currentSegment.startCutoffPlane));\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane));\n\n  }\n\n","sourceOld":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final GeoPoint point = points.get(0);\n      \n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{point};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start,\n          new SidedPlane(currentSegment.startCutoffPlane));\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.start};\n        continue;\n      }\n      \n      endPoints.add(new SegmentEndpoint(currentSegment.start,\n        new SidedPlane(segments.get(i-1).endCutoffPlane),\n        new SidedPlane(currentSegment.startCutoffPlane)));\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      new SidedPlane(lastSegment.endCutoffPlane)));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"685bd38810c206c93e9058f3c2cfa9827c086c27","date":1505751821,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoDegeneratePath#done().mjava","pathOld":"/dev/null","sourceNew":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      final GeoPoint point = points.get(0);\n      \n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{point};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start,\n          currentSegment.startCutoffPlane);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.start};\n        continue;\n      }\n      \n      endPoints.add(new SegmentEndpoint(currentSegment.start,\n        segments.get(i-1).endCutoffPlane,\n        currentSegment.startCutoffPlane));\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane));\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"685bd38810c206c93e9058f3c2cfa9827c086c27":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8a827779f795a6643fca64532d4ea3895d12ba84"],"8a827779f795a6643fca64532d4ea3895d12ba84":["45d96903d9a4f1788ca19cd283e5b2e7c196bcb6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8a827779f795a6643fca64532d4ea3895d12ba84"],"45d96903d9a4f1788ca19cd283e5b2e7c196bcb6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"685bd38810c206c93e9058f3c2cfa9827c086c27":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["685bd38810c206c93e9058f3c2cfa9827c086c27","45d96903d9a4f1788ca19cd283e5b2e7c196bcb6"],"8a827779f795a6643fca64532d4ea3895d12ba84":["685bd38810c206c93e9058f3c2cfa9827c086c27","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"45d96903d9a4f1788ca19cd283e5b2e7c196bcb6":["8a827779f795a6643fca64532d4ea3895d12ba84"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["685bd38810c206c93e9058f3c2cfa9827c086c27","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}