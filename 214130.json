{"path":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","commits":[{"id":"4f2bf10c11daad40c1e46fabd0d414c19a3e605b","date":1310410393,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0, outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3be20ca1091c0b7cdb2308b9023606a5e451cec","date":1327877325,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed =fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed =fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edcefacba254a0e3d6235c4b9c0a44dceaa626c5","date":1327944256,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed =fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"TEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null) {        \n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"410e066f093e407222d9681429d209084e783149","date":1327958394,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed =fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#doTest(int,int,boolean).mjava","sourceNew":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","sourceOld":"    FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n      }\n\n      final boolean willRewrite = random.nextBoolean();\n\n      final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                                prune1, prune2,\n                                                prune1==0 && prune2==0,\n                                                allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                                allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                                outputs,\n                                                null,\n                                                willRewrite);\n\n      for(InputOutput<T> pair : pairs) {\n        if (pair.output instanceof UpToTwoPositiveIntOutputs.TwoLongs) {\n          final UpToTwoPositiveIntOutputs _outputs = (UpToTwoPositiveIntOutputs) outputs;\n          final UpToTwoPositiveIntOutputs.TwoLongs twoLongs = (UpToTwoPositiveIntOutputs.TwoLongs) pair.output;\n          @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n          builderObject.add(pair.input, _outputs.get(twoLongs.first));\n          builderObject.add(pair.input, _outputs.get(twoLongs.second));\n        } else {\n          builder.add(pair.input, pair.output);\n        }\n      }\n      FST<T> fst = builder.finish();\n\n      if (random.nextBoolean() && fst != null && !willRewrite) {\n        TestFSTs t = new TestFSTs();\n        IOContext context = t.newIOContext(random);\n        IndexOutput out = dir.createOutput(\"fst.bin\", context);\n        fst.save(out);\n        out.close();\n        IndexInput in = dir.openInput(\"fst.bin\", context);\n        try {\n          fst = new FST<T>(in, outputs);\n        } finally {\n          in.close();\n          dir.deleteFile(\"fst.bin\");\n        }\n      }\n\n      if (VERBOSE && pairs.size() <= 20 && fst != null) {\n        Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n        Util.toDot(fst, w, false, false);\n        w.close();\n        System.out.println(\"SAVED out.dot\");\n      }\n\n      if (VERBOSE) {\n        if (fst == null) {\n          System.out.println(\"  fst has 0 nodes (fully pruned)\");\n        } else {\n          System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n        }\n      }\n\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, fst);\n      } else {\n        verifyPruned(inputMode, fst, prune1, prune2);\n      }\n\n      if (willRewrite && fst != null) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rewrite\");\n        }\n        final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n        if (VERBOSE) {\n          System.out.println(\"TEST: now verify packed FST\");\n        }\n        if (prune1 == 0 && prune2 == 0) {\n          verifyUnPruned(inputMode, packed);\n        } else {\n          verifyPruned(inputMode, packed, prune1, prune2);\n        }\n      }\n\n      return fst;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["4f2bf10c11daad40c1e46fabd0d414c19a3e605b"],"edcefacba254a0e3d6235c4b9c0a44dceaa626c5":["b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"410e066f093e407222d9681429d209084e783149":["817882884229bace7dc5d1b75f6b0e4aa1e47122","edcefacba254a0e3d6235c4b9c0a44dceaa626c5"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["60ba444201d2570214b6fcf1d15600dc1a01f548","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["edcefacba254a0e3d6235c4b9c0a44dceaa626c5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4f2bf10c11daad40c1e46fabd0d414c19a3e605b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5b6fdfce35d0adb18836cf8711abe487a934df33":["60ba444201d2570214b6fcf1d15600dc1a01f548","edcefacba254a0e3d6235c4b9c0a44dceaa626c5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["b3be20ca1091c0b7cdb2308b9023606a5e451cec","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"edcefacba254a0e3d6235c4b9c0a44dceaa626c5":["410e066f093e407222d9681429d209084e783149","3a119bbc8703c10faa329ec201c654b3a35a1e3e","5b6fdfce35d0adb18836cf8711abe487a934df33"],"410e066f093e407222d9681429d209084e783149":[],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["edcefacba254a0e3d6235c4b9c0a44dceaa626c5","817882884229bace7dc5d1b75f6b0e4aa1e47122"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["410e066f093e407222d9681429d209084e783149"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4f2bf10c11daad40c1e46fabd0d414c19a3e605b"],"4f2bf10c11daad40c1e46fabd0d414c19a3e605b":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["410e066f093e407222d9681429d209084e783149","5b6fdfce35d0adb18836cf8711abe487a934df33","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}