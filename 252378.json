{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf8a7ced1e96b646081915c332618d854944666e","date":1535687605,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"deea3439de4f487ae553317e50d5d641ca386374","date":1537522941,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      if (tlogReplicas + pullReplicas > 0)  {\n        throw new AssignmentException(Replica.Type.TLOG + \" or \" + Replica.Type.PULL +\n            \" replica types not supported with placement rules\");\n      }\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, tlogReplicas, pullReplicas,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1fec8b37cbb6884a64d39565e9dd7b4522a0598","date":1537699559,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      if (tlogReplicas + pullReplicas > 0)  {\n        throw new AssignmentException(Replica.Type.TLOG + \" or \" + Replica.Type.PULL +\n            \" replica types not supported with placement rules\");\n      }\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, tlogReplicas, pullReplicas,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"bf8a7ced1e96b646081915c332618d854944666e":["b94236357aaa22b76c10629851fe4e376e0cea82"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["bf8a7ced1e96b646081915c332618d854944666e","deea3439de4f487ae553317e50d5d641ca386374"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"deea3439de4f487ae553317e50d5d641ca386374":["bf8a7ced1e96b646081915c332618d854944666e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["bf8a7ced1e96b646081915c332618d854944666e"],"bf8a7ced1e96b646081915c332618d854944666e":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598","deea3439de4f487ae553317e50d5d641ca386374"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"deea3439de4f487ae553317e50d5d641ca386374":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}