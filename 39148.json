{"path":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","commits":[{"id":"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","date":1430750405,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    class Info extends SnitchContext.SnitchInfo {\n      final Snitch snitch;\n      final Set<String> myTags = new HashSet<>();\n      final Map<String, SnitchContext> nodeVsContext = new HashMap<>();\n\n      Info(Map<String, Object> conf, Snitch snitch) {\n        super(conf);\n        this.snitch = snitch;\n      }\n\n      @Override\n      public Set<String> getTagNames() {\n        return myTags;\n      }\n\n      @Override\n      public CoreContainer getCoreContainer() {\n        return cc;\n      }\n    }\n\n    Map<Class, Info> snitches = new LinkedHashMap<>();\n    for (Object o : snitchConf) {\n      //instantiating explicitly specified snitches\n      String klas = null;\n      Map map = Collections.emptyMap();\n      if (o instanceof Map) {//it can be a Map\n        map = (Map) o;\n        klas = (String) map.get(\"class\");\n        if (klas == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"snitch must have  a class attribute\");\n        }\n      } else { //or just the snitch name\n        klas = o.toString();\n      }\n      try {\n        if (klas.indexOf('.') == -1) klas = Snitch.class.getPackage().getName() + \".\" + klas;\n        Snitch inst = cc == null ?\n            (Snitch) Snitch.class.getClassLoader().loadClass(klas).newInstance() :\n            cc.getResourceLoader().newInstance(klas, Snitch.class);\n        snitches.put(inst.getClass(), new Info(map, inst));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n\n      }\n\n    }\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new Info(Collections.EMPTY_MAP, (Snitch) c.newInstance()));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (Info info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : liveNodes) {\n      //now use the Snitch to get the tags\n      for (Info info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = new SnitchContext(info, node);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (Info info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          liveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (liveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","bf98283bf93e06ee092a158798e6a9d53bb4c747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8","date":1431966199,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : liveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = new SnitchContext(info, node);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          liveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (liveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    class Info extends SnitchContext.SnitchInfo {\n      final Snitch snitch;\n      final Set<String> myTags = new HashSet<>();\n      final Map<String, SnitchContext> nodeVsContext = new HashMap<>();\n\n      Info(Map<String, Object> conf, Snitch snitch) {\n        super(conf);\n        this.snitch = snitch;\n      }\n\n      @Override\n      public Set<String> getTagNames() {\n        return myTags;\n      }\n\n      @Override\n      public CoreContainer getCoreContainer() {\n        return cc;\n      }\n    }\n\n    Map<Class, Info> snitches = new LinkedHashMap<>();\n    for (Object o : snitchConf) {\n      //instantiating explicitly specified snitches\n      String klas = null;\n      Map map = Collections.emptyMap();\n      if (o instanceof Map) {//it can be a Map\n        map = (Map) o;\n        klas = (String) map.get(\"class\");\n        if (klas == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"snitch must have  a class attribute\");\n        }\n      } else { //or just the snitch name\n        klas = o.toString();\n      }\n      try {\n        if (klas.indexOf('.') == -1) klas = Snitch.class.getPackage().getName() + \".\" + klas;\n        Snitch inst = cc == null ?\n            (Snitch) Snitch.class.getClassLoader().loadClass(klas).newInstance() :\n            cc.getResourceLoader().newInstance(klas, Snitch.class);\n        snitches.put(inst.getClass(), new Info(map, inst));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n\n      }\n\n    }\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new Info(Collections.EMPTY_MAP, (Snitch) c.newInstance()));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (Info info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : liveNodes) {\n      //now use the Snitch to get the tags\n      for (Info info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = new SnitchContext(info, node);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (Info info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          liveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (liveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","date":1457088757,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = new SnitchContext(info, node);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : liveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = new SnitchContext(info, node);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          liveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (liveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","bugFix":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e9db5fcef0c59566ad373ff7844f8a985f0017c","date":1467374856,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = new SnitchContext(info, node);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dded3df9e710f258905cff1def2f25eb51c62e0f","date":1475158173,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info, cc);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node, context.exception);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info, cc);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node, context.exception);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info, cc);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node, context.exception);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = new SnitchContext(info, node);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bf98283bf93e06ee092a158798e6a9d53bb4c747","date":1483715447,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info, cc);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node, context.exception);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          Map<String, Object> tags = result.get(node);\n          if (tags == null) {\n            tags = new HashMap<>();\n            result.put(node, tags);\n          }\n          tags.putAll(context.getTags());\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info, cc);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node, context.exception);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","bugFix":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"491c9672ec42582fe43960452dbd37f1c80fe0f0","date":1483739222,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info, cc);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node, context.exception);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          Map<String, Object> tags = result.get(node);\n          if (tags == null) {\n            tags = new HashMap<>();\n            result.put(node, tags);\n          }\n          tags.putAll(context.getTags());\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info, cc);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node, context.exception);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          if (context.getTags().keySet().containsAll(context.snitchInfo.getTagNames())) {\n            Map<String, Object> tags = result.get(node);\n            if (tags == null) {\n              tags = new HashMap<>();\n              result.put(node, tags);\n            }\n            tags.putAll(context.getTags());\n          }\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6397103f7076f0b5ee4edf5b3a63c750a072ff65","date":1510231708,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(SolrCloudManager,List).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#getTagsForNodes(CoreContainer,List).mjava","sourceNew":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final SolrCloudManager cloudManager, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cloudManager, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cloudManager));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info, cloudManager);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node, context.exception);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          Map<String, Object> tags = result.get(node);\n          if (tags == null) {\n            tags = new HashMap<>();\n            result.put(node, tags);\n          }\n          tags.putAll(context.getTags());\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","sourceOld":"  /**\n   * This method uses the snitches and get the tags for all the nodes\n   */\n  private Map<String, Map<String, Object>> getTagsForNodes(final CoreContainer cc, List snitchConf) {\n\n    Map<Class, SnitchInfoImpl> snitches = getSnitchInfos(cc, snitchConf);\n    for (Class c : Snitch.WELL_KNOWN_SNITCHES) {\n      if (snitches.containsKey(c)) continue;// it is already specified explicitly , ignore\n      try {\n        snitches.put(c, new SnitchInfoImpl(Collections.EMPTY_MAP, (Snitch) c.newInstance(), cc));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error instantiating Snitch \" + c.getName());\n      }\n    }\n    for (String tagName : tagNames) {\n      //identify which snitch is going to provide values for a given tag\n      boolean foundProvider = false;\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (info.snitch.isKnownTag(tagName)) {\n          foundProvider = true;\n          info.myTags.add(tagName);\n          break;\n        }\n      }\n      if (!foundProvider)\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown tag in rules \" + tagName);\n    }\n\n\n    for (String node : participatingLiveNodes) {\n      //now use the Snitch to get the tags\n      for (SnitchInfoImpl info : snitches.values()) {\n        if (!info.myTags.isEmpty()) {\n          SnitchContext context = getSnitchCtx(node, info, cc);\n          info.nodeVsContext.put(node, context);\n          try {\n            info.snitch.getTags(node, info.myTags, context);\n          } catch (Exception e) {\n            context.exception = e;\n          }\n        }\n      }\n    }\n\n    Map<String, Map<String, Object>> result = new HashMap<>();\n    for (SnitchInfoImpl info : snitches.values()) {\n      for (Map.Entry<String, SnitchContext> e : info.nodeVsContext.entrySet()) {\n        SnitchContext context = e.getValue();\n        String node = e.getKey();\n        if (context.exception != null) {\n          failedNodes.put(node, context);\n          participatingLiveNodes.remove(node);\n          log.warn(\"Not all tags were obtained from node \" + node, context.exception);\n          context.exception = new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Not all tags were obtained from node \" + node);\n        } else {\n          Map<String, Object> tags = result.get(node);\n          if (tags == null) {\n            tags = new HashMap<>();\n            result.put(node, tags);\n          }\n          tags.putAll(context.getTags());\n        }\n      }\n    }\n\n    if (participatingLiveNodes.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Could not get all tags for any nodes\");\n\n    }\n    return result;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8"],"bf98283bf93e06ee092a158798e6a9d53bb4c747":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6397103f7076f0b5ee4edf5b3a63c750a072ff65":["bf98283bf93e06ee092a158798e6a9d53bb4c747"],"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["2e9db5fcef0c59566ad373ff7844f8a985f0017c","dded3df9e710f258905cff1def2f25eb51c62e0f"],"2e9db5fcef0c59566ad373ff7844f8a985f0017c":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132"],"dded3df9e710f258905cff1def2f25eb51c62e0f":["2e9db5fcef0c59566ad373ff7844f8a985f0017c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6397103f7076f0b5ee4edf5b3a63c750a072ff65"],"491c9672ec42582fe43960452dbd37f1c80fe0f0":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","bf98283bf93e06ee092a158798e6a9d53bb4c747"]},"commit2Childs":{"5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132":["2e9db5fcef0c59566ad373ff7844f8a985f0017c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"bf98283bf93e06ee092a158798e6a9d53bb4c747":["6397103f7076f0b5ee4edf5b3a63c750a072ff65","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132"],"6397103f7076f0b5ee4edf5b3a63c750a072ff65":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["bf98283bf93e06ee092a158798e6a9d53bb4c747","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"2e9db5fcef0c59566ad373ff7844f8a985f0017c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","dded3df9e710f258905cff1def2f25eb51c62e0f"],"dded3df9e710f258905cff1def2f25eb51c62e0f":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["491c9672ec42582fe43960452dbd37f1c80fe0f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"491c9672ec42582fe43960452dbd37f1c80fe0f0":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}