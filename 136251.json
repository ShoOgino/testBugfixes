{"path":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases ,int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases ,int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7523dd562634d9145b67eb4c8b3b3db2340532b","date":1330467618,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases, int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases ,int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases, int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases ,int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e25729298aefe258b77e1b2676ae1088c1a2c49d","date":1338320376,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],MergeState.DocMap[],SortedSourceSlice).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases, MergeState.DocMap[] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final MergeState.DocMap currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null && currentDocMap.hasDeletions()) { // we have deletes\n      for (int i = 0; i < currentDocMap.maxDoc(); i++) {\n        final int doc = currentDocMap.get(i);\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases, int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e25729298aefe258b77e1b2676ae1088c1a2c49d":["b7523dd562634d9145b67eb4c8b3b3db2340532b"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","b7523dd562634d9145b67eb4c8b3b3db2340532b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7523dd562634d9145b67eb4c8b3b3db2340532b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e25729298aefe258b77e1b2676ae1088c1a2c49d"]},"commit2Childs":{"e25729298aefe258b77e1b2676ae1088c1a2c49d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b7523dd562634d9145b67eb4c8b3b3db2340532b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b7523dd562634d9145b67eb4c8b3b3db2340532b":["e25729298aefe258b77e1b2676ae1088c1a2c49d","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}