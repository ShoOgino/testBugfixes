{"path":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.SortedSetAggregator#aggregate(MatchingDocs,FacetArrays).mjava","commits":[{"id":"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","date":1375103250,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.SortedSetAggregator#aggregate(MatchingDocs,FacetArrays).mjava","pathOld":"/dev/null","sourceNew":"    public void aggregate(MatchingDocs matchingDocs, FacetArrays facetArrays) throws IOException {\n\n      AtomicReader reader = matchingDocs.context.reader();\n\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(matchingDocs.context).reader() != state.origReader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      SortedSetDocValues segValues = reader.getSortedSetDocValues(field);\n      if (segValues == null) {\n        return;\n      }\n\n      final int[] counts = facetArrays.getIntArray();\n      final int maxDoc = reader.maxDoc();\n      assert maxDoc == matchingDocs.bits.length();\n\n      if (dv instanceof MultiSortedSetDocValues) {\n        MultiDocValues.OrdinalMap ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n        int segOrd = matchingDocs.context.ord;\n\n        int numSegOrds = (int) segValues.getValueCount();\n\n        if (matchingDocs.totalHits < numSegOrds/10) {\n          // Remap every ord to global ord as we iterate:\n          int doc = 0;\n          while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n            segValues.setDocument(doc);\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              counts[(int) ordinalMap.getGlobalOrd(segOrd, term)]++;\n              term = (int) segValues.nextOrd();\n            }\n            ++doc;\n          }\n        } else {\n\n          // First count in seg-ord space:\n          final int[] segCounts = new int[numSegOrds];\n          int doc = 0;\n          while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n            segValues.setDocument(doc);\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              segCounts[term]++;\n              term = (int) segValues.nextOrd();\n            }\n            ++doc;\n          }\n\n          // Then, migrate to global ords:\n          for(int ord=0;ord<numSegOrds;ord++) {\n            int count = segCounts[ord];\n            if (count != 0) {\n              counts[(int) ordinalMap.getGlobalOrd(segOrd, ord)] += count;\n            }\n          }\n        }\n      } else {\n        // No ord mapping (e.g., single segment index):\n        // just aggregate directly into counts:\n\n        int doc = 0;\n        while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n          segValues.setDocument(doc);\n          int term = (int) segValues.nextOrd();\n          while (term != SortedSetDocValues.NO_MORE_ORDS) {\n            counts[term]++;\n            term = (int) segValues.nextOrd();\n          }\n          ++doc;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":0,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.SortedSetAggregator#aggregate(MatchingDocs,FacetArrays).mjava","pathOld":"/dev/null","sourceNew":"    public void aggregate(MatchingDocs matchingDocs, FacetArrays facetArrays) throws IOException {\n\n      AtomicReader reader = matchingDocs.context.reader();\n\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(matchingDocs.context).reader() != state.origReader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      SortedSetDocValues segValues = reader.getSortedSetDocValues(field);\n      if (segValues == null) {\n        return;\n      }\n\n      final int[] counts = facetArrays.getIntArray();\n      final int maxDoc = reader.maxDoc();\n      assert maxDoc == matchingDocs.bits.length();\n\n      if (dv instanceof MultiSortedSetDocValues) {\n        MultiDocValues.OrdinalMap ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n        int segOrd = matchingDocs.context.ord;\n\n        int numSegOrds = (int) segValues.getValueCount();\n\n        if (matchingDocs.totalHits < numSegOrds/10) {\n          // Remap every ord to global ord as we iterate:\n          int doc = 0;\n          while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n            segValues.setDocument(doc);\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              counts[(int) ordinalMap.getGlobalOrd(segOrd, term)]++;\n              term = (int) segValues.nextOrd();\n            }\n            ++doc;\n          }\n        } else {\n\n          // First count in seg-ord space:\n          final int[] segCounts = new int[numSegOrds];\n          int doc = 0;\n          while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n            segValues.setDocument(doc);\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              segCounts[term]++;\n              term = (int) segValues.nextOrd();\n            }\n            ++doc;\n          }\n\n          // Then, migrate to global ords:\n          for(int ord=0;ord<numSegOrds;ord++) {\n            int count = segCounts[ord];\n            if (count != 0) {\n              counts[(int) ordinalMap.getGlobalOrd(segOrd, ord)] += count;\n            }\n          }\n        }\n      } else {\n        // No ord mapping (e.g., single segment index):\n        // just aggregate directly into counts:\n\n        int doc = 0;\n        while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n          segValues.setDocument(doc);\n          int term = (int) segValues.nextOrd();\n          while (term != SortedSetDocValues.NO_MORE_ORDS) {\n            counts[term]++;\n            term = (int) segValues.nextOrd();\n          }\n          ++doc;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8428426152984b387a961487efefbe9cf62acf","date":1385332540,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.SortedSetAggregator#aggregate(MatchingDocs,FacetArrays).mjava","sourceNew":null,"sourceOld":"    public void aggregate(MatchingDocs matchingDocs, FacetArrays facetArrays) throws IOException {\n\n      AtomicReader reader = matchingDocs.context.reader();\n\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(matchingDocs.context).reader() != state.origReader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      SortedSetDocValues segValues = reader.getSortedSetDocValues(field);\n      if (segValues == null) {\n        return;\n      }\n\n      final int[] counts = facetArrays.getIntArray();\n      final int maxDoc = reader.maxDoc();\n      assert maxDoc == matchingDocs.bits.length();\n\n      if (dv instanceof MultiSortedSetDocValues) {\n        MultiDocValues.OrdinalMap ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n        int segOrd = matchingDocs.context.ord;\n\n        int numSegOrds = (int) segValues.getValueCount();\n\n        if (matchingDocs.totalHits < numSegOrds/10) {\n          // Remap every ord to global ord as we iterate:\n          int doc = 0;\n          while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n            segValues.setDocument(doc);\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              counts[(int) ordinalMap.getGlobalOrd(segOrd, term)]++;\n              term = (int) segValues.nextOrd();\n            }\n            ++doc;\n          }\n        } else {\n\n          // First count in seg-ord space:\n          final int[] segCounts = new int[numSegOrds];\n          int doc = 0;\n          while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n            segValues.setDocument(doc);\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              segCounts[term]++;\n              term = (int) segValues.nextOrd();\n            }\n            ++doc;\n          }\n\n          // Then, migrate to global ords:\n          for(int ord=0;ord<numSegOrds;ord++) {\n            int count = segCounts[ord];\n            if (count != 0) {\n              counts[(int) ordinalMap.getGlobalOrd(segOrd, ord)] += count;\n            }\n          }\n        }\n      } else {\n        // No ord mapping (e.g., single segment index):\n        // just aggregate directly into counts:\n\n        int doc = 0;\n        while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n          segValues.setDocument(doc);\n          int term = (int) segValues.nextOrd();\n          while (term != SortedSetDocValues.NO_MORE_ORDS) {\n            counts[term]++;\n            term = (int) segValues.nextOrd();\n          }\n          ++doc;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.SortedSetAggregator#aggregate(MatchingDocs,FacetArrays).mjava","sourceNew":null,"sourceOld":"    public void aggregate(MatchingDocs matchingDocs, FacetArrays facetArrays) throws IOException {\n\n      AtomicReader reader = matchingDocs.context.reader();\n\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(matchingDocs.context).reader() != state.origReader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      SortedSetDocValues segValues = reader.getSortedSetDocValues(field);\n      if (segValues == null) {\n        return;\n      }\n\n      final int[] counts = facetArrays.getIntArray();\n      final int maxDoc = reader.maxDoc();\n      assert maxDoc == matchingDocs.bits.length();\n\n      if (dv instanceof MultiSortedSetDocValues) {\n        MultiDocValues.OrdinalMap ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n        int segOrd = matchingDocs.context.ord;\n\n        int numSegOrds = (int) segValues.getValueCount();\n\n        if (matchingDocs.totalHits < numSegOrds/10) {\n          // Remap every ord to global ord as we iterate:\n          int doc = 0;\n          while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n            segValues.setDocument(doc);\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              counts[(int) ordinalMap.getGlobalOrd(segOrd, term)]++;\n              term = (int) segValues.nextOrd();\n            }\n            ++doc;\n          }\n        } else {\n\n          // First count in seg-ord space:\n          final int[] segCounts = new int[numSegOrds];\n          int doc = 0;\n          while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n            segValues.setDocument(doc);\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              segCounts[term]++;\n              term = (int) segValues.nextOrd();\n            }\n            ++doc;\n          }\n\n          // Then, migrate to global ords:\n          for(int ord=0;ord<numSegOrds;ord++) {\n            int count = segCounts[ord];\n            if (count != 0) {\n              counts[(int) ordinalMap.getGlobalOrd(segOrd, ord)] += count;\n            }\n          }\n        }\n      } else {\n        // No ord mapping (e.g., single segment index):\n        // just aggregate directly into counts:\n\n        int doc = 0;\n        while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {\n          segValues.setDocument(doc);\n          int term = (int) segValues.nextOrd();\n          while (term != SortedSetDocValues.NO_MORE_ORDS) {\n            counts[term]++;\n            term = (int) segValues.nextOrd();\n          }\n          ++doc;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","2e8428426152984b387a961487efefbe9cf62acf"],"2e8428426152984b387a961487efefbe9cf62acf":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2e8428426152984b387a961487efefbe9cf62acf":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["3cc728b07df73b197e6d940d27f9b08b63918f13","2e8428426152984b387a961487efefbe9cf62acf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}