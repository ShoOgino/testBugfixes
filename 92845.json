{"path":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteAliasWithExistingCollectionName().mjava","commits":[{"id":"4b342321d8906f4b19f6f87ea33ea3fff12bffa7","date":1515547632,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteAliasWithExistingCollectionName().mjava","pathOld":"/dev/null","sourceNew":"  // Rather a long title, but it's common to recommend when people need to re-index for any reason that they:\n  // 1> create a new collection\n  // 2> index the corpus to the new collection and verify it\n  // 3> create an alias pointing to the new collection WITH THE SAME NAME as their original collection\n  // 4> delete the old collection.\n  //\n  // They may or may not have an alias already pointing to the old collection that's being replaced.\n  // If they don't already have an alias, this leaves them with:\n  //\n  // > a collection named old_collection\n  // > a collection named new_collection\n  // > an alias old_collection->new_collection\n  //\n  // What happens when they delete old_collection now?\n  //\n  // Current behavior is that delete \"does the right thing\" and deletes old_collection rather than new_collection,\n  // but if this behavior changes it could be disastrous for users so this test insures that this behavior.\n  //\n  @Test\n  public void testDeleteAliasWithExistingCollectionName() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_old\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_new\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection_old to be created with 2 shards and 1 replica\", \"collection_old\", clusterShape(2, 1));\n    waitForState(\"Expected collection_new to be created with 1 shard and 1 replica\", \"collection_new\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"6\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .add(\"id\", \"7\", \"a_t\", \"humpty dumpy3 sat on a walls\")\n        .add(\"id\", \"8\", \"a_t\", \"humpty dumpy2 sat on a walled\")\n        .commit(cluster.getSolrClient(), \"collection_old\");\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on an unfortunate wall\")\n        .commit(cluster.getSolrClient(), \"collection_new\");\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Let's insure we have a \"handle\" to the old collection\n    CollectionAdminRequest.createAlias(\"collection_old_reserve\", \"collection_old\").process(cluster.getSolrClient());\n\n    // This is the critical bit. The alias uses the _old collection name.\n    CollectionAdminRequest.createAlias(\"collection_old\", \"collection_new\").process(cluster.getSolrClient());\n\n    // aliases: collection_old->collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_new and collection_old\n\n    // Now we should only see the doc in collection_new through the collection_old alias\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now we should still transitively see collection_new\n    res = cluster.getSolrClient().query(\"collection_old_reserve\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now delete the old collection. This should fail since the collection_old_reserve points to collection_old\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // assure ourselves that the old colletion is, indeed, still there.\n    assertNotNull(\"collection_old should exist!\", cluster.getSolrClient().getZkStateReader().getClusterState().getCollectionOrNull(\"collection_old\"));\n\n    // Now we should still succeed using the alias collection_old which points to collection_new\n    // aliase: collection_old -> collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_old, collection_new\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    Aliases aliases = cluster.getSolrClient().getZkStateReader().getAliases();\n    assertTrue(\"collection_old should point to collection_new\", aliases.resolveAliases(\"collection_old\").contains(\"collection_new\"));\n    assertTrue(\"collection_old_reserve should point to collection_new\", aliases.resolveAliases(\"collection_old_reserve\").contains(\"collection_new\"));\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_old_reserve\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteAlias(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_new\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_old already deleted as well as collection_old_reserve\n\n    assertNull(\"collection_old_reserve should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old_reserve\"));\n    assertNull(\"collection_old should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old\"));\n\n    assertFalse(\"collection_new should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_new\"));\n\n    assertFalse(\"collection_old should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_old\"));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteAliasWithExistingCollectionName().mjava","pathOld":"/dev/null","sourceNew":"  // Rather a long title, but it's common to recommend when people need to re-index for any reason that they:\n  // 1> create a new collection\n  // 2> index the corpus to the new collection and verify it\n  // 3> create an alias pointing to the new collection WITH THE SAME NAME as their original collection\n  // 4> delete the old collection.\n  //\n  // They may or may not have an alias already pointing to the old collection that's being replaced.\n  // If they don't already have an alias, this leaves them with:\n  //\n  // > a collection named old_collection\n  // > a collection named new_collection\n  // > an alias old_collection->new_collection\n  //\n  // What happens when they delete old_collection now?\n  //\n  // Current behavior is that delete \"does the right thing\" and deletes old_collection rather than new_collection,\n  // but if this behavior changes it could be disastrous for users so this test insures that this behavior.\n  //\n  @Test\n  public void testDeleteAliasWithExistingCollectionName() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_old\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_new\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection_old to be created with 2 shards and 1 replica\", \"collection_old\", clusterShape(2, 1));\n    waitForState(\"Expected collection_new to be created with 1 shard and 1 replica\", \"collection_new\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"6\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .add(\"id\", \"7\", \"a_t\", \"humpty dumpy3 sat on a walls\")\n        .add(\"id\", \"8\", \"a_t\", \"humpty dumpy2 sat on a walled\")\n        .commit(cluster.getSolrClient(), \"collection_old\");\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on an unfortunate wall\")\n        .commit(cluster.getSolrClient(), \"collection_new\");\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Let's insure we have a \"handle\" to the old collection\n    CollectionAdminRequest.createAlias(\"collection_old_reserve\", \"collection_old\").process(cluster.getSolrClient());\n\n    // This is the critical bit. The alias uses the _old collection name.\n    CollectionAdminRequest.createAlias(\"collection_old\", \"collection_new\").process(cluster.getSolrClient());\n\n    // aliases: collection_old->collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_new and collection_old\n\n    // Now we should only see the doc in collection_new through the collection_old alias\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now we should still transitively see collection_new\n    res = cluster.getSolrClient().query(\"collection_old_reserve\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now delete the old collection. This should fail since the collection_old_reserve points to collection_old\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // assure ourselves that the old colletion is, indeed, still there.\n    assertNotNull(\"collection_old should exist!\", cluster.getSolrClient().getZkStateReader().getClusterState().getCollectionOrNull(\"collection_old\"));\n\n    // Now we should still succeed using the alias collection_old which points to collection_new\n    // aliase: collection_old -> collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_old, collection_new\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    Aliases aliases = cluster.getSolrClient().getZkStateReader().getAliases();\n    assertTrue(\"collection_old should point to collection_new\", aliases.resolveAliases(\"collection_old\").contains(\"collection_new\"));\n    assertTrue(\"collection_old_reserve should point to collection_new\", aliases.resolveAliases(\"collection_old_reserve\").contains(\"collection_new\"));\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_old_reserve\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteAlias(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_new\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_old already deleted as well as collection_old_reserve\n\n    assertNull(\"collection_old_reserve should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old_reserve\"));\n    assertNull(\"collection_old should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old\"));\n\n    assertFalse(\"collection_new should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_new\"));\n\n    assertFalse(\"collection_old should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_old\"));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteAliasWithExistingCollectionName().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteAliasWithExistingCollectionName().mjava","sourceNew":"  // Rather a long title, but it's common to recommend when people need to re-index for any reason that they:\n  // 1> create a new collection\n  // 2> index the corpus to the new collection and verify it\n  // 3> create an alias pointing to the new collection WITH THE SAME NAME as their original collection\n  // 4> delete the old collection.\n  //\n  // They may or may not have an alias already pointing to the old collection that's being replaced.\n  // If they don't already have an alias, this leaves them with:\n  //\n  // > a collection named old_collection\n  // > a collection named new_collection\n  // > an alias old_collection->new_collection\n  //\n  // What happens when they delete old_collection now?\n  //\n  // Current behavior is that delete \"does the right thing\" and deletes old_collection rather than new_collection,\n  // but if this behavior changes it could be disastrous for users so this test insures that this behavior.\n  //\n  @Test\n  public void testDeleteAliasWithExistingCollectionName() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_old\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_new\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_old\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_new\", 1, 1);\n    \n    waitForState(\"Expected collection_old to be created with 2 shards and 1 replica\", \"collection_old\", clusterShape(2, 2));\n    waitForState(\"Expected collection_new to be created with 1 shard and 1 replica\", \"collection_new\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"6\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .add(\"id\", \"7\", \"a_t\", \"humpty dumpy3 sat on a walls\")\n        .add(\"id\", \"8\", \"a_t\", \"humpty dumpy2 sat on a walled\")\n        .commit(cluster.getSolrClient(), \"collection_old\");\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on an unfortunate wall\")\n        .commit(cluster.getSolrClient(), \"collection_new\");\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Let's insure we have a \"handle\" to the old collection\n    CollectionAdminRequest.createAlias(\"collection_old_reserve\", \"collection_old\").process(cluster.getSolrClient());\n\n    // This is the critical bit. The alias uses the _old collection name.\n    CollectionAdminRequest.createAlias(\"collection_old\", \"collection_new\").process(cluster.getSolrClient());\n\n    // aliases: collection_old->collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_new and collection_old\n\n    // Now we should only see the doc in collection_new through the collection_old alias\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now we should still transitively see collection_new\n    res = cluster.getSolrClient().query(\"collection_old_reserve\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now delete the old collection. This should fail since the collection_old_reserve points to collection_old\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // assure ourselves that the old colletion is, indeed, still there.\n    assertNotNull(\"collection_old should exist!\", cluster.getSolrClient().getZkStateReader().getClusterState().getCollectionOrNull(\"collection_old\"));\n\n    // Now we should still succeed using the alias collection_old which points to collection_new\n    // aliase: collection_old -> collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_old, collection_new\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    Aliases aliases = cluster.getSolrClient().getZkStateReader().getAliases();\n    assertTrue(\"collection_old should point to collection_new\", aliases.resolveAliases(\"collection_old\").contains(\"collection_new\"));\n    assertTrue(\"collection_old_reserve should point to collection_new\", aliases.resolveAliases(\"collection_old_reserve\").contains(\"collection_new\"));\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_old_reserve\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteAlias(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_new\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_old already deleted as well as collection_old_reserve\n\n    assertNull(\"collection_old_reserve should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old_reserve\"));\n    assertNull(\"collection_old should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old\"));\n\n    assertFalse(\"collection_new should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_new\"));\n\n    assertFalse(\"collection_old should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_old\"));\n  }\n\n","sourceOld":"  // Rather a long title, but it's common to recommend when people need to re-index for any reason that they:\n  // 1> create a new collection\n  // 2> index the corpus to the new collection and verify it\n  // 3> create an alias pointing to the new collection WITH THE SAME NAME as their original collection\n  // 4> delete the old collection.\n  //\n  // They may or may not have an alias already pointing to the old collection that's being replaced.\n  // If they don't already have an alias, this leaves them with:\n  //\n  // > a collection named old_collection\n  // > a collection named new_collection\n  // > an alias old_collection->new_collection\n  //\n  // What happens when they delete old_collection now?\n  //\n  // Current behavior is that delete \"does the right thing\" and deletes old_collection rather than new_collection,\n  // but if this behavior changes it could be disastrous for users so this test insures that this behavior.\n  //\n  @Test\n  public void testDeleteAliasWithExistingCollectionName() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_old\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_new\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection_old to be created with 2 shards and 1 replica\", \"collection_old\", clusterShape(2, 1));\n    waitForState(\"Expected collection_new to be created with 1 shard and 1 replica\", \"collection_new\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"6\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .add(\"id\", \"7\", \"a_t\", \"humpty dumpy3 sat on a walls\")\n        .add(\"id\", \"8\", \"a_t\", \"humpty dumpy2 sat on a walled\")\n        .commit(cluster.getSolrClient(), \"collection_old\");\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on an unfortunate wall\")\n        .commit(cluster.getSolrClient(), \"collection_new\");\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Let's insure we have a \"handle\" to the old collection\n    CollectionAdminRequest.createAlias(\"collection_old_reserve\", \"collection_old\").process(cluster.getSolrClient());\n\n    // This is the critical bit. The alias uses the _old collection name.\n    CollectionAdminRequest.createAlias(\"collection_old\", \"collection_new\").process(cluster.getSolrClient());\n\n    // aliases: collection_old->collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_new and collection_old\n\n    // Now we should only see the doc in collection_new through the collection_old alias\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now we should still transitively see collection_new\n    res = cluster.getSolrClient().query(\"collection_old_reserve\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now delete the old collection. This should fail since the collection_old_reserve points to collection_old\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // assure ourselves that the old colletion is, indeed, still there.\n    assertNotNull(\"collection_old should exist!\", cluster.getSolrClient().getZkStateReader().getClusterState().getCollectionOrNull(\"collection_old\"));\n\n    // Now we should still succeed using the alias collection_old which points to collection_new\n    // aliase: collection_old -> collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_old, collection_new\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    Aliases aliases = cluster.getSolrClient().getZkStateReader().getAliases();\n    assertTrue(\"collection_old should point to collection_new\", aliases.resolveAliases(\"collection_old\").contains(\"collection_new\"));\n    assertTrue(\"collection_old_reserve should point to collection_new\", aliases.resolveAliases(\"collection_old_reserve\").contains(\"collection_new\"));\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_old_reserve\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteAlias(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_new\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_old already deleted as well as collection_old_reserve\n\n    assertNull(\"collection_old_reserve should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old_reserve\"));\n    assertNull(\"collection_old should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old\"));\n\n    assertFalse(\"collection_new should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_new\"));\n\n    assertFalse(\"collection_old should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_old\"));\n  }\n\n","bugFix":["4b342321d8906f4b19f6f87ea33ea3fff12bffa7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc21266829f9cffb210032f5808ce3a630780ab3","date":1560248034,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteAliasWithExistingCollectionName().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteAliasWithExistingCollectionName().mjava","sourceNew":"  // Rather a long title, but it's common to recommend when people need to re-index for any reason that they:\n  // 1> create a new collection\n  // 2> index the corpus to the new collection and verify it\n  // 3> create an alias pointing to the new collection WITH THE SAME NAME as their original collection\n  // 4> delete the old collection.\n  //\n  // They may or may not have an alias already pointing to the old collection that's being replaced.\n  // If they don't already have an alias, this leaves them with:\n  //\n  // > a collection named old_collection\n  // > a collection named new_collection\n  // > an alias old_collection->new_collection\n  //\n  // What happens when they delete old_collection now?\n  //\n  // Current behavior is that delete \"does the right thing\" and deletes old_collection rather than new_collection,\n  // but if this behavior changes it could be disastrous for users so this test insures that this behavior.\n  //\n  @Test\n  public void testDeleteAliasWithExistingCollectionName() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_old\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_new\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_old\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_new\", 1, 1);\n    \n    waitForState(\"Expected collection_old to be created with 2 shards and 1 replica\", \"collection_old\", clusterShape(2, 2));\n    waitForState(\"Expected collection_new to be created with 1 shard and 1 replica\", \"collection_new\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"6\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .add(\"id\", \"7\", \"a_t\", \"humpty dumpy3 sat on a walls\")\n        .add(\"id\", \"8\", \"a_t\", \"humpty dumpy2 sat on a walled\")\n        .commit(cluster.getSolrClient(), \"collection_old\");\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on an unfortunate wall\")\n        .commit(cluster.getSolrClient(), \"collection_new\");\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    int lastVersion = zkStateReader.aliasesManager.getAliases().getZNodeVersion();\n    // Let's insure we have a \"handle\" to the old collection\n    CollectionAdminRequest.createAlias(\"collection_old_reserve\", \"collection_old\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    // This is the critical bit. The alias uses the _old collection name.\n    CollectionAdminRequest.createAlias(\"collection_old\", \"collection_new\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    // aliases: collection_old->collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_new and collection_old\n\n    // Now we should only see the doc in collection_new through the collection_old alias\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now we should still transitively see collection_new\n    res = cluster.getSolrClient().query(\"collection_old_reserve\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now delete the old collection. This should fail since the collection_old_reserve points to collection_old\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // assure ourselves that the old colletion is, indeed, still there.\n    assertNotNull(\"collection_old should exist!\", cluster.getSolrClient().getZkStateReader().getClusterState().getCollectionOrNull(\"collection_old\"));\n\n    // Now we should still succeed using the alias collection_old which points to collection_new\n    // aliase: collection_old -> collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_old, collection_new\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    Aliases aliases = cluster.getSolrClient().getZkStateReader().getAliases();\n    assertTrue(\"collection_old should point to collection_new\", aliases.resolveAliases(\"collection_old\").contains(\"collection_new\"));\n    assertTrue(\"collection_old_reserve should point to collection_new\", aliases.resolveAliases(\"collection_old_reserve\").contains(\"collection_new\"));\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_old_reserve\").processAndWait(cluster.getSolrClient(), 60);\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    CollectionAdminRequest.deleteAlias(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    CollectionAdminRequest.deleteCollection(\"collection_new\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_old already deleted as well as collection_old_reserve\n\n    assertNull(\"collection_old_reserve should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old_reserve\"));\n    assertNull(\"collection_old should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old\"));\n\n    assertFalse(\"collection_new should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_new\"));\n\n    assertFalse(\"collection_old should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_old\"));\n  }\n\n","sourceOld":"  // Rather a long title, but it's common to recommend when people need to re-index for any reason that they:\n  // 1> create a new collection\n  // 2> index the corpus to the new collection and verify it\n  // 3> create an alias pointing to the new collection WITH THE SAME NAME as their original collection\n  // 4> delete the old collection.\n  //\n  // They may or may not have an alias already pointing to the old collection that's being replaced.\n  // If they don't already have an alias, this leaves them with:\n  //\n  // > a collection named old_collection\n  // > a collection named new_collection\n  // > an alias old_collection->new_collection\n  //\n  // What happens when they delete old_collection now?\n  //\n  // Current behavior is that delete \"does the right thing\" and deletes old_collection rather than new_collection,\n  // but if this behavior changes it could be disastrous for users so this test insures that this behavior.\n  //\n  @Test\n  public void testDeleteAliasWithExistingCollectionName() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_old\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_new\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_old\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_new\", 1, 1);\n    \n    waitForState(\"Expected collection_old to be created with 2 shards and 1 replica\", \"collection_old\", clusterShape(2, 2));\n    waitForState(\"Expected collection_new to be created with 1 shard and 1 replica\", \"collection_new\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"6\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .add(\"id\", \"7\", \"a_t\", \"humpty dumpy3 sat on a walls\")\n        .add(\"id\", \"8\", \"a_t\", \"humpty dumpy2 sat on a walled\")\n        .commit(cluster.getSolrClient(), \"collection_old\");\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on an unfortunate wall\")\n        .commit(cluster.getSolrClient(), \"collection_new\");\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Let's insure we have a \"handle\" to the old collection\n    CollectionAdminRequest.createAlias(\"collection_old_reserve\", \"collection_old\").process(cluster.getSolrClient());\n\n    // This is the critical bit. The alias uses the _old collection name.\n    CollectionAdminRequest.createAlias(\"collection_old\", \"collection_new\").process(cluster.getSolrClient());\n\n    // aliases: collection_old->collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_new and collection_old\n\n    // Now we should only see the doc in collection_new through the collection_old alias\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now we should still transitively see collection_new\n    res = cluster.getSolrClient().query(\"collection_old_reserve\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now delete the old collection. This should fail since the collection_old_reserve points to collection_old\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // assure ourselves that the old colletion is, indeed, still there.\n    assertNotNull(\"collection_old should exist!\", cluster.getSolrClient().getZkStateReader().getClusterState().getCollectionOrNull(\"collection_old\"));\n\n    // Now we should still succeed using the alias collection_old which points to collection_new\n    // aliase: collection_old -> collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_old, collection_new\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    Aliases aliases = cluster.getSolrClient().getZkStateReader().getAliases();\n    assertTrue(\"collection_old should point to collection_new\", aliases.resolveAliases(\"collection_old\").contains(\"collection_new\"));\n    assertTrue(\"collection_old_reserve should point to collection_new\", aliases.resolveAliases(\"collection_old_reserve\").contains(\"collection_new\"));\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_old_reserve\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteAlias(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_new\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_old already deleted as well as collection_old_reserve\n\n    assertNull(\"collection_old_reserve should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old_reserve\"));\n    assertNull(\"collection_old should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old\"));\n\n    assertFalse(\"collection_new should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_new\"));\n\n    assertFalse(\"collection_old should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_old\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteAliasWithExistingCollectionName().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteAliasWithExistingCollectionName().mjava","sourceNew":"  // Rather a long title, but it's common to recommend when people need to re-index for any reason that they:\n  // 1> create a new collection\n  // 2> index the corpus to the new collection and verify it\n  // 3> create an alias pointing to the new collection WITH THE SAME NAME as their original collection\n  // 4> delete the old collection.\n  //\n  // They may or may not have an alias already pointing to the old collection that's being replaced.\n  // If they don't already have an alias, this leaves them with:\n  //\n  // > a collection named old_collection\n  // > a collection named new_collection\n  // > an alias old_collection->new_collection\n  //\n  // What happens when they delete old_collection now?\n  //\n  // Current behavior is that delete \"does the right thing\" and deletes old_collection rather than new_collection,\n  // but if this behavior changes it could be disastrous for users so this test insures that this behavior.\n  //\n  @Test\n  public void testDeleteAliasWithExistingCollectionName() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_old\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_new\", \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    cluster.waitForActiveCollection(\"collection_old\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_new\", 1, 1);\n\n    waitForState(\"Expected collection_old to be created with 2 shards and 1 replica\", \"collection_old\", clusterShape(2, 2));\n    waitForState(\"Expected collection_new to be created with 1 shard and 1 replica\", \"collection_new\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"6\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .add(\"id\", \"7\", \"a_t\", \"humpty dumpy3 sat on a walls\")\n        .add(\"id\", \"8\", \"a_t\", \"humpty dumpy2 sat on a walled\")\n        .commit(cluster.getSolrClient(), \"collection_old\");\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on an unfortunate wall\")\n        .commit(cluster.getSolrClient(), \"collection_new\");\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    int lastVersion = zkStateReader.aliasesManager.getAliases().getZNodeVersion();\n    // Let's insure we have a \"handle\" to the old collection\n    CollectionAdminRequest.createAlias(\"collection_old_reserve\", \"collection_old\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    // This is the critical bit. The alias uses the _old collection name.\n    CollectionAdminRequest.createAlias(\"collection_old\", \"collection_new\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    // aliases: collection_old->collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_new and collection_old\n\n    // Now we should only see the doc in collection_new through the collection_old alias\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now we should still transitively see collection_new\n    res = cluster.getSolrClient().query(\"collection_old_reserve\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now delete the old collection. This should fail since the collection_old_reserve points to collection_old\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // assure ourselves that the old colletion is, indeed, still there.\n    assertNotNull(\"collection_old should exist!\", cluster.getSolrClient().getZkStateReader().getClusterState().getCollectionOrNull(\"collection_old\"));\n\n    // Now we should still succeed using the alias collection_old which points to collection_new\n    // aliase: collection_old -> collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_old, collection_new\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    Aliases aliases = cluster.getSolrClient().getZkStateReader().getAliases();\n    assertTrue(\"collection_old should point to collection_new\", aliases.resolveAliases(\"collection_old\").contains(\"collection_new\"));\n    assertTrue(\"collection_old_reserve should point to collection_new\", aliases.resolveAliases(\"collection_old_reserve\").contains(\"collection_new\"));\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_old_reserve\").processAndWait(cluster.getSolrClient(), 60);\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    CollectionAdminRequest.deleteAlias(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    CollectionAdminRequest.deleteCollection(\"collection_new\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_old already deleted as well as collection_old_reserve\n\n    assertNull(\"collection_old_reserve should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old_reserve\"));\n    assertNull(\"collection_old should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old\"));\n\n    assertFalse(\"collection_new should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_new\"));\n\n    assertFalse(\"collection_old should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_old\"));\n  }\n\n","sourceOld":"  // Rather a long title, but it's common to recommend when people need to re-index for any reason that they:\n  // 1> create a new collection\n  // 2> index the corpus to the new collection and verify it\n  // 3> create an alias pointing to the new collection WITH THE SAME NAME as their original collection\n  // 4> delete the old collection.\n  //\n  // They may or may not have an alias already pointing to the old collection that's being replaced.\n  // If they don't already have an alias, this leaves them with:\n  //\n  // > a collection named old_collection\n  // > a collection named new_collection\n  // > an alias old_collection->new_collection\n  //\n  // What happens when they delete old_collection now?\n  //\n  // Current behavior is that delete \"does the right thing\" and deletes old_collection rather than new_collection,\n  // but if this behavior changes it could be disastrous for users so this test insures that this behavior.\n  //\n  @Test\n  public void testDeleteAliasWithExistingCollectionName() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_old\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_new\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_old\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_new\", 1, 1);\n    \n    waitForState(\"Expected collection_old to be created with 2 shards and 1 replica\", \"collection_old\", clusterShape(2, 2));\n    waitForState(\"Expected collection_new to be created with 1 shard and 1 replica\", \"collection_new\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"6\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .add(\"id\", \"7\", \"a_t\", \"humpty dumpy3 sat on a walls\")\n        .add(\"id\", \"8\", \"a_t\", \"humpty dumpy2 sat on a walled\")\n        .commit(cluster.getSolrClient(), \"collection_old\");\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on an unfortunate wall\")\n        .commit(cluster.getSolrClient(), \"collection_new\");\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    int lastVersion = zkStateReader.aliasesManager.getAliases().getZNodeVersion();\n    // Let's insure we have a \"handle\" to the old collection\n    CollectionAdminRequest.createAlias(\"collection_old_reserve\", \"collection_old\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    // This is the critical bit. The alias uses the _old collection name.\n    CollectionAdminRequest.createAlias(\"collection_old\", \"collection_new\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    // aliases: collection_old->collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_new and collection_old\n\n    // Now we should only see the doc in collection_new through the collection_old alias\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now we should still transitively see collection_new\n    res = cluster.getSolrClient().query(\"collection_old_reserve\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    // Now delete the old collection. This should fail since the collection_old_reserve points to collection_old\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // assure ourselves that the old colletion is, indeed, still there.\n    assertNotNull(\"collection_old should exist!\", cluster.getSolrClient().getZkStateReader().getClusterState().getCollectionOrNull(\"collection_old\"));\n\n    // Now we should still succeed using the alias collection_old which points to collection_new\n    // aliase: collection_old -> collection_new, collection_old_reserve -> collection_old -> collection_new\n    // collections: collection_old, collection_new\n    res = cluster.getSolrClient().query(\"collection_old\", new SolrQuery(\"*:*\"));\n    assertEquals(1, res.getResults().getNumFound());\n\n    Aliases aliases = cluster.getSolrClient().getZkStateReader().getAliases();\n    assertTrue(\"collection_old should point to collection_new\", aliases.resolveAliases(\"collection_old\").contains(\"collection_new\"));\n    assertTrue(\"collection_old_reserve should point to collection_new\", aliases.resolveAliases(\"collection_old_reserve\").contains(\"collection_new\"));\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_old_reserve\").processAndWait(cluster.getSolrClient(), 60);\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    CollectionAdminRequest.deleteAlias(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    CollectionAdminRequest.deleteCollection(\"collection_new\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_old\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_old already deleted as well as collection_old_reserve\n\n    assertNull(\"collection_old_reserve should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old_reserve\"));\n    assertNull(\"collection_old should be gone\", cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_old\"));\n\n    assertFalse(\"collection_new should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_new\"));\n\n    assertFalse(\"collection_old should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_old\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4b342321d8906f4b19f6f87ea33ea3fff12bffa7"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4b342321d8906f4b19f6f87ea33ea3fff12bffa7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["fc21266829f9cffb210032f5808ce3a630780ab3"],"fc21266829f9cffb210032f5808ce3a630780ab3":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"4b342321d8906f4b19f6f87ea33ea3fff12bffa7":["b94236357aaa22b76c10629851fe4e376e0cea82"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["fc21266829f9cffb210032f5808ce3a630780ab3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","4b342321d8906f4b19f6f87ea33ea3fff12bffa7"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fc21266829f9cffb210032f5808ce3a630780ab3":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}