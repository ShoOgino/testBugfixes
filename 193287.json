{"path":"modules/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","commits":[{"id":"ecc11368dc265bfdad90214f8bf5da99016ab1e2","date":1294144090,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"/dev/null","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7ee868f5038843b2550e6e996be578b90d65378","date":1309428052,"type":4,"author":"Doron Cohen","isMerge":false,"pathNew":"/dev/null","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":null,"sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":4,"author":"Steven Rowe","isMerge":true,"pathNew":"/dev/null","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":null,"sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":null,"sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuilder sb = new StringBuilder();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"ecc11368dc265bfdad90214f8bf5da99016ab1e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e7ee868f5038843b2550e6e996be578b90d65378":["ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["ecc11368dc265bfdad90214f8bf5da99016ab1e2","e7ee868f5038843b2550e6e996be578b90d65378"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["ecc11368dc265bfdad90214f8bf5da99016ab1e2","e7ee868f5038843b2550e6e996be578b90d65378"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7ee868f5038843b2550e6e996be578b90d65378"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":[],"ecc11368dc265bfdad90214f8bf5da99016ab1e2":["70ad682703b8585f5d0a637efec044d57ec05efb","e7ee868f5038843b2550e6e996be578b90d65378","d083e83f225b11e5fdd900e83d26ddb385b6955c","868da859b43505d9d2a023bfeae6dd0c795f5295","817d8435e9135b756f08ce6710ab0baac51bdf88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70ad682703b8585f5d0a637efec044d57ec05efb","ecc11368dc265bfdad90214f8bf5da99016ab1e2","868da859b43505d9d2a023bfeae6dd0c795f5295"],"e7ee868f5038843b2550e6e996be578b90d65378":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["70ad682703b8585f5d0a637efec044d57ec05efb","d083e83f225b11e5fdd900e83d26ddb385b6955c","868da859b43505d9d2a023bfeae6dd0c795f5295","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}