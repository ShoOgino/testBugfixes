{"path":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85d41890f2bad879e6a04c6dd7d2cf276f973994","date":1338488367,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":["2eb9dcbcff763b925aeaf51efba4dabd996ec69a"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"85d41890f2bad879e6a04c6dd7d2cf276f973994":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["85d41890f2bad879e6a04c6dd7d2cf276f973994"]},"commit2Childs":{"85d41890f2bad879e6a04c6dd7d2cf276f973994":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}