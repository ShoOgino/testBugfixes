{"path":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","commits":[{"id":"c9727734a64d33a1345c9251f53eb375f04c583e","date":1158874656,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"/dev/null","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int limit = params.getFieldInt(field, params.FACET_LIMIT, 100);\n    boolean zeros = params.getFieldBool(field, params.FACET_ZEROS, true);\n    boolean missing = params.getFieldBool(field, params.FACET_MISSING, false);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher,docs,field,limit,zeros,missing);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, limit, zeros, missing);\n    }\n\n    return counts;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9691bd012f05632bf944115412ed90daae112f68","date":1168971974,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, params.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, params.FACET_LIMIT, 100);\n    Integer mincount = params.getFieldInt(field, params.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, params.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, params.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, params.FACET_SORT, limit>0);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int limit = params.getFieldInt(field, params.FACET_LIMIT, 100);\n    boolean zeros = params.getFieldBool(field, params.FACET_ZEROS, true);\n    boolean missing = params.getFieldBool(field, params.FACET_MISSING, false);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher,docs,field,limit,zeros,missing);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, limit, zeros, missing);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a902fceaa7c10b5669d1ed631319bd619378ca7","date":1169742721,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, params.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, params.FACET_LIMIT, 100);\n    Integer mincount = params.getFieldInt(field, params.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, params.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, params.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, params.FACET_SORT, limit>0);\n    String prefix = params.getFieldParam(field,params.FACET_PREFIX);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, params.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, params.FACET_LIMIT, 100);\n    Integer mincount = params.getFieldInt(field, params.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, params.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, params.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, params.FACET_SORT, limit>0);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef","date":1185993405,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, FacetParams.FACET_SORT, limit>0);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, params.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, params.FACET_LIMIT, 100);\n    Integer mincount = params.getFieldInt(field, params.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, params.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, params.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, params.FACET_SORT, limit>0);\n    String prefix = params.getFieldParam(field,params.FACET_PREFIX);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97d743708948b35ac3cb02ac68f2560cc98640be","date":1213294286,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, FacetParams.FACET_SORT, limit>0);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, FacetParams.FACET_SORT, limit>0);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a70797e2ad3b67325d3043155af4baf6445fdd9","date":1227585729,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, FacetParams.FACET_SORT, limit>0);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.isTokenized();\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, FacetParams.FACET_SORT, limit>0);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    if (sf.multiValued() || ft.isTokenized() || ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      // TODO: future logic could use filters instead of the fieldcache if\n      // the number of terms in the field is small enough.\n      counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":["5e62bfc99fea332bfdcdca0f73a821428d533279"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5a95ce1d7a3779af6db59b6b39d3b89172d7445","date":1228620032,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? \"count\" : \"lex\");\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.isTokenized();\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    boolean sort = params.getFieldBool(field, FacetParams.FACET_SORT, limit>0);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.isTokenized();\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cb179b2fab2183d2f6041e450ff8022c592ecf0","date":1229553695,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? \"count\" : \"lex\");\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.isTokenized();\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? \"count\" : \"lex\");\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.isTokenized();\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, docs, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1161f19bd84204b140d97fea16ff621e86ce7ab4","date":1235924971,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.isTokenized();\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? \"count\" : \"lex\");\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.isTokenized();\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e62bfc99fea332bfdcdca0f73a821428d533279","date":1254838400,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.isTokenized();\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":["9a70797e2ad3b67325d3043155af4baf6445fdd9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"97d743708948b35ac3cb02ac68f2560cc98640be":["c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["e5a95ce1d7a3779af6db59b6b39d3b89172d7445"],"9a70797e2ad3b67325d3043155af4baf6445fdd9":["97d743708948b35ac3cb02ac68f2560cc98640be"],"c9727734a64d33a1345c9251f53eb375f04c583e":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"e5a95ce1d7a3779af6db59b6b39d3b89172d7445":["9a70797e2ad3b67325d3043155af4baf6445fdd9"],"c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef":["5a902fceaa7c10b5669d1ed631319bd619378ca7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9691bd012f05632bf944115412ed90daae112f68":["c9727734a64d33a1345c9251f53eb375f04c583e"],"5e62bfc99fea332bfdcdca0f73a821428d533279":["1161f19bd84204b140d97fea16ff621e86ce7ab4"],"1161f19bd84204b140d97fea16ff621e86ce7ab4":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"ad94625fb8d088209f46650c8097196fec67f00c":["5e62bfc99fea332bfdcdca0f73a821428d533279"],"5a902fceaa7c10b5669d1ed631319bd619378ca7":["9691bd012f05632bf944115412ed90daae112f68"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"97d743708948b35ac3cb02ac68f2560cc98640be":["9a70797e2ad3b67325d3043155af4baf6445fdd9"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["c9727734a64d33a1345c9251f53eb375f04c583e"],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["1161f19bd84204b140d97fea16ff621e86ce7ab4"],"9a70797e2ad3b67325d3043155af4baf6445fdd9":["e5a95ce1d7a3779af6db59b6b39d3b89172d7445"],"c9727734a64d33a1345c9251f53eb375f04c583e":["9691bd012f05632bf944115412ed90daae112f68"],"e5a95ce1d7a3779af6db59b6b39d3b89172d7445":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef":["97d743708948b35ac3cb02ac68f2560cc98640be"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9691bd012f05632bf944115412ed90daae112f68":["5a902fceaa7c10b5669d1ed631319bd619378ca7"],"5e62bfc99fea332bfdcdca0f73a821428d533279":["ad94625fb8d088209f46650c8097196fec67f00c"],"1161f19bd84204b140d97fea16ff621e86ce7ab4":["5e62bfc99fea332bfdcdca0f73a821428d533279"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"5a902fceaa7c10b5669d1ed631319bd619378ca7":["c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}