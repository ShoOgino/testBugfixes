{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toLightAutomaton(int).mjava","commits":[{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toLightAutomaton(int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public LightAutomaton toLightAutomaton(int n) {\n    if (n == 0) {\n      return BasicAutomata.makeString(word, 0, word.length).toLightAutomaton();\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < numStates; i++) {\n      a.createState();\n      a.setAccept(i, description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(k, dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(k, dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finish();\n\n    return a;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f4ef381bf0c2d618c6db830d3dd668c6901c05a","date":1402592253,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toLightAutomaton(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toLightAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public LightAutomaton toLightAutomaton(int n) {\n    if (n == 0) {\n      return BasicAutomata.makeStringLight(word, 0, word.length);\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < numStates; i++) {\n      a.createState();\n      a.setAccept(i, description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(k, dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(k, dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finish();\n\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public LightAutomaton toLightAutomaton(int n) {\n    if (n == 0) {\n      return BasicAutomata.makeString(word, 0, word.length).toLightAutomaton();\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < numStates; i++) {\n      a.createState();\n      a.setAccept(i, description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(k, dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(k, dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finish();\n\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a67285d1a68175d877eb9fd1624fccad3db028ff","date":1402779028,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toLightAutomaton(int).mjava","sourceNew":"  public LightAutomaton toAutomaton(int n, String prefix) {\n    assert prefix != null;\n    if (n == 0) {\n      return BasicAutomata.makeStringLight(prefix + UnicodeUtil.newString(word, 0, word.length));\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n    int lastState;\n    if (prefix != null) {\n      // Insert prefix\n      lastState = a.createState();\n      for (int i = 0, cp = 0; i < prefix.length(); i += Character.charCount(cp)) {\n        int state = a.createState();\n        cp = prefix.codePointAt(i);\n        a.addTransition(lastState, state, cp, cp);\n        lastState = state;\n      }\n    } else {\n      lastState = a.createState();\n    }\n\n    // nocommit why are so many dead states created here?\n\n    int stateOffset = lastState;\n    a.setAccept(lastState, description.isAccept(0));\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 1; i < numStates; i++) {\n      int state = a.createState();\n      a.setAccept(state, description.isAccept(i));\n    }\n\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          // nocommit why do we create cycles in dead states?\n          if (k != dest) {\n            a.addTransition(stateOffset+k, stateOffset+dest, ch);\n          }\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          // nocommit why do we create cycles in dead states?\n          if (k != dest) {\n            a.addTransition(stateOffset+k, stateOffset+dest, rangeLower[r], rangeUpper[r]);\n          }\n        }\n      }\n    }\n\n    a.finish();\n    assert a.isDeterministic();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public LightAutomaton toLightAutomaton(int n) {\n    if (n == 0) {\n      return BasicAutomata.makeStringLight(word, 0, word.length);\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    int numStates = description.size();\n\n    LightAutomaton a = new LightAutomaton();\n\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < numStates; i++) {\n      a.createState();\n      a.setAccept(i, description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < numStates; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0) {\n          a.addTransition(k, dest, ch);\n        }\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0) {\n        for (int r = 0; r < numRanges; r++) {\n          a.addTransition(k, dest, rangeLower[r], rangeUpper[r]);\n        }\n      }\n    }\n\n    a.finish();\n\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a67285d1a68175d877eb9fd1624fccad3db028ff":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a67285d1a68175d877eb9fd1624fccad3db028ff":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ac34f0c5bb9274821fb0cb18075234e02002e9bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a67285d1a68175d877eb9fd1624fccad3db028ff","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}