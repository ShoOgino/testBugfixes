{"path":"solr/core/src/java/org/apache/solr/handler/component/StatsField[StatsComponent]#getFieldCacheStats(DocSet).mjava","commits":[{"id":"610c97b96420e614c67797fd43822ebc1d4b7ee2","date":1410814832,"type":1,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField[StatsComponent]#getFieldCacheStats(DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,boolean,String[]).mjava","sourceNew":"  private StatsValues getFieldCacheStats(DocSet base) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<>();\n    for( String facetField : facets ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = base.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats;\n  }\n\n","sourceOld":"  public NamedList<?> getFieldCacheStats(String fieldName, boolean calcDistinct, String[] facet) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final SchemaField sf = schema.getField(fieldName);\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<>();\n    for( String facetField : facet ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = base.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats.getStatsValues();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"283ff02f401ec3e7a2fad73643970f052383fb0c","date":1411407953,"type":5,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField#computeLocalValueSourceStats(DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField[StatsComponent]#getFieldCacheStats(DocSet).mjava","sourceNew":"  private StatsValues computeLocalValueSourceStats(DocSet base) throws IOException {\n\n    IndexSchema schema = searcher.getSchema();\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(this);\n\n    List<FieldFacetStats> facetStats = new ArrayList<>();\n    for( String facetField : facets ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, fsf, this));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = base.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats;\n  }\n\n","sourceOld":"  private StatsValues getFieldCacheStats(DocSet base) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<>();\n    for( String facetField : facets ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = base.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"283ff02f401ec3e7a2fad73643970f052383fb0c":["610c97b96420e614c67797fd43822ebc1d4b7ee2"],"610c97b96420e614c67797fd43822ebc1d4b7ee2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["283ff02f401ec3e7a2fad73643970f052383fb0c"]},"commit2Childs":{"283ff02f401ec3e7a2fad73643970f052383fb0c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"610c97b96420e614c67797fd43822ebc1d4b7ee2":["283ff02f401ec3e7a2fad73643970f052383fb0c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["610c97b96420e614c67797fd43822ebc1d4b7ee2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}