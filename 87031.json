{"path":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","commits":[{"id":"0ad9ec888e587ca9a3279368245cdf00aabdc108","date":1338832525,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","pathOld":"/dev/null","sourceNew":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8e65acce892eede973379cb2fb3b90ea49a4a5ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3df4431225cd26f95bfda0ddc15b497b506c886","date":1338839306,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","sourceNew":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, Integer> combinedTokenFrequency = new HashMap<Token, Integer>();\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n      if(result.getTokenFrequency()!=null) {\n        combinedTokenFrequency.putAll(result.getTokenFrequency());\n      }\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            if(tokenFrequency!=null) {\n              combinedResult.addFrequency(original, tokenFrequency);\n            }\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }\n    \n    \n    return combinedResult;\n  }\n\n","sourceOld":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b215968db57f22e351a70732d4bb05c8d7073f68","date":1338845616,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","sourceNew":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","sourceOld":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, Integer> combinedTokenFrequency = new HashMap<Token, Integer>();\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n      if(result.getTokenFrequency()!=null) {\n        combinedTokenFrequency.putAll(result.getTokenFrequency());\n      }\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            if(tokenFrequency!=null) {\n              combinedResult.addFrequency(original, tokenFrequency);\n            }\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }\n    \n    \n    return combinedResult;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56d78974d33c1244e0810e0dc8f1c6371faceac9","date":1338918242,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","sourceNew":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, Integer> combinedTokenFrequency = new HashMap<Token, Integer>();\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n    \tif(result.getTokenFrequency()!=null) {\n        combinedTokenFrequency.putAll(result.getTokenFrequency());\n      }\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            if(tokenFrequency!=null) {\n              combinedResult.addFrequency(original, tokenFrequency);\n            }\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","sourceOld":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","bugFix":null,"bugIntro":["8e65acce892eede973379cb2fb3b90ea49a4a5ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","sourceNew":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, Integer> combinedTokenFrequency = new HashMap<Token, Integer>();\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n      if(result.getTokenFrequency()!=null) {\n        combinedTokenFrequency.putAll(result.getTokenFrequency());\n      }\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            if(tokenFrequency!=null) {\n              combinedResult.addFrequency(original, tokenFrequency);\n            }\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","sourceOld":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, Integer> combinedTokenFrequency = new HashMap<Token, Integer>();\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n    \tif(result.getTokenFrequency()!=null) {\n        combinedTokenFrequency.putAll(result.getTokenFrequency());\n      }\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            if(tokenFrequency!=null) {\n              combinedResult.addFrequency(original, tokenFrequency);\n            }\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","sourceNew":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, Integer> combinedTokenFrequency = new HashMap<>();\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<>();\n    for(SpellingResult result : results) {\n      if(result.getTokenFrequency()!=null) {\n        combinedTokenFrequency.putAll(result.getTokenFrequency());\n      }\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            if(tokenFrequency!=null) {\n              combinedResult.addFrequency(original, tokenFrequency);\n            }\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","sourceOld":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, Integer> combinedTokenFrequency = new HashMap<Token, Integer>();\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<Token, List<LinkedHashMap<String, Integer>>>();\n    for(SpellingResult result : results) {\n      if(result.getTokenFrequency()!=null) {\n        combinedTokenFrequency.putAll(result.getTokenFrequency());\n      }\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<LinkedHashMap<String, Integer>>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<Iterator<Map.Entry<String,Integer>>>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            if(tokenFrequency!=null) {\n              combinedResult.addFrequency(original, tokenFrequency);\n            }\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8e65acce892eede973379cb2fb3b90ea49a4a5ed","date":1409839025,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/ConjunctionSolrSpellChecker#mergeCheckers(SpellingResult[],int).mjava","sourceNew":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, Integer> combinedTokenFrequency = new HashMap<>();\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<>();\n    for(SpellingResult result : results) {\n      if(result.getTokenFrequency()!=null) {\n        combinedTokenFrequency.putAll(result.getTokenFrequency());\n      }\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            combinedResult.addFrequency(original, tokenFrequency==null ? 0 : tokenFrequency);\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          if(numberAdded==0) {\n            combinedResult.add(original, Collections.<String>emptyList());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            combinedResult.addFrequency(original, tokenFrequency==null ? 0 : tokenFrequency);\n          }\n          break;\n        }        \n      }      \n    }    \n    return combinedResult;\n  }\n\n","sourceOld":"  //TODO: This just interleaves the results.  In the future, we might want to let users give each checker its\n  //      own weight and use that in combination to score & frequency to sort the results ?\n  private SpellingResult mergeCheckers(SpellingResult[] results, int numSug) {\n    Map<Token, Integer> combinedTokenFrequency = new HashMap<>();\n    Map<Token, List<LinkedHashMap<String, Integer>>> allSuggestions = new LinkedHashMap<>();\n    for(SpellingResult result : results) {\n      if(result.getTokenFrequency()!=null) {\n        combinedTokenFrequency.putAll(result.getTokenFrequency());\n      }\n      for(Map.Entry<Token, LinkedHashMap<String, Integer>> entry : result.getSuggestions().entrySet()) {\n        List<LinkedHashMap<String, Integer>> allForThisToken = allSuggestions.get(entry.getKey());\n        if(allForThisToken==null) {\n          allForThisToken = new ArrayList<>();\n          allSuggestions.put(entry.getKey(), allForThisToken);\n        }\n        allForThisToken.add(entry.getValue());\n      }\n    }    \n    SpellingResult combinedResult = new SpellingResult();    \n    for(Map.Entry<Token, List<LinkedHashMap<String, Integer>>> entry : allSuggestions.entrySet()) {\n      Token original = entry.getKey();      \n      List<Iterator<Map.Entry<String,Integer>>> corrIters = new ArrayList<>(entry.getValue().size());\n      for(LinkedHashMap<String, Integer> corrections : entry.getValue()) {\n        corrIters.add(corrections.entrySet().iterator());\n      }        \n      int numberAdded = 0;\n      while(numberAdded < numSug) {\n        boolean anyData = false;\n        for(Iterator<Map.Entry<String,Integer>> iter : corrIters) {\n          if(iter.hasNext()) {\n            anyData = true;\n            Map.Entry<String,Integer> corr = iter.next();\n            combinedResult.add(original, corr.getKey(), corr.getValue());\n            Integer tokenFrequency = combinedTokenFrequency.get(original);\n            if(tokenFrequency!=null) {\n              combinedResult.addFrequency(original, tokenFrequency);\n            }\n            if(++numberAdded==numSug) {\n              break;\n            }\n          }\n        }        \n        if(!anyData) {\n          break;\n        }\n      }      \n    }    \n    return combinedResult;\n  }\n\n","bugFix":["0ad9ec888e587ca9a3279368245cdf00aabdc108","56d78974d33c1244e0810e0dc8f1c6371faceac9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"56d78974d33c1244e0810e0dc8f1c6371faceac9":["b215968db57f22e351a70732d4bb05c8d7073f68"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8e65acce892eede973379cb2fb3b90ea49a4a5ed":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b215968db57f22e351a70732d4bb05c8d7073f68":["c3df4431225cd26f95bfda0ddc15b497b506c886"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c3df4431225cd26f95bfda0ddc15b497b506c886":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8e65acce892eede973379cb2fb3b90ea49a4a5ed"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["56d78974d33c1244e0810e0dc8f1c6371faceac9"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["8e65acce892eede973379cb2fb3b90ea49a4a5ed"],"56d78974d33c1244e0810e0dc8f1c6371faceac9":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["c3df4431225cd26f95bfda0ddc15b497b506c886"],"8e65acce892eede973379cb2fb3b90ea49a4a5ed":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b215968db57f22e351a70732d4bb05c8d7073f68":["56d78974d33c1244e0810e0dc8f1c6371faceac9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"c3df4431225cd26f95bfda0ddc15b497b506c886":["b215968db57f22e351a70732d4bb05c8d7073f68"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}