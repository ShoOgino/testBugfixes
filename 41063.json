{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput,DataOutput).mjava","commits":[{"id":"99f06f5dd087b1829e7b4139e4d014c786b92572","date":1592312728,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput,DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput metaOut, DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(metaOut, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      metaOut.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n      int emptyLen = emptyOutputBytes.length;\n\n      // reverse\n      final int stopAt = emptyLen / 2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyLen - upto - 1];\n        emptyOutputBytes[emptyLen - upto - 1] = b;\n        upto++;\n      }\n      metaOut.writeVInt(emptyLen);\n      metaOut.writeBytes(emptyOutputBytes, 0, emptyLen);\n    } else {\n      metaOut.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    metaOut.writeByte(t);\n    metaOut.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      metaOut.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert fstStore != null;\n      fstStore.writeTo(out);\n    }\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n      int emptyLen = emptyOutputBytes.length;\n\n      // reverse\n      final int stopAt = emptyLen / 2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyLen - upto - 1];\n        emptyOutputBytes[emptyLen - upto - 1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyLen);\n      out.writeBytes(emptyOutputBytes, 0, emptyLen);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert fstStore != null;\n      fstStore.writeTo(out);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"99f06f5dd087b1829e7b4139e4d014c786b92572":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99f06f5dd087b1829e7b4139e4d014c786b92572"]},"commit2Childs":{"99f06f5dd087b1829e7b4139e4d014c786b92572":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["99f06f5dd087b1829e7b4139e4d014c786b92572"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}