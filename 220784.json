{"path":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this.r = r;\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some what to make that random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 37; \n    docValuesFieldPrefix = r.nextLong();\n    switchDoDocValues();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this.r = r;\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some what to make that random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 37; \n    docValuesFieldPrefix = r.nextLong();\n    switchDoDocValues();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89f25dae8ada65524f6808224b9f4f8202cf2c8c","date":1332501580,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this.r = r;\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some what to make that random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 17; \n    docValuesFieldPrefix = r.nextLong();\n    switchDoDocValues();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this.r = r;\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some what to make that random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 37; \n    docValuesFieldPrefix = r.nextLong();\n    switchDoDocValues();\n  } \n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"732de6718534f7b42fc956f4929b953ef4b1610f","date":1332871688,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this.r = r;\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some way to make this random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 17; \n\n    // NOTE: this means up to 13 * 5 unique fields (we have\n    // 13 different DV types):\n    docValuesFieldPrefix = r.nextInt(5);\n    switchDoDocValues();\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this.r = r;\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some what to make that random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 17; \n    docValuesFieldPrefix = r.nextLong();\n    switchDoDocValues();\n  } \n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some way to make this random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 17; \n\n    // NOTE: this means up to 13 * 5 unique fields (we have\n    // 13 different DV types):\n    docValuesFieldPrefix = r.nextInt(5);\n    switchDoDocValues();\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this.r = r;\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some way to make this random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 17; \n\n    // NOTE: this means up to 13 * 5 unique fields (we have\n    // 13 different DV types):\n    docValuesFieldPrefix = r.nextInt(5);\n    switchDoDocValues();\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3aef104b331c63aa3334f5dd93101bd91e128629","date":1348072129,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some way to make this random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 17; \n\n    // NOTE: this means up to 13 * 5 unique fields (we have\n    // 13 different DV types):\n    docValuesFieldPrefix = r.nextInt(5);\n    switchDoDocValues();\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some way to make this random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 17; \n\n    // NOTE: this means up to 13 * 5 unique fields (we have\n    // 13 different DV types):\n    docValuesFieldPrefix = r.nextInt(5);\n    switchDoDocValues();\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"003dc2cb64b06ce8caea28156505feb3c5059ba2","date":1359688932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some way to make this random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 17; \n\n    // NOTE: this means up to 13 * 5 unique fields (we have\n    // 13 different DV types):\n    docValuesFieldPrefix = r.nextInt(5);\n    switchDoDocValues();\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n    /* TODO: find some way to make this random...\n     * This must be fixed across all fixed bytes \n     * fields in one index. so if you open another writer\n     * this might change if I use r.nextInt(x)\n     * maybe we can peek at the existing files here? \n     */\n    fixedBytesLength = 17; \n\n    // NOTE: this means up to 13 * 5 unique fields (we have\n    // 13 different DV types):\n    docValuesFieldPrefix = r.nextInt(5);\n    switchDoDocValues();\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","bugFix":["732de6718534f7b42fc956f4929b953ef4b1610f","7b91922b55d15444d554721b352861d028eb8278","89f25dae8ada65524f6808224b9f4f8202cf2c8c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3166e9a56606e903a9c5f8dda276557bef1f004d","date":1367188094,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = !(c.getMergePolicy() instanceof NoMergePolicy) && r.nextBoolean();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = r.nextBoolean();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"978de4e2d23054c6624dd5928ddeb734dca68eec","date":1370592803,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = mockIndexWriter(dir, c, r);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = !(c.getMergePolicy() instanceof NoMergePolicy) && r.nextBoolean();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = new MockIndexWriter(r, dir, c);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = !(c.getMergePolicy() instanceof NoMergePolicy) && r.nextBoolean();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = mockIndexWriter(dir, c, r);\n    flushAt = TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = !(c.getMergePolicy() instanceof NoMergePolicy) && r.nextBoolean();\n  } \n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = mockIndexWriter(dir, c, r);\n    flushAt = _TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = !(c.getMergePolicy() instanceof NoMergePolicy) && r.nextBoolean();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56958d7f71a28824f20031ffbb2e13502a0274e","date":1425573902,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this(r, dir, c, false);\n  }\n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = mockIndexWriter(dir, c, r);\n    flushAt = TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = !(c.getMergePolicy() instanceof NoMergePolicy) && r.nextBoolean();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this(r, dir, c, false);\n  }\n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    // TODO: this should be solved in a different way; Random should not be shared (!).\n    this.r = new Random(r.nextLong());\n    w = mockIndexWriter(dir, c, r);\n    flushAt = TestUtil.nextInt(r, 10, 1000);\n    codec = w.getConfig().getCodec();\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"RIW dir=\" + dir + \" config=\" + w.getConfig());\n      System.out.println(\"codec default=\" + codec.getName());\n    }\n\n    // Make sure we sometimes test indices that don't get\n    // any forced merges:\n    doRandomForceMerge = !(c.getMergePolicy() instanceof NoMergePolicy) && r.nextBoolean();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ee0394b8176abd7c90a4be8c05465be1879db79","date":1522842314,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#RandomIndexWriter(Random,Directory,IndexWriterConfig).mjava","sourceNew":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this(r, dir, c, false, r.nextBoolean());\n  }\n\n","sourceOld":"  /** create a RandomIndexWriter with the provided config */\n  public RandomIndexWriter(Random r, Directory dir, IndexWriterConfig c) throws IOException {\n    this(r, dir, c, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"978de4e2d23054c6624dd5928ddeb734dca68eec":["3166e9a56606e903a9c5f8dda276557bef1f004d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["978de4e2d23054c6624dd5928ddeb734dca68eec"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["a56958d7f71a28824f20031ffbb2e13502a0274e"],"3166e9a56606e903a9c5f8dda276557bef1f004d":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"3aef104b331c63aa3334f5dd93101bd91e128629":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6613659748fe4411a7dcf85266e55db1f95f7315","a56958d7f71a28824f20031ffbb2e13502a0274e"],"732de6718534f7b42fc956f4929b953ef4b1610f":["89f25dae8ada65524f6808224b9f4f8202cf2c8c"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3aef104b331c63aa3334f5dd93101bd91e128629","003dc2cb64b06ce8caea28156505feb3c5059ba2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"003dc2cb64b06ce8caea28156505feb3c5059ba2":["3aef104b331c63aa3334f5dd93101bd91e128629"],"89f25dae8ada65524f6808224b9f4f8202cf2c8c":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["732de6718534f7b42fc956f4929b953ef4b1610f"],"a56958d7f71a28824f20031ffbb2e13502a0274e":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ee0394b8176abd7c90a4be8c05465be1879db79"]},"commit2Childs":{"978de4e2d23054c6624dd5928ddeb734dca68eec":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","a56958d7f71a28824f20031ffbb2e13502a0274e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["89f25dae8ada65524f6808224b9f4f8202cf2c8c"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3166e9a56606e903a9c5f8dda276557bef1f004d":["978de4e2d23054c6624dd5928ddeb734dca68eec"],"3aef104b331c63aa3334f5dd93101bd91e128629":["d4d69c535930b5cce125cff868d40f6373dc27d4","003dc2cb64b06ce8caea28156505feb3c5059ba2"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"732de6718534f7b42fc956f4929b953ef4b1610f":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3166e9a56606e903a9c5f8dda276557bef1f004d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"003dc2cb64b06ce8caea28156505feb3c5059ba2":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"89f25dae8ada65524f6808224b9f4f8202cf2c8c":["732de6718534f7b42fc956f4929b953ef4b1610f"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3aef104b331c63aa3334f5dd93101bd91e128629"],"a56958d7f71a28824f20031ffbb2e13502a0274e":["5ee0394b8176abd7c90a4be8c05465be1879db79","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}