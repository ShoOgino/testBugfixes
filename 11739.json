{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","commits":[{"id":"cf09c02272f823c216c96545af03876602d27996","date":1337363554,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"/dev/null","sourceNew":"  private boolean checkConsistency() {\n    // nocommit more checks here\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      assert omitNorms || normsType != null;\n      assert indexOptions != null;\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["83ede60c0b5bb96ad193414bbd663193b56689b3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  private boolean checkConsistency() {\n    // nocommit more checks here\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      // nocommit this trips:\n      //assert omitNorms || normType != null;\n      assert indexOptions != null;\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","sourceOld":"  private boolean checkConsistency() {\n    // nocommit more checks here\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      assert omitNorms || normsType != null;\n      assert indexOptions != null;\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b512a6470fbb93c320e0cc8519ec0fe94efa13e","date":1337522360,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  private boolean checkConsistency() {\n    // nocommit more checks here\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      // nocommit trips:\n      //assert omitNorms || normType != null;\n      assert indexOptions != null;\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","sourceOld":"  private boolean checkConsistency() {\n    // nocommit more checks here\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      // nocommit this trips:\n      //assert omitNorms || normType != null;\n      assert indexOptions != null;\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6713daf1eafe75390c61687aa084777ad46bea09","date":1337692531,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  private boolean checkConsistency() {\n    // nocommit more checks here\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      assert indexOptions != null;\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","sourceOld":"  private boolean checkConsistency() {\n    // nocommit more checks here\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      // nocommit trips:\n      //assert omitNorms || normType != null;\n      assert indexOptions != null;\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19e1fda71fec5a2a0d0fd11eccb5b7cd50cfd059","date":1337694380,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","sourceOld":"  private boolean checkConsistency() {\n    // nocommit more checks here\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      assert indexOptions != null;\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"/dev/null","sourceNew":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83ede60c0b5bb96ad193414bbd663193b56689b3","date":1338331478,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == null;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n      // Cannot store payloads unless positions are indexed:\n      assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n    }\n\n    // Cannot store payloads unless positions are indexed:\n    assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n\n    return true;\n  }\n\n","bugFix":["cf09c02272f823c216c96545af03876602d27996"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71","date":1400675008,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == null;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n      // Cannot store payloads unless positions are indexed:\n      assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n    }\n    \n    if (dvGen != -1) {\n      assert docValueType != null;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == null;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n      // Cannot store payloads unless positions are indexed:\n      assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a656b32c3aa151037a8c52e9b134acc3cbf482bc","date":1400688195,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == null;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n      // Cannot store payloads unless positions are indexed:\n      assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n    }\n    \n    if (dvGen != -1) {\n      assert docValueType != null;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == null;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n      // Cannot store payloads unless positions are indexed:\n      assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == null;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n      // Cannot store payloads unless positions are indexed:\n      assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n    }\n    \n    if (dvGen != -1) {\n      assert docValueType != null;\n    }\n\n    return true;\n  }\n\n","sourceOld":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == null;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n      // Cannot store payloads unless positions are indexed:\n      assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"500867f0f15393f6b2c38c3366e414fccba04ed6","date":1411520390,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexed) {\n      if (indexOptions == null) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' must have index options\");\n      }\n      if (omitNorms) {\n        if (normType != null) {\n          throw new IllegalStateException(\"indexed field '\" + name + \"' cannot both omit norms and have norms\");\n        }\n      }\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (normType != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  private boolean checkConsistency() {\n    if (!indexed) {\n      assert !storeTermVector;\n      assert !storePayloads;\n      assert !omitNorms;\n      assert normType == null;\n      assert indexOptions == null;\n    } else {\n      assert indexOptions != null;\n      if (omitNorms) {\n        assert normType == null;\n      }\n      // Cannot store payloads unless positions are indexed:\n      assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !this.storePayloads;\n    }\n    \n    if (dvGen != -1) {\n      assert docValueType != null;\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05da2d758a6089e737cdfc230e57a51b472b94b6","date":1413392310,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexed) {\n      if (indexOptions == null) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' must have index options\");\n      }\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexed) {\n      if (indexOptions == null) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' must have index options\");\n      }\n      if (omitNorms) {\n        if (normType != null) {\n          throw new IllegalStateException(\"indexed field '\" + name + \"' cannot both omit norms and have norms\");\n        }\n      }\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (normType != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexed) {\n      if (indexOptions == null) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' must have index options\");\n      }\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexed) {\n      if (indexOptions == null) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' must have index options\");\n      }\n      if (omitNorms) {\n        if (normType != null) {\n          throw new IllegalStateException(\"indexed field '\" + name + \"' cannot both omit norms and have norms\");\n        }\n      }\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (normType != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3184874f7f3aca850248483485b4995343066875","date":1413876758,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != null) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexed) {\n      if (indexOptions == null) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' must have index options\");\n      }\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != null) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexed) {\n      if (indexOptions == null) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' must have index options\");\n      }\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc60eec6f7ea38d8eb48525cdf39ede2331c85cb","date":1414427572,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != null) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != null) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n      if (indexOptions != null) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot have index options\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bb2842e561df4e8e9ad89010605fc86ac265465","date":1414768208,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NO) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != null) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1edd0fe3b3915bf01160dfd544ab0c18cb77e45","date":1414773150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NO) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NO) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NO) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n    \n    if (dvGen != -1 && docValueType == null) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95ce1375367b92d411a06175eab3915fe93c6bc","date":1414788502,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NONE) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NO) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NO) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NONE) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n\n    if (dimensionCount < 0) {\n      throw new IllegalStateException(\"dimensionCount must be >= 0; got \" + dimensionCount);\n    }\n\n    if (dimensionNumBytes < 0) {\n      throw new IllegalStateException(\"dimensionNumBytes must be >= 0; got \" + dimensionNumBytes);\n    }\n\n    if (dimensionCount != 0 && dimensionNumBytes == 0) {\n      throw new IllegalStateException(\"dimensionNumBytes must be > 0 when dimensionCount=\" + dimensionCount);\n    }\n\n    if (dimensionNumBytes != 0 && dimensionCount == 0) {\n      throw new IllegalStateException(\"dimensionCount must be > 0 when dimensionNumBytes=\" + dimensionNumBytes);\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NONE) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NONE) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n\n    if (pointDimensionCount < 0) {\n      throw new IllegalStateException(\"pointDimensionCount must be >= 0; got \" + pointDimensionCount);\n    }\n\n    if (pointNumBytes < 0) {\n      throw new IllegalStateException(\"pointNumBytes must be >= 0; got \" + pointNumBytes);\n    }\n\n    if (pointDimensionCount != 0 && pointNumBytes == 0) {\n      throw new IllegalStateException(\"pointNumBytes must be > 0 when pointDimensionCount=\" + pointDimensionCount);\n    }\n\n    if (pointNumBytes != 0 && pointDimensionCount == 0) {\n      throw new IllegalStateException(\"pointDimensionCount must be > 0 when pointNumBytes=\" + pointNumBytes);\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NONE) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n\n    if (dimensionCount < 0) {\n      throw new IllegalStateException(\"dimensionCount must be >= 0; got \" + dimensionCount);\n    }\n\n    if (dimensionNumBytes < 0) {\n      throw new IllegalStateException(\"dimensionNumBytes must be >= 0; got \" + dimensionNumBytes);\n    }\n\n    if (dimensionCount != 0 && dimensionNumBytes == 0) {\n      throw new IllegalStateException(\"dimensionNumBytes must be > 0 when dimensionCount=\" + dimensionCount);\n    }\n\n    if (dimensionNumBytes != 0 && dimensionCount == 0) {\n      throw new IllegalStateException(\"dimensionCount must be > 0 when dimensionNumBytes=\" + dimensionNumBytes);\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NONE) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n\n    if (pointDataDimensionCount < 0) {\n      throw new IllegalStateException(\"pointDataDimensionCount must be >= 0; got \" + pointDataDimensionCount);\n    }\n\n    if (pointIndexDimensionCount < 0) {\n      throw new IllegalStateException(\"pointIndexDimensionCount must be >= 0; got \" + pointIndexDimensionCount);\n    }\n\n    if (pointNumBytes < 0) {\n      throw new IllegalStateException(\"pointNumBytes must be >= 0; got \" + pointNumBytes);\n    }\n\n    if (pointDataDimensionCount != 0 && pointNumBytes == 0) {\n      throw new IllegalStateException(\"pointNumBytes must be > 0 when pointDataDimensionCount=\" + pointDataDimensionCount);\n    }\n\n    if (pointIndexDimensionCount != 0 && pointDataDimensionCount == 0) {\n      throw new IllegalStateException(\"pointIndexDimensionCount must be 0 when pointDataDimensionCount=0\");\n    }\n\n    if (pointNumBytes != 0 && pointDataDimensionCount == 0) {\n      throw new IllegalStateException(\"pointDataDimensionCount must be > 0 when pointNumBytes=\" + pointNumBytes);\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NONE) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n\n    if (pointDimensionCount < 0) {\n      throw new IllegalStateException(\"pointDimensionCount must be >= 0; got \" + pointDimensionCount);\n    }\n\n    if (pointNumBytes < 0) {\n      throw new IllegalStateException(\"pointNumBytes must be >= 0; got \" + pointNumBytes);\n    }\n\n    if (pointDimensionCount != 0 && pointNumBytes == 0) {\n      throw new IllegalStateException(\"pointNumBytes must be > 0 when pointDimensionCount=\" + pointDimensionCount);\n    }\n\n    if (pointNumBytes != 0 && pointDimensionCount == 0) {\n      throw new IllegalStateException(\"pointDimensionCount must be > 0 when pointNumBytes=\" + pointNumBytes);\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#checkConsistency().mjava","sourceNew":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NONE) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n\n    if (pointDimensionCount < 0) {\n      throw new IllegalStateException(\"pointDimensionCount must be >= 0; got \" + pointDimensionCount);\n    }\n\n    if (pointIndexDimensionCount < 0) {\n      throw new IllegalStateException(\"pointIndexDimensionCount must be >= 0; got \" + pointIndexDimensionCount);\n    }\n\n    if (pointNumBytes < 0) {\n      throw new IllegalStateException(\"pointNumBytes must be >= 0; got \" + pointNumBytes);\n    }\n\n    if (pointDimensionCount != 0 && pointNumBytes == 0) {\n      throw new IllegalStateException(\"pointNumBytes must be > 0 when pointDimensionCount=\" + pointDimensionCount);\n    }\n\n    if (pointIndexDimensionCount != 0 && pointDimensionCount == 0) {\n      throw new IllegalStateException(\"pointIndexDimensionCount must be 0 when pointDimensionCount=0\");\n    }\n\n    if (pointNumBytes != 0 && pointDimensionCount == 0) {\n      throw new IllegalStateException(\"pointDimensionCount must be > 0 when pointNumBytes=\" + pointNumBytes);\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** \n   * Performs internal consistency checks.\n   * Always returns true (or throws IllegalStateException) \n   */\n  public boolean checkConsistency() {\n    if (indexOptions != IndexOptions.NONE) {\n      // Cannot store payloads unless positions are indexed:\n      if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {\n        throw new IllegalStateException(\"indexed field '\" + name + \"' cannot have payloads without positions\");\n      }\n    } else {\n      if (storeTermVector) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store term vectors\");\n      }\n      if (storePayloads) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot store payloads\");\n      }\n      if (omitNorms) {\n        throw new IllegalStateException(\"non-indexed field '\" + name + \"' cannot omit norms\");\n      }\n    }\n\n    if (pointDataDimensionCount < 0) {\n      throw new IllegalStateException(\"pointDataDimensionCount must be >= 0; got \" + pointDataDimensionCount);\n    }\n\n    if (pointIndexDimensionCount < 0) {\n      throw new IllegalStateException(\"pointIndexDimensionCount must be >= 0; got \" + pointIndexDimensionCount);\n    }\n\n    if (pointNumBytes < 0) {\n      throw new IllegalStateException(\"pointNumBytes must be >= 0; got \" + pointNumBytes);\n    }\n\n    if (pointDataDimensionCount != 0 && pointNumBytes == 0) {\n      throw new IllegalStateException(\"pointNumBytes must be > 0 when pointDataDimensionCount=\" + pointDataDimensionCount);\n    }\n\n    if (pointIndexDimensionCount != 0 && pointDataDimensionCount == 0) {\n      throw new IllegalStateException(\"pointIndexDimensionCount must be 0 when pointDataDimensionCount=0\");\n    }\n\n    if (pointNumBytes != 0 && pointDataDimensionCount == 0) {\n      throw new IllegalStateException(\"pointDataDimensionCount must be > 0 when pointNumBytes=\" + pointNumBytes);\n    }\n    \n    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {\n      throw new IllegalStateException(\"field '\" + name + \"' cannot have a docvalues update generation without having docvalues\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cc60eec6f7ea38d8eb48525cdf39ede2331c85cb":["3184874f7f3aca850248483485b4995343066875"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["f6652c943595e92c187ee904c382863013eae28f"],"f6652c943595e92c187ee904c382863013eae28f":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["cc60eec6f7ea38d8eb48525cdf39ede2331c85cb"],"b7605579001505896d48b07160075a5c8b8e128e":["83ede60c0b5bb96ad193414bbd663193b56689b3","ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71"],"d1edd0fe3b3915bf01160dfd544ab0c18cb77e45":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"cf09c02272f823c216c96545af03876602d27996":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6713daf1eafe75390c61687aa084777ad46bea09":["4b512a6470fbb93c320e0cc8519ec0fe94efa13e"],"4356000e349e38c9fb48034695b7c309abd54557":["cf09c02272f823c216c96545af03876602d27996"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"05da2d758a6089e737cdfc230e57a51b472b94b6":["500867f0f15393f6b2c38c3366e414fccba04ed6"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["500867f0f15393f6b2c38c3366e414fccba04ed6","05da2d758a6089e737cdfc230e57a51b472b94b6"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"83ede60c0b5bb96ad193414bbd663193b56689b3":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"500867f0f15393f6b2c38c3366e414fccba04ed6":["ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71"],"f95ce1375367b92d411a06175eab3915fe93c6bc":["d1edd0fe3b3915bf01160dfd544ab0c18cb77e45"],"3184874f7f3aca850248483485b4995343066875":["05da2d758a6089e737cdfc230e57a51b472b94b6"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","19e1fda71fec5a2a0d0fd11eccb5b7cd50cfd059"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3184874f7f3aca850248483485b4995343066875"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["f95ce1375367b92d411a06175eab3915fe93c6bc"],"19e1fda71fec5a2a0d0fd11eccb5b7cd50cfd059":["6713daf1eafe75390c61687aa084777ad46bea09"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":["83ede60c0b5bb96ad193414bbd663193b56689b3","ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71"],"ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71":["83ede60c0b5bb96ad193414bbd663193b56689b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"4b512a6470fbb93c320e0cc8519ec0fe94efa13e":["4356000e349e38c9fb48034695b7c309abd54557"]},"commit2Childs":{"cc60eec6f7ea38d8eb48525cdf39ede2331c85cb":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["d1edd0fe3b3915bf01160dfd544ab0c18cb77e45"],"b7605579001505896d48b07160075a5c8b8e128e":[],"d1edd0fe3b3915bf01160dfd544ab0c18cb77e45":["f95ce1375367b92d411a06175eab3915fe93c6bc"],"cf09c02272f823c216c96545af03876602d27996":["4356000e349e38c9fb48034695b7c309abd54557"],"6713daf1eafe75390c61687aa084777ad46bea09":["19e1fda71fec5a2a0d0fd11eccb5b7cd50cfd059"],"4356000e349e38c9fb48034695b7c309abd54557":["4b512a6470fbb93c320e0cc8519ec0fe94efa13e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cf09c02272f823c216c96545af03876602d27996","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"05da2d758a6089e737cdfc230e57a51b472b94b6":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3184874f7f3aca850248483485b4995343066875"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["f6652c943595e92c187ee904c382863013eae28f"],"83ede60c0b5bb96ad193414bbd663193b56689b3":["b7605579001505896d48b07160075a5c8b8e128e","a656b32c3aa151037a8c52e9b134acc3cbf482bc","ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71"],"500867f0f15393f6b2c38c3366e414fccba04ed6":["05da2d758a6089e737cdfc230e57a51b472b94b6","c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84"],"3184874f7f3aca850248483485b4995343066875":["cc60eec6f7ea38d8eb48525cdf39ede2331c85cb","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"f95ce1375367b92d411a06175eab3915fe93c6bc":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["83ede60c0b5bb96ad193414bbd663193b56689b3"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"19e1fda71fec5a2a0d0fd11eccb5b7cd50cfd059":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":[],"ca02c6cbb1ba28fd0bd36bd0f8a2ac84be5f0e71":["b7605579001505896d48b07160075a5c8b8e128e","500867f0f15393f6b2c38c3366e414fccba04ed6","a656b32c3aa151037a8c52e9b134acc3cbf482bc"],"4b512a6470fbb93c320e0cc8519ec0fe94efa13e":["6713daf1eafe75390c61687aa084777ad46bea09"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","0a22eafe3f72a4c2945eaad9547e6c78816978f4","a656b32c3aa151037a8c52e9b134acc3cbf482bc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}