{"path":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","commits":[{"id":"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0","date":1367858986,"type":1,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int,int,boolean).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);\n            if (reportHits) {\n              f = checkResponse.getFieldFlags();\n              checkResponse.setFieldFlags(f |= SolrIndexSearcher.FORCE_INORDER_COLLECTION);\n            }\n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          if (etce.getLastDocId() + 1 == maxDocId) {\n            hits = docCollectionLimit;\n          } else {\n            hits = maxDocId / ((etce.getLastDocId() + 1) / docCollectionLimit);\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries, int maxEvaluations, boolean suggestionsMayOverlap) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), maxNumberToIterate, maxEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.<SearchComponent>asList(queryComponent));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d93bd328514720a5d9f50266ea72059833876b71","date":1367860677,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          if (etce.getLastDocId() + 1 == maxDocId) {\n            hits = docCollectionLimit;\n          } else {\n            hits = maxDocId / ((etce.getLastDocId() + 1) / docCollectionLimit);\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);\n            if (reportHits) {\n              f = checkResponse.getFieldFlags();\n              checkResponse.setFieldFlags(f |= SolrIndexSearcher.FORCE_INORDER_COLLECTION);\n            }\n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          if (etce.getLastDocId() + 1 == maxDocId) {\n            hits = docCollectionLimit;\n          } else {\n            hits = maxDocId / ((etce.getLastDocId() + 1) / docCollectionLimit);\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c66792f6f4d853bde4d423587fb81b0940945369","date":1376589030,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          if (etce.getLastDocId() + 1 == maxDocId) {\n            hits = docCollectionLimit;\n          } else {\n            hits = maxDocId / ((etce.getLastDocId() + 1) / docCollectionLimit);\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          if (etce.getLastDocId() + 1 == maxDocId) {\n            hits = docCollectionLimit;\n          } else {\n            hits = maxDocId / ((etce.getLastDocId() + 1) / docCollectionLimit);\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c15914b0d98e563f81d03ee023dc82f58171369d","date":1464292003,"type":3,"author":"jdyer1","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da8a02bef7458089240404614139b53c9f875ec7","date":1464597207,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8ee93140fd0efef7e101786e3ed5160a700b5f","date":1464820111,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, \"id\");\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ca8125609b7262844370761a4c1f26137c9f3a6b","date":1491831581,"type":3,"author":"jdyer1","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":["2ef113fb050c2f71e3075c84198045b09385eda3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","date":1498031702,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":["c66792f6f4d853bde4d423587fb81b0940945369","01dce43e4bc4beefad6c846395bc4bd7aecd89be"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (int) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      log.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (log.isDebugEnabled()) {\n        log.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ef113fb050c2f71e3075c84198045b09385eda3","date":1584508910,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      log.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.asList(queryComponent));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (log.isDebugEnabled()) {\n        log.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      log.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n        String[] filters = params.getParams(CommonParams.FQ);\n        if (filters != null) {\n          List<String> filtersToApply = new ArrayList<>(filters.length);\n          for (String fq : filters) {\n            if (!fq.startsWith(\"{!collapse\")) {\n              filtersToApply.add(fq);\n            }\n          }\n          params.set(\"fq\", filtersToApply.toArray(new String[filtersToApply.size()]));\n        }      \n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.<SearchComponent> asList(queryComponent)); \n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.<SearchComponent>asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (log.isDebugEnabled()) {\n        log.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0","ca8125609b7262844370761a4c1f26137c9f3a6b","fae06511695f4be0bce5337deb3b3f813d0c3e7c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      log.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.asList(queryComponent));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (log.isDebugEnabled()) {\n        log.debug(\"Collation: {} {}\", collationQueryStr, (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\")); // LOGOK\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      log.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.asList(queryComponent));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (log.isDebugEnabled()) {\n        log.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      log.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.asList(queryComponent));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (log.isDebugEnabled()) {\n        log.debug(\"Collation: {} {}\", collationQueryStr, (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\")); // logOk\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      log.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.asList(queryComponent));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (log.isDebugEnabled()) {\n        log.debug(\"Collation: {} {}\", collationQueryStr, (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\")); // LOGOK\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d19164145b2a65acf62a657c75f4a249b649c0","date":1601732857,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      log.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.asList(queryComponent));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (log.isDebugEnabled()) {\n        log.debug(\"Collation: {} {}\", collationQueryStr, (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\")); // nowarn\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result,\n      String originalQuery, ResponseBuilder ultimateResponse) {\n  List<SpellCheckCollation> collations = new ArrayList<>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    int maxTries = maxCollationTries;\n    int maxNumberToIterate = maxTries;\n    if (maxTries < 1) {\n      maxTries = 1;\n      maxNumberToIterate = maxCollations;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      log.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    docCollectionLimit = docCollectionLimit > 0 ? docCollectionLimit : 0;\n    int maxDocId = -1;\n    if (verifyCandidateWithQuery && docCollectionLimit > 0) {\n      IndexReader reader = ultimateResponse.req.getSearcher().getIndexReader();\n      maxDocId = reader.maxDoc();\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), \n        maxNumberToIterate, maxCollationEvaluations, suggestionsMayOverlap);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      PossibilityIterator.RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.corrections);\n      long hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n        SolrParams origParams = ultimateResponse.req.getParams();\n        ModifiableSolrParams params = new ModifiableSolrParams(origParams);  \n        Iterator<String> origParamIterator = origParams.getParameterNamesIterator();\n        int pl = SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE.length();\n        while (origParamIterator.hasNext()) {\n          String origParamName = origParamIterator.next();\n          if (origParamName\n              .startsWith(SpellingParams.SPELLCHECK_COLLATE_PARAM_OVERRIDE)\n              && origParamName.length() > pl) {\n            String[] val = origParams.getParams(origParamName);\n            if (val.length == 1 && val[0].length() == 0) {\n              params.set(origParamName.substring(pl), (String[]) null);\n            } else {\n              params.set(origParamName.substring(pl), val);\n            }\n          }\n        }\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.ROWS, \"\" + docCollectionLimit);\n        // we don't want any stored fields\n        params.set(CommonParams.FL, ID);\n        // we'll sort by doc id to ensure no scoring is done.\n        params.set(CommonParams.SORT, \"_docid_ asc\");\n        // CursorMark does not like _docid_ sorting, and we don't need it.\n        params.remove(CursorMarkParams.CURSOR_MARK_PARAM);\n        // If a dismax query, don't add unnecessary clauses for scoring\n        params.remove(DisMaxParams.TIE);\n        params.remove(DisMaxParams.PF);\n        params.remove(DisMaxParams.PF2);\n        params.remove(DisMaxParams.PF3);\n        params.remove(DisMaxParams.BQ);\n        params.remove(DisMaxParams.BF);\n        // Collate testing does not support Grouping (see SOLR-2577)\n        params.remove(GroupParams.GROUP);\n        \n        // Collate testing does not support the Collapse QParser (See SOLR-8807)\n        params.remove(\"expand\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(\n            new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),\n            new SolrQueryResponse(), Arrays.asList(queryComponent));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(queryComponent);\n\n        try {\n          queryComponent.prepare(checkResponse);\n          if (docCollectionLimit > 0) {\n            int f = checkResponse.getFieldFlags();\n            checkResponse.setFieldFlags(f |= SolrIndexSearcher.TERMINATE_EARLY);            \n          }\n          queryComponent.process(checkResponse);\n          hits = ((Number) checkResponse.rsp.getToLog().get(\"hits\")).longValue();\n        } catch (EarlyTerminatingCollectorException etce) {\n          assert (docCollectionLimit > 0);\n          assert 0 < etce.getNumberScanned();\n          assert 0 < etce.getNumberCollected();\n\n          if (etce.getNumberScanned() == maxDocId) {\n            hits = etce.getNumberCollected();\n          } else {\n            hits = (long) ( ((float)( maxDocId * etce.getNumberCollected() )) \n                           / (float)etce.getNumberScanned() );\n          }\n        } catch (Exception e) {\n          log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(suggestionsMayOverlap ? ((possibility.rank * 1000) + possibility.index) : possibility.rank);\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<>();\n        for (SpellCheckCorrection corr : possibility.corrections) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (log.isDebugEnabled()) {\n        log.debug(\"Collation: {} {}\", collationQueryStr, (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\")); // logOk\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d93bd328514720a5d9f50266ea72059833876b71":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c66792f6f4d853bde4d423587fb81b0940945369"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["ca8125609b7262844370761a4c1f26137c9f3a6b"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["d93bd328514720a5d9f50266ea72059833876b71","c66792f6f4d853bde4d423587fb81b0940945369"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["c15914b0d98e563f81d03ee023dc82f58171369d"],"c66792f6f4d853bde4d423587fb81b0940945369":["d93bd328514720a5d9f50266ea72059833876b71"],"575e66bd4b2349209027f6801184da7fc3cba13f":["2ef113fb050c2f71e3075c84198045b09385eda3"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","c15914b0d98e563f81d03ee023dc82f58171369d"],"c15914b0d98e563f81d03ee023dc82f58171369d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"ca8125609b7262844370761a4c1f26137c9f3a6b":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"28288370235ed02234a64753cdbf0c6ec096304a":["ca8125609b7262844370761a4c1f26137c9f3a6b","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","c15914b0d98e563f81d03ee023dc82f58171369d"],"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["c15914b0d98e563f81d03ee023dc82f58171369d"],"da8a02bef7458089240404614139b53c9f875ec7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","c15914b0d98e563f81d03ee023dc82f58171369d"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b2d19164145b2a65acf62a657c75f4a249b649c0":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"2ef113fb050c2f71e3075c84198045b09385eda3":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2d19164145b2a65acf62a657c75f4a249b649c0"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"d93bd328514720a5d9f50266ea72059833876b71":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","c66792f6f4d853bde4d423587fb81b0940945369"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5b8ee93140fd0efef7e101786e3ed5160a700b5f","c15914b0d98e563f81d03ee023dc82f58171369d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","da8a02bef7458089240404614139b53c9f875ec7"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["ca8125609b7262844370761a4c1f26137c9f3a6b"],"c66792f6f4d853bde4d423587fb81b0940945369":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"575e66bd4b2349209027f6801184da7fc3cba13f":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":[],"c15914b0d98e563f81d03ee023dc82f58171369d":["6d2dadc1f5ca8703d8659f4964961f9967935d75","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e5fa6615014cd2288fe930f8c8bb726f9504961d","da8a02bef7458089240404614139b53c9f875ec7"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"ca8125609b7262844370761a4c1f26137c9f3a6b":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0":["d93bd328514720a5d9f50266ea72059833876b71"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"da8a02bef7458089240404614139b53c9f875ec7":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["b2d19164145b2a65acf62a657c75f4a249b649c0"],"b2d19164145b2a65acf62a657c75f4a249b649c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2ef113fb050c2f71e3075c84198045b09385eda3":["575e66bd4b2349209027f6801184da7fc3cba13f"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["2ef113fb050c2f71e3075c84198045b09385eda3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","5b8ee93140fd0efef7e101786e3ed5160a700b5f","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","da8a02bef7458089240404614139b53c9f875ec7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}