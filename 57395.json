{"path":"lucene/spatial3d/src/java/org/apache/lucene/bkdtree3d/BKD3DTreeReader#intersect(QueryState,int,int,int,int,int,int,int).mjava","commits":[{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/bkdtree3d/BKD3DTreeReader#intersect(QueryState,int,int,int,int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellXMin, int cellXMax,\n                        int cellYMin, int cellYMax,\n                        int cellZMin, int cellZMax)\n    throws IOException {\n\n    //System.out.println(\"BKD3D.intersect nodeID=\" + nodeID + \" cellX=\" + cellXMin + \" TO \" + cellXMax + \", cellY=\" + cellYMin + \" TO \" + cellYMax + \", cellZ=\" + cellZMin + \" TO \" + cellZMax);\n\n    if (cellXMin >= state.xMin ||\n        cellXMax <= state.xMax ||\n        cellYMin >= state.yMin ||\n        cellYMax <= state.yMax ||\n        cellZMin >= state.zMin ||\n        cellZMax <= state.zMax) {\n\n      // Only call the filter when the current cell does not fully contain the bbox:\n      Relation r = state.valueFilter.compare(cellXMin, cellXMax,\n                                             cellYMin, cellYMax,\n                                             cellZMin, cellZMax);\n      //System.out.println(\"  relation: \" + r);\n\n      if (r == Relation.SHAPE_OUTSIDE_CELL) {\n        // This cell is fully outside of the query shape: stop recursing\n        return 0;\n      } else if (r == Relation.CELL_INSIDE_SHAPE) {\n        // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n        \n        /*\n        System.out.println(Thread.currentThread() + \": switch to addAll at cell\" +\n                           \" x=\" + Geo3DDocValuesFormat.decodeValue(cellXMin) + \" to \" + Geo3DDocValuesFormat.decodeValue(cellXMax) +\n                           \" y=\" + Geo3DDocValuesFormat.decodeValue(cellYMin) + \" to \" + Geo3DDocValuesFormat.decodeValue(cellYMax) +\n                           \" z=\" + Geo3DDocValuesFormat.decodeValue(cellZMin) + \" to \" + Geo3DDocValuesFormat.decodeValue(cellZMax));\n        */\n        return addAll(state, nodeID);\n      } else {\n        // The cell crosses the shape boundary, so we fall through and do full filtering\n      }\n    } else {\n      // The whole point of the incoming bbox (state.xMin/xMax/etc.) is that it is\n      // supposed to fully enclose the shape, so this cell we are visiting, which\n      // fully contains the query's bbox, better in turn fully contain the shape!\n      assert state.valueFilter.compare(cellXMin, cellXMax, cellYMin, cellYMax, cellZMin, cellZMax) == Relation.SHAPE_INSIDE_CELL: \"got \" + state.valueFilter.compare(cellXMin, cellXMax, cellYMin, cellYMax, cellZMin, cellZMax);\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      //System.out.println(\"  leaf\");\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      state.docs.grow(count);\n      //System.out.println(\"  count=\" + count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        //System.out.println(\"  check docID=\" + docID);\n        if (state.valueFilter.accept(docID)) {\n          state.docs.add(docID);\n          hitCount++;\n        }\n      }\n\n      return hitCount;\n\n    } else {\n\n      //System.out.println(\"  non-leaf\");\n\n      int splitDim = BKD3DTreeWriter.getSplitDim(cellXMin, cellXMax,\n                                                 cellYMin, cellYMax,\n                                                 cellZMin, cellZMax);\n\n      int splitValue = splitValues[nodeID];\n\n      int count = 0;\n\n      if (splitDim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on x:\n\n        // Left node:\n        if (state.xMin <= splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellXMin, splitValue,\n                             cellYMin, cellYMax,\n                             cellZMin, cellZMax);\n        }\n\n        // Right node:\n        if (state.xMax >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellXMax,\n                             cellYMin, cellYMax,\n                             cellZMin, cellZMax);\n        }\n\n      } else if (splitDim == 1) {\n        // Inner node split on y:\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.yMin <= splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellXMin, cellXMax,\n                             cellYMin, splitValue,\n                             cellZMin, cellZMax);\n        }\n\n        // Right node:\n        if (state.yMax >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellXMin, cellXMax,\n                             splitValue, cellYMax,\n                             cellZMin, cellZMax);\n        }\n      } else {\n        // Inner node split on z:\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.zMin <= splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellXMin, cellXMax,\n                             cellYMin, cellYMax,\n                             cellZMin, splitValue);\n        }\n\n        // Right node:\n        if (state.zMax >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellXMin, cellXMax,\n                             cellYMin, cellYMax,\n                             splitValue, cellZMax);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/bkdtree3d/BKD3DTreeReader#intersect(QueryState,int,int,int,int,int,int,int).mjava","sourceNew":null,"sourceOld":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellXMin, int cellXMax,\n                        int cellYMin, int cellYMax,\n                        int cellZMin, int cellZMax)\n    throws IOException {\n\n    //System.out.println(\"BKD3D.intersect nodeID=\" + nodeID + \" cellX=\" + cellXMin + \" TO \" + cellXMax + \", cellY=\" + cellYMin + \" TO \" + cellYMax + \", cellZ=\" + cellZMin + \" TO \" + cellZMax);\n\n    if (cellXMin >= state.xMin ||\n        cellXMax <= state.xMax ||\n        cellYMin >= state.yMin ||\n        cellYMax <= state.yMax ||\n        cellZMin >= state.zMin ||\n        cellZMax <= state.zMax) {\n\n      // Only call the filter when the current cell does not fully contain the bbox:\n      Relation r = state.valueFilter.compare(cellXMin, cellXMax,\n                                             cellYMin, cellYMax,\n                                             cellZMin, cellZMax);\n      //System.out.println(\"  relation: \" + r);\n\n      if (r == Relation.SHAPE_OUTSIDE_CELL) {\n        // This cell is fully outside of the query shape: stop recursing\n        return 0;\n      } else if (r == Relation.CELL_INSIDE_SHAPE) {\n        // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n        \n        /*\n        System.out.println(Thread.currentThread() + \": switch to addAll at cell\" +\n                           \" x=\" + Geo3DDocValuesFormat.decodeValue(cellXMin) + \" to \" + Geo3DDocValuesFormat.decodeValue(cellXMax) +\n                           \" y=\" + Geo3DDocValuesFormat.decodeValue(cellYMin) + \" to \" + Geo3DDocValuesFormat.decodeValue(cellYMax) +\n                           \" z=\" + Geo3DDocValuesFormat.decodeValue(cellZMin) + \" to \" + Geo3DDocValuesFormat.decodeValue(cellZMax));\n        */\n        return addAll(state, nodeID);\n      } else {\n        // The cell crosses the shape boundary, so we fall through and do full filtering\n      }\n    } else {\n      // The whole point of the incoming bbox (state.xMin/xMax/etc.) is that it is\n      // supposed to fully enclose the shape, so this cell we are visiting, which\n      // fully contains the query's bbox, better in turn fully contain the shape!\n      assert state.valueFilter.compare(cellXMin, cellXMax, cellYMin, cellYMax, cellZMin, cellZMax) == Relation.SHAPE_INSIDE_CELL: \"got \" + state.valueFilter.compare(cellXMin, cellXMax, cellYMin, cellYMax, cellZMin, cellZMax);\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      //System.out.println(\"  leaf\");\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      state.docs.grow(count);\n      //System.out.println(\"  count=\" + count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        //System.out.println(\"  check docID=\" + docID);\n        if (state.valueFilter.accept(docID)) {\n          state.docs.add(docID);\n          hitCount++;\n        }\n      }\n\n      return hitCount;\n\n    } else {\n\n      //System.out.println(\"  non-leaf\");\n\n      int splitDim = BKD3DTreeWriter.getSplitDim(cellXMin, cellXMax,\n                                                 cellYMin, cellYMax,\n                                                 cellZMin, cellZMax);\n\n      int splitValue = splitValues[nodeID];\n\n      int count = 0;\n\n      if (splitDim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on x:\n\n        // Left node:\n        if (state.xMin <= splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellXMin, splitValue,\n                             cellYMin, cellYMax,\n                             cellZMin, cellZMax);\n        }\n\n        // Right node:\n        if (state.xMax >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellXMax,\n                             cellYMin, cellYMax,\n                             cellZMin, cellZMax);\n        }\n\n      } else if (splitDim == 1) {\n        // Inner node split on y:\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.yMin <= splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellXMin, cellXMax,\n                             cellYMin, splitValue,\n                             cellZMin, cellZMax);\n        }\n\n        // Right node:\n        if (state.yMax >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellXMin, cellXMax,\n                             splitValue, cellYMax,\n                             cellZMin, cellZMax);\n        }\n      } else {\n        // Inner node split on z:\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.zMin <= splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellXMin, cellXMax,\n                             cellYMin, cellYMax,\n                             cellZMin, splitValue);\n        }\n\n        // Right node:\n        if (state.zMax >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellXMin, cellXMax,\n                             cellYMin, cellYMax,\n                             splitValue, cellZMax);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f64b7098768253180859cd8faeae6b1a185b06ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["f64b7098768253180859cd8faeae6b1a185b06ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"]},"commit2Childs":{"f64b7098768253180859cd8faeae6b1a185b06ed":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f64b7098768253180859cd8faeae6b1a185b06ed"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}