{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","sourceNew":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if(async!=null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir);\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","sourceOld":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if(async!=null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir);\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","sourceNew":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if(async!=null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir);\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","sourceOld":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if(async!=null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir);\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27639bb5e041490ce599065875dd2f6d8beef62a","date":1532829373,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","sourceNew":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir);\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","sourceOld":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if(async!=null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir);\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"346faa31ad3a1f8db6c1a33c5a703e0fa4826a94","date":1537439812,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","sourceNew":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir);\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","sourceOld":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir);\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13566d7393ca95d9897baf67f5e9c87dca82a253","date":1571390317,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","sourceNew":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir,\n        ZkStateReader.REPLICA_TYPE, replica.getType().name());\n\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","sourceOld":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir);\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","sourceNew":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir,\n        ZkStateReader.REPLICA_TYPE, replica.getType().name());\n\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica {} - trying to roll back...\",  addReplicasProps, e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","sourceOld":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir,\n        ZkStateReader.REPLICA_TYPE, replica.getType().name());\n\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica \" + addReplicasProps + \" - trying to roll back...\", e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private void moveHdfsReplica(ClusterState clusterState, @SuppressWarnings({\"rawtypes\"})NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir,\n        ZkStateReader.REPLICA_TYPE, replica.getType().name());\n\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica {} - trying to roll back...\",  addReplicasProps, e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","sourceOld":"  private void moveHdfsReplica(ClusterState clusterState, NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir,\n        ZkStateReader.REPLICA_TYPE, replica.getType().name());\n\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica {} - trying to roll back...\",  addReplicasProps, e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,CloudConfig,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private void moveHdfsReplica(ClusterState clusterState, CloudConfig cloudConfig, @SuppressWarnings({\"rawtypes\"})NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir,\n        ZkStateReader.REPLICA_TYPE, replica.getType().name());\n\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), cloudConfig, addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica {} - trying to roll back...\",  addReplicasProps, e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), cloudConfig, addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), cloudConfig, addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  private void moveHdfsReplica(ClusterState clusterState, @SuppressWarnings({\"rawtypes\"})NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir,\n        ZkStateReader.REPLICA_TYPE, replica.getType().name());\n\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica {} - trying to roll back...\",  addReplicasProps, e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MoveReplicaCmd#moveHdfsReplica(ClusterState,CloudConfig,NamedList,String,String,String,DocCollection,Replica,Slice,int,boolean).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private void moveHdfsReplica(ClusterState clusterState, @SuppressWarnings({\"rawtypes\"})NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir,\n        ZkStateReader.REPLICA_TYPE, replica.getType().name());\n\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica {} - trying to roll back...\",  addReplicasProps, e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  private void moveHdfsReplica(ClusterState clusterState, CloudConfig cloudConfig, @SuppressWarnings({\"rawtypes\"})NamedList results, String dataDir, String targetNode, String async,\n                                 DocCollection coll, Replica replica, Slice slice, int timeout, boolean waitForFinalState) throws Exception {\n    String skipCreateReplicaInClusterState = \"true\";\n    if (clusterState.getLiveNodes().contains(replica.getNodeName())) {\n      skipCreateReplicaInClusterState = \"false\";\n      ZkNodeProps removeReplicasProps = new ZkNodeProps(\n          COLLECTION_PROP, coll.getName(),\n          SHARD_ID_PROP, slice.getName(),\n          REPLICA_PROP, replica.getName()\n      );\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_DATA_DIR, false);\n      removeReplicasProps.getProperties().put(CoreAdminParams.DELETE_INDEX, false);\n      if (async != null) removeReplicasProps.getProperties().put(ASYNC, async);\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList deleteResult = new NamedList();\n      try {\n        ocmh.deleteReplica(clusterState, removeReplicasProps, deleteResult, null);\n      } catch (SolrException e) {\n        // assume this failed completely so there's nothing to roll back\n        deleteResult.add(\"failure\", e.toString());\n      }\n      if (deleteResult.get(\"failure\") != null) {\n        String errorString = String.format(Locale.ROOT, \"Failed to cleanup replica collection=%s shard=%s name=%s, failure=%s\",\n            coll.getName(), slice.getName(), replica.getName(), deleteResult.get(\"failure\"));\n        log.warn(errorString);\n        results.add(\"failure\", errorString);\n        return;\n      }\n\n      TimeOut timeOut = new TimeOut(20L, TimeUnit.SECONDS, timeSource);\n      while (!timeOut.hasTimedOut()) {\n        coll = ocmh.zkStateReader.getClusterState().getCollection(coll.getName());\n        if (coll.getReplica(replica.getName()) != null) {\n          timeOut.sleep(100);\n        } else {\n          break;\n        }\n      }\n      if (timeOut.hasTimedOut()) {\n        results.add(\"failure\", \"Still see deleted replica in clusterstate!\");\n        return;\n      }\n\n    }\n\n    String ulogDir = replica.getStr(CoreAdminParams.ULOG_DIR);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, coll.getName(),\n        SHARD_ID_PROP, slice.getName(),\n        CoreAdminParams.NODE, targetNode,\n        CoreAdminParams.CORE_NODE_NAME, replica.getName(),\n        CoreAdminParams.NAME, replica.getCoreName(),\n        WAIT_FOR_FINAL_STATE, String.valueOf(waitForFinalState),\n        SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, skipCreateReplicaInClusterState,\n        CoreAdminParams.ULOG_DIR, ulogDir.substring(0, ulogDir.lastIndexOf(UpdateLog.TLOG_NAME)),\n        CoreAdminParams.DATA_DIR, dataDir,\n        ZkStateReader.REPLICA_TYPE, replica.getType().name());\n\n    if(async!=null) addReplicasProps.getProperties().put(ASYNC, async);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), cloudConfig, addReplicasProps, addResult, null);\n    } catch (Exception e) {\n      // fatal error - try rolling back\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      results.add(\"failure\", errorString);\n      log.warn(\"Error adding replica {} - trying to roll back...\",  addReplicasProps, e);\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      ocmh.addReplica(ocmh.zkStateReader.getClusterState(), cloudConfig, addReplicasProps, rollback, null);\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent: \" + rollback.get(\"failure\"));\n      }\n      return;\n    }\n    if (addResult.get(\"failure\") != null) {\n      String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n          \" on node=%s, failure=%s\", coll.getName(), slice.getName(), targetNode, addResult.get(\"failure\"));\n      log.warn(errorString);\n      results.add(\"failure\", errorString);\n      log.debug(\"--- trying to roll back...\");\n      // try to roll back\n      addReplicasProps = addReplicasProps.plus(CoreAdminParams.NODE, replica.getNodeName());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rollback = new NamedList();\n      try {\n        ocmh.addReplica(ocmh.zkStateReader.getClusterState(), cloudConfig, addReplicasProps, rollback, null);\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent!\", e);\n      }\n      if (rollback.get(\"failure\") != null) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Fatal error during MOVEREPLICA of \" + replica\n            + \", collection may be inconsistent! Failure: \" + rollback.get(\"failure\"));\n      }\n      return;\n    } else {\n      String successString = String.format(Locale.ROOT, \"MOVEREPLICA action completed successfully, moved replica=%s at node=%s \" +\n          \"to replica=%s at node=%s\", replica.getCoreName(), replica.getNodeName(), replica.getCoreName(), targetNode);\n      results.add(\"success\", successString);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"4abf821a41a2fdca2a1dea148999931d22e20529":["13566d7393ca95d9897baf67f5e9c87dca82a253"],"13566d7393ca95d9897baf67f5e9c87dca82a253":["346faa31ad3a1f8db6c1a33c5a703e0fa4826a94"],"c526352db87264a72a7a9ad68c1b769b81e54305":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["4abf821a41a2fdca2a1dea148999931d22e20529"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"346faa31ad3a1f8db6c1a33c5a703e0fa4826a94":["27639bb5e041490ce599065875dd2f6d8beef62a"],"27639bb5e041490ce599065875dd2f6d8beef62a":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b94236357aaa22b76c10629851fe4e376e0cea82":["27639bb5e041490ce599065875dd2f6d8beef62a"],"4abf821a41a2fdca2a1dea148999931d22e20529":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"13566d7393ca95d9897baf67f5e9c87dca82a253":["4abf821a41a2fdca2a1dea148999931d22e20529"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["c526352db87264a72a7a9ad68c1b769b81e54305"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"346faa31ad3a1f8db6c1a33c5a703e0fa4826a94":["13566d7393ca95d9897baf67f5e9c87dca82a253"],"27639bb5e041490ce599065875dd2f6d8beef62a":["346faa31ad3a1f8db6c1a33c5a703e0fa4826a94"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}