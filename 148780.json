{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","commits":[{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","pathOld":"/dev/null","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrServer cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"072f211dfa8387028bb978d128c35bf9a450bbbf","date":1406041363,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrServer cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrServer cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","bugFix":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"471d806b28fa8f148222eb0c300dcab1047a391d","date":1413210204,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrServer cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrServer cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrServer cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrServer cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrClient solrClient = new HttpSolrClient(url);\n      QueryResponse queryResponse = queryRequest.process(solrClient);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrClient threadedClient = null;\n    try {\n      threadedClient = new CloudSolrClient(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrClient solrClient = new HttpSolrClient(url);\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrServer cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"072f211dfa8387028bb978d128c35bf9a450bbbf":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"55980207f1977bd1463465de1659b821347e2fa8":["072f211dfa8387028bb978d128c35bf9a450bbbf","471d806b28fa8f148222eb0c300dcab1047a391d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bafca15d8e408346a67f4282ad1143b88023893b":["471d806b28fa8f148222eb0c300dcab1047a391d"],"471d806b28fa8f148222eb0c300dcab1047a391d":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"]},"commit2Childs":{"072f211dfa8387028bb978d128c35bf9a450bbbf":["55980207f1977bd1463465de1659b821347e2fa8","471d806b28fa8f148222eb0c300dcab1047a391d"],"55980207f1977bd1463465de1659b821347e2fa8":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"471d806b28fa8f148222eb0c300dcab1047a391d":["55980207f1977bd1463465de1659b821347e2fa8","bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}