{"path":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#createRegularPolygon(double,double,double,int).mjava","commits":[{"id":"479a2bccf10cd79339b5e18eccf3b0b9a18b755f","date":1460541098,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#createRegularPolygon(double,double,double,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Makes an n-gon, centered at the provided lat/lon, and each vertex approximately\n   *  distanceMeters away from the center.\n   *\n   * Do not invoke me across the dateline or a pole!! */\n  public static Polygon createRegularPolygon(double centerLat, double centerLon, double radiusMeters, int gons) {\n\n    // System.out.println(\"MAKE POLY: centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters + \" gons=\" + gons);\n\n    double[][] result = new double[2][];\n    result[0] = new double[gons+1];\n    result[1] = new double[gons+1];\n    //System.out.println(\"make gon=\" + gons);\n    for(int i=0;i<gons;i++) {\n      double angle = 360.0-i*(360.0/gons);\n      //System.out.println(\"  angle \" + angle);\n      double x = Math.cos(Math.toRadians(angle));\n      double y = Math.sin(Math.toRadians(angle));\n      double factor = 2.0;\n      double step = 1.0;\n      int last = 0;\n\n      //System.out.println(\"angle \" + angle + \" slope=\" + slope);\n      // Iterate out along one spoke until we hone in on the point that's nearly exactly radiusMeters from the center:\n      while (true) {\n\n        // TODO: we could in fact cross a pole?  Just do what surpriseMePolygon does?\n        double lat = centerLat + y * factor;\n        GeoUtils.checkLatitude(lat);\n        double lon = centerLon + x * factor;\n        GeoUtils.checkLongitude(lon);\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        //System.out.println(\"  iter lat=\" + lat + \" lon=\" + lon + \" distance=\" + distanceMeters + \" vs \" + radiusMeters);\n        if (Math.abs(distanceMeters - radiusMeters) < 0.1) {\n          // Within 10 cm: close enough!\n          result[0][i] = lat;\n          result[1][i] = lon;\n          break;\n        }\n\n        if (distanceMeters > radiusMeters) {\n          // too big\n          //System.out.println(\"    smaller\");\n          factor -= step;\n          if (last == 1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = -1;\n        } else if (distanceMeters < radiusMeters) {\n          // too small\n          //System.out.println(\"    bigger\");\n          factor += step;\n          if (last == -1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = 1;\n        }\n      }\n    }\n\n    // close poly\n    result[0][gons] = result[0][0];\n    result[1][gons] = result[1][0];\n\n    //System.out.println(\"  polyLats=\" + Arrays.toString(result[0]));\n    //System.out.println(\"  polyLons=\" + Arrays.toString(result[1]));\n\n    return new Polygon(result[0], result[1]);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c7e72caffc799b265e17158ff9b0aad014849ad8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#createRegularPolygon(double,double,double,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Makes an n-gon, centered at the provided lat/lon, and each vertex approximately\n   *  distanceMeters away from the center.\n   *\n   * Do not invoke me across the dateline or a pole!! */\n  public static Polygon createRegularPolygon(double centerLat, double centerLon, double radiusMeters, int gons) {\n\n    // System.out.println(\"MAKE POLY: centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters + \" gons=\" + gons);\n\n    double[][] result = new double[2][];\n    result[0] = new double[gons+1];\n    result[1] = new double[gons+1];\n    //System.out.println(\"make gon=\" + gons);\n    for(int i=0;i<gons;i++) {\n      double angle = 360.0-i*(360.0/gons);\n      //System.out.println(\"  angle \" + angle);\n      double x = Math.cos(Math.toRadians(angle));\n      double y = Math.sin(Math.toRadians(angle));\n      double factor = 2.0;\n      double step = 1.0;\n      int last = 0;\n\n      //System.out.println(\"angle \" + angle + \" slope=\" + slope);\n      // Iterate out along one spoke until we hone in on the point that's nearly exactly radiusMeters from the center:\n      while (true) {\n\n        // TODO: we could in fact cross a pole?  Just do what surpriseMePolygon does?\n        double lat = centerLat + y * factor;\n        GeoUtils.checkLatitude(lat);\n        double lon = centerLon + x * factor;\n        GeoUtils.checkLongitude(lon);\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        //System.out.println(\"  iter lat=\" + lat + \" lon=\" + lon + \" distance=\" + distanceMeters + \" vs \" + radiusMeters);\n        if (Math.abs(distanceMeters - radiusMeters) < 0.1) {\n          // Within 10 cm: close enough!\n          result[0][i] = lat;\n          result[1][i] = lon;\n          break;\n        }\n\n        if (distanceMeters > radiusMeters) {\n          // too big\n          //System.out.println(\"    smaller\");\n          factor -= step;\n          if (last == 1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = -1;\n        } else if (distanceMeters < radiusMeters) {\n          // too small\n          //System.out.println(\"    bigger\");\n          factor += step;\n          if (last == -1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = 1;\n        }\n      }\n    }\n\n    // close poly\n    result[0][gons] = result[0][0];\n    result[1][gons] = result[1][0];\n\n    //System.out.println(\"  polyLats=\" + Arrays.toString(result[0]));\n    //System.out.println(\"  polyLons=\" + Arrays.toString(result[1]));\n\n    return new Polygon(result[0], result[1]);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7e72caffc799b265e17158ff9b0aad014849ad8","date":1466582027,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#createRegularPolygon(double,double,double,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#createRegularPolygon(double,double,double,int).mjava","sourceNew":"  /** Makes an n-gon, centered at the provided lat/lon, and each vertex approximately\n   *  distanceMeters away from the center.\n   *\n   * Do not invoke me across the dateline or a pole!! */\n  public static Polygon createRegularPolygon(double centerLat, double centerLon, double radiusMeters, int gons) {\n\n    // System.out.println(\"MAKE POLY: centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters + \" gons=\" + gons);\n\n    double[][] result = new double[2][];\n    result[0] = new double[gons+1];\n    result[1] = new double[gons+1];\n    //System.out.println(\"make gon=\" + gons);\n    for(int i=0;i<gons;i++) {\n      double angle = 360.0-i*(360.0/gons);\n      //System.out.println(\"  angle \" + angle);\n      double x = Math.cos(SloppyMath.toRadians(angle));\n      double y = Math.sin(SloppyMath.toRadians(angle));\n      double factor = 2.0;\n      double step = 1.0;\n      int last = 0;\n\n      //System.out.println(\"angle \" + angle + \" slope=\" + slope);\n      // Iterate out along one spoke until we hone in on the point that's nearly exactly radiusMeters from the center:\n      while (true) {\n\n        // TODO: we could in fact cross a pole?  Just do what surpriseMePolygon does?\n        double lat = centerLat + y * factor;\n        GeoUtils.checkLatitude(lat);\n        double lon = centerLon + x * factor;\n        GeoUtils.checkLongitude(lon);\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        //System.out.println(\"  iter lat=\" + lat + \" lon=\" + lon + \" distance=\" + distanceMeters + \" vs \" + radiusMeters);\n        if (Math.abs(distanceMeters - radiusMeters) < 0.1) {\n          // Within 10 cm: close enough!\n          result[0][i] = lat;\n          result[1][i] = lon;\n          break;\n        }\n\n        if (distanceMeters > radiusMeters) {\n          // too big\n          //System.out.println(\"    smaller\");\n          factor -= step;\n          if (last == 1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = -1;\n        } else if (distanceMeters < radiusMeters) {\n          // too small\n          //System.out.println(\"    bigger\");\n          factor += step;\n          if (last == -1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = 1;\n        }\n      }\n    }\n\n    // close poly\n    result[0][gons] = result[0][0];\n    result[1][gons] = result[1][0];\n\n    //System.out.println(\"  polyLats=\" + Arrays.toString(result[0]));\n    //System.out.println(\"  polyLons=\" + Arrays.toString(result[1]));\n\n    return new Polygon(result[0], result[1]);\n  }\n\n","sourceOld":"  /** Makes an n-gon, centered at the provided lat/lon, and each vertex approximately\n   *  distanceMeters away from the center.\n   *\n   * Do not invoke me across the dateline or a pole!! */\n  public static Polygon createRegularPolygon(double centerLat, double centerLon, double radiusMeters, int gons) {\n\n    // System.out.println(\"MAKE POLY: centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters + \" gons=\" + gons);\n\n    double[][] result = new double[2][];\n    result[0] = new double[gons+1];\n    result[1] = new double[gons+1];\n    //System.out.println(\"make gon=\" + gons);\n    for(int i=0;i<gons;i++) {\n      double angle = 360.0-i*(360.0/gons);\n      //System.out.println(\"  angle \" + angle);\n      double x = Math.cos(Math.toRadians(angle));\n      double y = Math.sin(Math.toRadians(angle));\n      double factor = 2.0;\n      double step = 1.0;\n      int last = 0;\n\n      //System.out.println(\"angle \" + angle + \" slope=\" + slope);\n      // Iterate out along one spoke until we hone in on the point that's nearly exactly radiusMeters from the center:\n      while (true) {\n\n        // TODO: we could in fact cross a pole?  Just do what surpriseMePolygon does?\n        double lat = centerLat + y * factor;\n        GeoUtils.checkLatitude(lat);\n        double lon = centerLon + x * factor;\n        GeoUtils.checkLongitude(lon);\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        //System.out.println(\"  iter lat=\" + lat + \" lon=\" + lon + \" distance=\" + distanceMeters + \" vs \" + radiusMeters);\n        if (Math.abs(distanceMeters - radiusMeters) < 0.1) {\n          // Within 10 cm: close enough!\n          result[0][i] = lat;\n          result[1][i] = lon;\n          break;\n        }\n\n        if (distanceMeters > radiusMeters) {\n          // too big\n          //System.out.println(\"    smaller\");\n          factor -= step;\n          if (last == 1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = -1;\n        } else if (distanceMeters < radiusMeters) {\n          // too small\n          //System.out.println(\"    bigger\");\n          factor += step;\n          if (last == -1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = 1;\n        }\n      }\n    }\n\n    // close poly\n    result[0][gons] = result[0][0];\n    result[1][gons] = result[1][0];\n\n    //System.out.println(\"  polyLats=\" + Arrays.toString(result[0]));\n    //System.out.println(\"  polyLons=\" + Arrays.toString(result[1]));\n\n    return new Polygon(result[0], result[1]);\n  }\n\n","bugFix":["479a2bccf10cd79339b5e18eccf3b0b9a18b755f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#createRegularPolygon(double,double,double,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#createRegularPolygon(double,double,double,int).mjava","sourceNew":"  /** Makes an n-gon, centered at the provided lat/lon, and each vertex approximately\n   *  distanceMeters away from the center.\n   *\n   * Do not invoke me across the dateline or a pole!! */\n  public static Polygon createRegularPolygon(double centerLat, double centerLon, double radiusMeters, int gons) {\n\n    // System.out.println(\"MAKE POLY: centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters + \" gons=\" + gons);\n\n    double[][] result = new double[2][];\n    result[0] = new double[gons+1];\n    result[1] = new double[gons+1];\n    //System.out.println(\"make gon=\" + gons);\n    for(int i=0;i<gons;i++) {\n      double angle = 360.0-i*(360.0/gons);\n      //System.out.println(\"  angle \" + angle);\n      double x = Math.cos(SloppyMath.toRadians(angle));\n      double y = Math.sin(SloppyMath.toRadians(angle));\n      double factor = 2.0;\n      double step = 1.0;\n      int last = 0;\n\n      //System.out.println(\"angle \" + angle + \" slope=\" + slope);\n      // Iterate out along one spoke until we hone in on the point that's nearly exactly radiusMeters from the center:\n      while (true) {\n\n        // TODO: we could in fact cross a pole?  Just do what surpriseMePolygon does?\n        double lat = centerLat + y * factor;\n        GeoUtils.checkLatitude(lat);\n        double lon = centerLon + x * factor;\n        GeoUtils.checkLongitude(lon);\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        //System.out.println(\"  iter lat=\" + lat + \" lon=\" + lon + \" distance=\" + distanceMeters + \" vs \" + radiusMeters);\n        if (Math.abs(distanceMeters - radiusMeters) < 0.1) {\n          // Within 10 cm: close enough!\n          result[0][i] = lat;\n          result[1][i] = lon;\n          break;\n        }\n\n        if (distanceMeters > radiusMeters) {\n          // too big\n          //System.out.println(\"    smaller\");\n          factor -= step;\n          if (last == 1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = -1;\n        } else if (distanceMeters < radiusMeters) {\n          // too small\n          //System.out.println(\"    bigger\");\n          factor += step;\n          if (last == -1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = 1;\n        }\n      }\n    }\n\n    // close poly\n    result[0][gons] = result[0][0];\n    result[1][gons] = result[1][0];\n\n    //System.out.println(\"  polyLats=\" + Arrays.toString(result[0]));\n    //System.out.println(\"  polyLons=\" + Arrays.toString(result[1]));\n\n    return new Polygon(result[0], result[1]);\n  }\n\n","sourceOld":"  /** Makes an n-gon, centered at the provided lat/lon, and each vertex approximately\n   *  distanceMeters away from the center.\n   *\n   * Do not invoke me across the dateline or a pole!! */\n  public static Polygon createRegularPolygon(double centerLat, double centerLon, double radiusMeters, int gons) {\n\n    // System.out.println(\"MAKE POLY: centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters + \" gons=\" + gons);\n\n    double[][] result = new double[2][];\n    result[0] = new double[gons+1];\n    result[1] = new double[gons+1];\n    //System.out.println(\"make gon=\" + gons);\n    for(int i=0;i<gons;i++) {\n      double angle = 360.0-i*(360.0/gons);\n      //System.out.println(\"  angle \" + angle);\n      double x = Math.cos(Math.toRadians(angle));\n      double y = Math.sin(Math.toRadians(angle));\n      double factor = 2.0;\n      double step = 1.0;\n      int last = 0;\n\n      //System.out.println(\"angle \" + angle + \" slope=\" + slope);\n      // Iterate out along one spoke until we hone in on the point that's nearly exactly radiusMeters from the center:\n      while (true) {\n\n        // TODO: we could in fact cross a pole?  Just do what surpriseMePolygon does?\n        double lat = centerLat + y * factor;\n        GeoUtils.checkLatitude(lat);\n        double lon = centerLon + x * factor;\n        GeoUtils.checkLongitude(lon);\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        //System.out.println(\"  iter lat=\" + lat + \" lon=\" + lon + \" distance=\" + distanceMeters + \" vs \" + radiusMeters);\n        if (Math.abs(distanceMeters - radiusMeters) < 0.1) {\n          // Within 10 cm: close enough!\n          result[0][i] = lat;\n          result[1][i] = lon;\n          break;\n        }\n\n        if (distanceMeters > radiusMeters) {\n          // too big\n          //System.out.println(\"    smaller\");\n          factor -= step;\n          if (last == 1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = -1;\n        } else if (distanceMeters < radiusMeters) {\n          // too small\n          //System.out.println(\"    bigger\");\n          factor += step;\n          if (last == -1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = 1;\n        }\n      }\n    }\n\n    // close poly\n    result[0][gons] = result[0][0];\n    result[1][gons] = result[1][0];\n\n    //System.out.println(\"  polyLats=\" + Arrays.toString(result[0]));\n    //System.out.println(\"  polyLons=\" + Arrays.toString(result[1]));\n\n    return new Polygon(result[0], result[1]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71a92b21a4564a0dd5e0559cebf435a5fe34542e","date":1573666298,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#createRegularPolygon(double,double,double,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#createRegularPolygon(double,double,double,int).mjava","sourceNew":"  /** Makes an n-gon, centered at the provided lat/lon, and each vertex approximately\n   *  distanceMeters away from the center.\n   *\n   * Do not invoke me across the dateline or a pole!! */\n  public static Polygon createRegularPolygon(double centerLat, double centerLon, double radiusMeters, int gons) {\n\n    // System.out.println(\"MAKE POLY: centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters + \" gons=\" + gons);\n\n    double[][] result = new double[2][];\n    result[0] = new double[gons+1];\n    result[1] = new double[gons+1];\n    //System.out.println(\"make gon=\" + gons);\n    for(int i=0;i<gons;i++) {\n      double angle = 360.0-i*(360.0/gons);\n      //System.out.println(\"  angle \" + angle);\n      double x = Math.cos(Math.toRadians(angle));\n      double y = Math.sin(Math.toRadians(angle));\n      double factor = 2.0;\n      double step = 1.0;\n      int last = 0;\n\n      //System.out.println(\"angle \" + angle + \" slope=\" + slope);\n      // Iterate out along one spoke until we hone in on the point that's nearly exactly radiusMeters from the center:\n      while (true) {\n\n        // TODO: we could in fact cross a pole?  Just do what surpriseMePolygon does?\n        double lat = centerLat + y * factor;\n        GeoUtils.checkLatitude(lat);\n        double lon = centerLon + x * factor;\n        GeoUtils.checkLongitude(lon);\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        //System.out.println(\"  iter lat=\" + lat + \" lon=\" + lon + \" distance=\" + distanceMeters + \" vs \" + radiusMeters);\n        if (Math.abs(distanceMeters - radiusMeters) < 0.1) {\n          // Within 10 cm: close enough!\n          result[0][i] = lat;\n          result[1][i] = lon;\n          break;\n        }\n\n        if (distanceMeters > radiusMeters) {\n          // too big\n          //System.out.println(\"    smaller\");\n          factor -= step;\n          if (last == 1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = -1;\n        } else if (distanceMeters < radiusMeters) {\n          // too small\n          //System.out.println(\"    bigger\");\n          factor += step;\n          if (last == -1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = 1;\n        }\n      }\n    }\n\n    // close poly\n    result[0][gons] = result[0][0];\n    result[1][gons] = result[1][0];\n\n    //System.out.println(\"  polyLats=\" + Arrays.toString(result[0]));\n    //System.out.println(\"  polyLons=\" + Arrays.toString(result[1]));\n\n    return new Polygon(result[0], result[1]);\n  }\n\n","sourceOld":"  /** Makes an n-gon, centered at the provided lat/lon, and each vertex approximately\n   *  distanceMeters away from the center.\n   *\n   * Do not invoke me across the dateline or a pole!! */\n  public static Polygon createRegularPolygon(double centerLat, double centerLon, double radiusMeters, int gons) {\n\n    // System.out.println(\"MAKE POLY: centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters + \" gons=\" + gons);\n\n    double[][] result = new double[2][];\n    result[0] = new double[gons+1];\n    result[1] = new double[gons+1];\n    //System.out.println(\"make gon=\" + gons);\n    for(int i=0;i<gons;i++) {\n      double angle = 360.0-i*(360.0/gons);\n      //System.out.println(\"  angle \" + angle);\n      double x = Math.cos(SloppyMath.toRadians(angle));\n      double y = Math.sin(SloppyMath.toRadians(angle));\n      double factor = 2.0;\n      double step = 1.0;\n      int last = 0;\n\n      //System.out.println(\"angle \" + angle + \" slope=\" + slope);\n      // Iterate out along one spoke until we hone in on the point that's nearly exactly radiusMeters from the center:\n      while (true) {\n\n        // TODO: we could in fact cross a pole?  Just do what surpriseMePolygon does?\n        double lat = centerLat + y * factor;\n        GeoUtils.checkLatitude(lat);\n        double lon = centerLon + x * factor;\n        GeoUtils.checkLongitude(lon);\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        //System.out.println(\"  iter lat=\" + lat + \" lon=\" + lon + \" distance=\" + distanceMeters + \" vs \" + radiusMeters);\n        if (Math.abs(distanceMeters - radiusMeters) < 0.1) {\n          // Within 10 cm: close enough!\n          result[0][i] = lat;\n          result[1][i] = lon;\n          break;\n        }\n\n        if (distanceMeters > radiusMeters) {\n          // too big\n          //System.out.println(\"    smaller\");\n          factor -= step;\n          if (last == 1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = -1;\n        } else if (distanceMeters < radiusMeters) {\n          // too small\n          //System.out.println(\"    bigger\");\n          factor += step;\n          if (last == -1) {\n            //System.out.println(\"      half-step\");\n            step /= 2.0;\n          }\n          last = 1;\n        }\n      }\n    }\n\n    // close poly\n    result[0][gons] = result[0][0];\n    result[1][gons] = result[1][0];\n\n    //System.out.println(\"  polyLats=\" + Arrays.toString(result[0]));\n    //System.out.println(\"  polyLons=\" + Arrays.toString(result[1]));\n\n    return new Polygon(result[0], result[1]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","479a2bccf10cd79339b5e18eccf3b0b9a18b755f"],"479a2bccf10cd79339b5e18eccf3b0b9a18b755f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c7e72caffc799b265e17158ff9b0aad014849ad8":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"71a92b21a4564a0dd5e0559cebf435a5fe34542e":["c7e72caffc799b265e17158ff9b0aad014849ad8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","c7e72caffc799b265e17158ff9b0aad014849ad8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71a92b21a4564a0dd5e0559cebf435a5fe34542e"]},"commit2Childs":{"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["c7e72caffc799b265e17158ff9b0aad014849ad8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"479a2bccf10cd79339b5e18eccf3b0b9a18b755f":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","479a2bccf10cd79339b5e18eccf3b0b9a18b755f"],"c7e72caffc799b265e17158ff9b0aad014849ad8":["71a92b21a4564a0dd5e0559cebf435a5fe34542e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"71a92b21a4564a0dd5e0559cebf435a5fe34542e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}