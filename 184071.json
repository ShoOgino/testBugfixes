{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doWaitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket,TimeOut).mjava","commits":[{"id":"9b3824fcbd3256db359391630ae05b3917ab369a","date":1556656304,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doWaitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket,TimeOut).mjava","pathOld":"/dev/null","sourceNew":"  private long doWaitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync, VersionBucket bucket,\n      TimeOut waitTimeout) {\n    long lastFoundVersion;\n    try {\n      Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n      lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n\n      if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n        log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\",\n            (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion,\n            isReplayOrPeersync, cmd.getPrintableId());\n      }\n\n      while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut()) {\n        long timeLeftInNanos = waitTimeout.timeLeft(TimeUnit.NANOSECONDS);\n        if(timeLeftInNanos > 0) { // 0 means: wait forever until notified, but we don't want that.\n          bucket.awaitNanos(timeLeftInNanos);\n        }\n        lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return lastFoundVersion;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doWaitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket,TimeOut).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doWaitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket,TimeOut).mjava","sourceNew":"  private long doWaitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync, VersionBucket bucket,\n      TimeOut waitTimeout) {\n    long lastFoundVersion;\n    try {\n      Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n      lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n\n      if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\",\n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion,\n              isReplayOrPeersync, cmd.getPrintableId());\n        }\n      }\n\n      while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut()) {\n        long timeLeftInNanos = waitTimeout.timeLeft(TimeUnit.NANOSECONDS);\n        if(timeLeftInNanos > 0) { // 0 means: wait forever until notified, but we don't want that.\n          bucket.awaitNanos(timeLeftInNanos);\n        }\n        lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return lastFoundVersion;\n  }\n\n","sourceOld":"  private long doWaitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync, VersionBucket bucket,\n      TimeOut waitTimeout) {\n    long lastFoundVersion;\n    try {\n      Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n      lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n\n      if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n        log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\",\n            (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion,\n            isReplayOrPeersync, cmd.getPrintableId());\n      }\n\n      while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut()) {\n        long timeLeftInNanos = waitTimeout.timeLeft(TimeUnit.NANOSECONDS);\n        if(timeLeftInNanos > 0) { // 0 means: wait forever until notified, but we don't want that.\n          bucket.awaitNanos(timeLeftInNanos);\n        }\n        lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return lastFoundVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9b3824fcbd3256db359391630ae05b3917ab369a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"740d649f013f07efbeb73ca854f106c60166e7c0":["9b3824fcbd3256db359391630ae05b3917ab369a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"]},"commit2Childs":{"9b3824fcbd3256db359391630ae05b3917ab369a":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9b3824fcbd3256db359391630ae05b3917ab369a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}