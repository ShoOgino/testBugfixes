{"path":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","commits":[{"id":"68b7d6fb5301c56ddb6a803c8fca1dbea2d76906","date":1298298228,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, null, \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              emitDotState(out, Integer.toString(arc.target), stateShape, null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n    \n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 } \");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, null, \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              emitDotState(out, Integer.toString(arc.target), stateShape, null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n    \n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 } \");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66a31a416e3550794ff2e245570885b7193952b6","date":1298453724,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, null, \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              emitDotState(out, Integer.toString(arc.target), stateShape, null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n    \n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 } \");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"692804e172a5810620fac3194db7b7616a21ad3d","date":1298513499,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, null, \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              emitDotState(out, Integer.toString(arc.target), stateShape, null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n    \n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 } \");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8be6e1e4fbbc94d90b78f175c03ff389b6949373","date":1306674752,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n    emitDotState(out, Integer.toString(startArc.target), stateShape, \n        fst.isExpandedTarget(startArc) ? expandedNodeColor : null, \n        \"\");\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        \n        if (fst.targetHasArcs(arc)) {\n          // scan all arcs\n          final int node = arc.target;\n          fst.readFirstTargetArc(arc, arc);\n          \n          while (true) {\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n              final boolean isExpanded = fst.isExpandedTarget(arc);\n              emitDotState(out, Integer.toString(arc.target), stateShape, \n                  isExpanded ?  expandedNodeColor : null, \n                  labelStates ? Integer.toString(arc.target) : \"\"); \n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            final String cl;\n            if (arc.label == FST.END_LABEL) {\n              cl = \"~\";\n            } else {\n              cl = printableLabel(arc.label);\n            }\n\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + cl + outs + \"\\\"]\\n\");\n            \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(arc);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=circle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"692804e172a5810620fac3194db7b7616a21ad3d":["bde51b089eb7f86171eb3406e38a274743f9b7ac","66a31a416e3550794ff2e245570885b7193952b6"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["66a31a416e3550794ff2e245570885b7193952b6"],"66a31a416e3550794ff2e245570885b7193952b6":["68b7d6fb5301c56ddb6a803c8fca1dbea2d76906"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","66a31a416e3550794ff2e245570885b7193952b6"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["66a31a416e3550794ff2e245570885b7193952b6","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68b7d6fb5301c56ddb6a803c8fca1dbea2d76906":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","68b7d6fb5301c56ddb6a803c8fca1dbea2d76906"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["d619839baa8ce5503e496b94a9e42ad6f079293f","8be6e1e4fbbc94d90b78f175c03ff389b6949373"]},"commit2Childs":{"692804e172a5810620fac3194db7b7616a21ad3d":[],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"66a31a416e3550794ff2e245570885b7193952b6":["692804e172a5810620fac3194db7b7616a21ad3d","8be6e1e4fbbc94d90b78f175c03ff389b6949373","d619839baa8ce5503e496b94a9e42ad6f079293f","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d619839baa8ce5503e496b94a9e42ad6f079293f","68b7d6fb5301c56ddb6a803c8fca1dbea2d76906","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"68b7d6fb5301c56ddb6a803c8fca1dbea2d76906":["66a31a416e3550794ff2e245570885b7193952b6","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["692804e172a5810620fac3194db7b7616a21ad3d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["692804e172a5810620fac3194db7b7616a21ad3d","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}