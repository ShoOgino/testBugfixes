{"path":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","commits":[{"id":"b3e493496c35fb4f17315b8827d1ba1ae1585554","date":1177392767,"type":0,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initializatin for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetiotions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.put(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = (PhrasePositions[]) m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            // must propagate higher offsets first (otherwise might miss matches).\n            Arrays.sort(repeats,  new Comparator() {\n                public int compare(Object x, Object y) {\n                    return ((PhrasePositions) y).offset - ((PhrasePositions) x).offset;\n                }});\n            // now advance them\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                while (!termPositionsDiffer(pp)) {\n                  if (!pp.nextPosition())\n                      return -1;    // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);         // build pq from list\n        }\n\n        return end;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["76bdd2a0d65c8a40e657fbefccfc915026e4902b","c9ff635e6838a2facda02727dec5b77d9e64dc4c","3b2ceed5f2320db5cc371e0dd95622cda9a9a56a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b2ceed5f2320db5cc371e0dd95622cda9a9a56a","date":1217778014,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.put(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = (PhrasePositions[]) m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initializatin for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetiotions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.put(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = (PhrasePositions[]) m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            // must propagate higher offsets first (otherwise might miss matches).\n            Arrays.sort(repeats,  new Comparator() {\n                public int compare(Object x, Object y) {\n                    return ((PhrasePositions) y).offset - ((PhrasePositions) x).offset;\n                }});\n            // now advance them\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                while (!termPositionsDiffer(pp)) {\n                  if (!pp.nextPosition())\n                      return -1;    // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);         // build pq from list\n        }\n\n        return end;\n    }\n\n","bugFix":["b3e493496c35fb4f17315b8827d1ba1ae1585554"],"bugIntro":["76bdd2a0d65c8a40e657fbefccfc915026e4902b","c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0731e137bcbb58121034de6ddaa67332fbe6e5d1","date":1255233265,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = (PhrasePositions[]) m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.put(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = (PhrasePositions[]) m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":null,"bugIntro":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef82ff03e4016c705811b2658e81471a645c0e49","date":1255900293,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = (PhrasePositions[]) m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3b2ceed5f2320db5cc371e0dd95622cda9a9a56a":["b3e493496c35fb4f17315b8827d1ba1ae1585554"],"b3e493496c35fb4f17315b8827d1ba1ae1585554":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ef82ff03e4016c705811b2658e81471a645c0e49":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["3b2ceed5f2320db5cc371e0dd95622cda9a9a56a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["ef82ff03e4016c705811b2658e81471a645c0e49"]},"commit2Childs":{"3b2ceed5f2320db5cc371e0dd95622cda9a9a56a":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"b3e493496c35fb4f17315b8827d1ba1ae1585554":["3b2ceed5f2320db5cc371e0dd95622cda9a9a56a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b3e493496c35fb4f17315b8827d1ba1ae1585554"],"ef82ff03e4016c705811b2658e81471a645c0e49":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["ef82ff03e4016c705811b2658e81471a645c0e49"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}