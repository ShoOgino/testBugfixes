{"path":"modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser#Clause(CharSequence).mjava","commits":[{"id":"4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1","date":1310612214,"type":1,"author":"Christopher John Male","isMerge":false,"pathNew":"modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser#Clause(CharSequence).mjava","pathOld":"lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser#Clause(CharSequence).mjava","sourceNew":"  final public QueryNode Clause(CharSequence field) throws ParseException {\n  QueryNode q;\n  Token fieldToken=null, boost=null;\n  boolean group = false;\n    if (jj_2_1(2)) {\n      fieldToken = jj_consume_token(TERM);\n      jj_consume_token(COLON);\n                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n    } else {\n      ;\n    }\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case QUOTED:\n    case TERM:\n    case REGEXPTERM:\n    case RANGEIN_START:\n    case RANGEEX_START:\n    case NUMBER:\n      q = Term(field);\n      break;\n    case LPAREN:\n      jj_consume_token(LPAREN);\n      q = Query(field);\n      jj_consume_token(RPAREN);\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case CARAT:\n        jj_consume_token(CARAT);\n        boost = jj_consume_token(NUMBER);\n        break;\n      default:\n        jj_la1[7] = jj_gen;\n        ;\n      }\n                                                                 group=true;\n      break;\n    default:\n      jj_la1[8] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n      if (boost != null) {\n                  float f = (float)1.0;\n                  try {\n                    f = Float.valueOf(boost.image).floatValue();\n                    // avoid boosting null queries, such as those caused by stop words\n                if (q != null) {\n                        q = new BoostQueryNode(q, f);\n                }\n                  } catch (Exception ignored) {\n                        /* Should this be handled somehow? (defaults to \"no boost\", if\n             * boost number is invalid)\n             */\n                  }\n      }\n      if (group) { q = new GroupQueryNode(q);}\n      {if (true) return q;}\n    throw new Error(\"Missing return statement in function\");\n  }\n\n","sourceOld":"  final public QueryNode Clause(CharSequence field) throws ParseException {\n  QueryNode q;\n  Token fieldToken=null, boost=null;\n  boolean group = false;\n    if (jj_2_1(2)) {\n      fieldToken = jj_consume_token(TERM);\n      jj_consume_token(COLON);\n                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n    } else {\n      ;\n    }\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case QUOTED:\n    case TERM:\n    case REGEXPTERM:\n    case RANGEIN_START:\n    case RANGEEX_START:\n    case NUMBER:\n      q = Term(field);\n      break;\n    case LPAREN:\n      jj_consume_token(LPAREN);\n      q = Query(field);\n      jj_consume_token(RPAREN);\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case CARAT:\n        jj_consume_token(CARAT);\n        boost = jj_consume_token(NUMBER);\n        break;\n      default:\n        jj_la1[7] = jj_gen;\n        ;\n      }\n                                                                 group=true;\n      break;\n    default:\n      jj_la1[8] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n      if (boost != null) {\n                  float f = (float)1.0;\n                  try {\n                    f = Float.valueOf(boost.image).floatValue();\n                    // avoid boosting null queries, such as those caused by stop words\n                if (q != null) {\n                        q = new BoostQueryNode(q, f);\n                }\n                  } catch (Exception ignored) {\n                        /* Should this be handled somehow? (defaults to \"no boost\", if\n             * boost number is invalid)\n             */\n                  }\n      }\n      if (group) { q = new GroupQueryNode(q);}\n      {if (true) return q;}\n    throw new Error(\"Missing return statement in function\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e91b7614171e0a6a82351457c2870d2a0124ba9a","date":1312225025,"type":3,"author":"Adriano Crestani Campos","isMerge":false,"pathNew":"modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser#Clause(CharSequence).mjava","pathOld":"modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser#Clause(CharSequence).mjava","sourceNew":"  final public QueryNode Clause(CharSequence field) throws ParseException {\n  QueryNode q;\n  Token fieldToken=null, boost=null, operator=null, term=null;\n  ParametricQueryNode qLower, qUpper;\n\n  boolean group = false;\n    if (jj_2_2(3)) {\n      fieldToken = jj_consume_token(TERM);\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case OP_COLON:\n      case OP_EQUAL:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_COLON:\n          jj_consume_token(OP_COLON);\n          break;\n        case OP_EQUAL:\n          jj_consume_token(OP_EQUAL);\n          break;\n        default:\n          jj_la1[7] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        q = Term(field);\n        break;\n      case OP_LESSTHAN:\n      case OP_LESSTHANEQ:\n      case OP_MORETHAN:\n      case OP_MORETHANEQ:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_LESSTHAN:\n          operator = jj_consume_token(OP_LESSTHAN);\n          break;\n        case OP_LESSTHANEQ:\n          operator = jj_consume_token(OP_LESSTHANEQ);\n          break;\n        case OP_MORETHAN:\n          operator = jj_consume_token(OP_MORETHAN);\n          break;\n        case OP_MORETHANEQ:\n          operator = jj_consume_token(OP_MORETHANEQ);\n          break;\n        default:\n          jj_la1[8] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                                                                                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case TERM:\n          term = jj_consume_token(TERM);\n          break;\n        case QUOTED:\n          term = jj_consume_token(QUOTED);\n          break;\n        case NUMBER:\n          term = jj_consume_token(NUMBER);\n          break;\n        default:\n          jj_la1[9] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        if (term.kind == QUOTED) {\n            term.image = term.image.substring(1, term.image.length()-1);\n        }\n        switch (operator.kind) {\n            case OP_LESSTHAN:\n                qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE,\n                                         \"*\", term.beginColumn, term.endColumn);\n                qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LT,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                break;\n            case OP_LESSTHANEQ:\n                qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE,\n                                         \"*\", term.beginColumn, term.endColumn);\n                qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHAN:\n                qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GT,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHANEQ:\n                qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            default:\n                {if (true) throw new Error(\"Unhandled case: operator=\"+operator.toString());}\n        }\n        q = new ParametricRangeQueryNode(qLower, qUpper);\n        break;\n      default:\n        jj_la1[10] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case LPAREN:\n      case QUOTED:\n      case TERM:\n      case REGEXPTERM:\n      case RANGEIN_START:\n      case RANGEEX_START:\n      case NUMBER:\n        if (jj_2_1(2)) {\n          fieldToken = jj_consume_token(TERM);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case OP_COLON:\n            jj_consume_token(OP_COLON);\n            break;\n          case OP_EQUAL:\n            jj_consume_token(OP_EQUAL);\n            break;\n          default:\n            jj_la1[11] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n          }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        } else {\n          ;\n        }\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case QUOTED:\n        case TERM:\n        case REGEXPTERM:\n        case RANGEIN_START:\n        case RANGEEX_START:\n        case NUMBER:\n          q = Term(field);\n          break;\n        case LPAREN:\n          jj_consume_token(LPAREN);\n          q = Query(field);\n          jj_consume_token(RPAREN);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case CARAT:\n            jj_consume_token(CARAT);\n            boost = jj_consume_token(NUMBER);\n            break;\n          default:\n            jj_la1[12] = jj_gen;\n            ;\n          }\n                                                                 group=true;\n          break;\n        default:\n          jj_la1[13] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n      default:\n        jj_la1[14] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n      if (boost != null) {\n                  float f = (float)1.0;\n                  try {\n                    f = Float.valueOf(boost.image).floatValue();\n                    // avoid boosting null queries, such as those caused by stop words\n                if (q != null) {\n                        q = new BoostQueryNode(q, f);\n                }\n                  } catch (Exception ignored) {\n                        /* Should this be handled somehow? (defaults to \"no boost\", if\n             * boost number is invalid)\n             */\n                  }\n      }\n      if (group) { q = new GroupQueryNode(q);}\n      {if (true) return q;}\n    throw new Error(\"Missing return statement in function\");\n  }\n\n","sourceOld":"  final public QueryNode Clause(CharSequence field) throws ParseException {\n  QueryNode q;\n  Token fieldToken=null, boost=null;\n  boolean group = false;\n    if (jj_2_1(2)) {\n      fieldToken = jj_consume_token(TERM);\n      jj_consume_token(COLON);\n                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n    } else {\n      ;\n    }\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case QUOTED:\n    case TERM:\n    case REGEXPTERM:\n    case RANGEIN_START:\n    case RANGEEX_START:\n    case NUMBER:\n      q = Term(field);\n      break;\n    case LPAREN:\n      jj_consume_token(LPAREN);\n      q = Query(field);\n      jj_consume_token(RPAREN);\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case CARAT:\n        jj_consume_token(CARAT);\n        boost = jj_consume_token(NUMBER);\n        break;\n      default:\n        jj_la1[7] = jj_gen;\n        ;\n      }\n                                                                 group=true;\n      break;\n    default:\n      jj_la1[8] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n      if (boost != null) {\n                  float f = (float)1.0;\n                  try {\n                    f = Float.valueOf(boost.image).floatValue();\n                    // avoid boosting null queries, such as those caused by stop words\n                if (q != null) {\n                        q = new BoostQueryNode(q, f);\n                }\n                  } catch (Exception ignored) {\n                        /* Should this be handled somehow? (defaults to \"no boost\", if\n             * boost number is invalid)\n             */\n                  }\n      }\n      if (group) { q = new GroupQueryNode(q);}\n      {if (true) return q;}\n    throw new Error(\"Missing return statement in function\");\n  }\n\n","bugFix":["f15bad88fcdb5cb75a8cd9f5dea23a87a3b04b6b","d94d6afa51157e490fc169e192a154ffc4cdad0b"],"bugIntro":["383e6510a01a27ea3d860472f33049ed2c766e15"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aff8a13a1bad7d9e3a7180e3f64825fa93b1ed25","date":1315500470,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser#Clause(CharSequence).mjava","pathOld":"modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser#Clause(CharSequence).mjava","sourceNew":"  final public QueryNode Clause(CharSequence field) throws ParseException {\n  QueryNode q;\n  Token fieldToken=null, boost=null, operator=null, term=null;\n  FieldQueryNode qLower, qUpper;\n  boolean lowerInclusive, upperInclusive;\n\n  boolean group = false;\n    if (jj_2_2(3)) {\n      fieldToken = jj_consume_token(TERM);\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case OP_COLON:\n      case OP_EQUAL:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_COLON:\n          jj_consume_token(OP_COLON);\n          break;\n        case OP_EQUAL:\n          jj_consume_token(OP_EQUAL);\n          break;\n        default:\n          jj_la1[7] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        q = Term(field);\n        break;\n      case OP_LESSTHAN:\n      case OP_LESSTHANEQ:\n      case OP_MORETHAN:\n      case OP_MORETHANEQ:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_LESSTHAN:\n          operator = jj_consume_token(OP_LESSTHAN);\n          break;\n        case OP_LESSTHANEQ:\n          operator = jj_consume_token(OP_LESSTHANEQ);\n          break;\n        case OP_MORETHAN:\n          operator = jj_consume_token(OP_MORETHAN);\n          break;\n        case OP_MORETHANEQ:\n          operator = jj_consume_token(OP_MORETHANEQ);\n          break;\n        default:\n          jj_la1[8] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                                                                                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case TERM:\n          term = jj_consume_token(TERM);\n          break;\n        case QUOTED:\n          term = jj_consume_token(QUOTED);\n          break;\n        case NUMBER:\n          term = jj_consume_token(NUMBER);\n          break;\n        default:\n          jj_la1[9] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        if (term.kind == QUOTED) {\n            term.image = term.image.substring(1, term.image.length()-1);\n        }\n        switch (operator.kind) {\n            case OP_LESSTHAN:\n                lowerInclusive = true;\n                upperInclusive = false;\n\n                qLower = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                        qUpper = new FieldQueryNode(field,\n                                 EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n\n                break;\n            case OP_LESSTHANEQ:\n                lowerInclusive = true;\n                upperInclusive = true;\n\n                qLower = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                qUpper = new FieldQueryNode(field,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHAN:\n                lowerInclusive = false;\n                upperInclusive = true;\n\n                qLower = new FieldQueryNode(field,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHANEQ:\n                lowerInclusive = true;\n                upperInclusive = true;\n\n                qLower = new FieldQueryNode(field,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            default:\n                {if (true) throw new Error(\"Unhandled case: operator=\"+operator.toString());}\n        }\n        q = new TermRangeQueryNode(qLower, qUpper, lowerInclusive, upperInclusive);\n        break;\n      default:\n        jj_la1[10] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case LPAREN:\n      case QUOTED:\n      case TERM:\n      case REGEXPTERM:\n      case RANGEIN_START:\n      case RANGEEX_START:\n      case NUMBER:\n        if (jj_2_1(2)) {\n          fieldToken = jj_consume_token(TERM);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case OP_COLON:\n            jj_consume_token(OP_COLON);\n            break;\n          case OP_EQUAL:\n            jj_consume_token(OP_EQUAL);\n            break;\n          default:\n            jj_la1[11] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n          }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        } else {\n          ;\n        }\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case QUOTED:\n        case TERM:\n        case REGEXPTERM:\n        case RANGEIN_START:\n        case RANGEEX_START:\n        case NUMBER:\n          q = Term(field);\n          break;\n        case LPAREN:\n          jj_consume_token(LPAREN);\n          q = Query(field);\n          jj_consume_token(RPAREN);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case CARAT:\n            jj_consume_token(CARAT);\n            boost = jj_consume_token(NUMBER);\n            break;\n          default:\n            jj_la1[12] = jj_gen;\n            ;\n          }\n                                                                 group=true;\n          break;\n        default:\n          jj_la1[13] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n      default:\n        jj_la1[14] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n      if (boost != null) {\n                  float f = (float)1.0;\n                  try {\n                    f = Float.valueOf(boost.image).floatValue();\n                    // avoid boosting null queries, such as those caused by stop words\n                if (q != null) {\n                        q = new BoostQueryNode(q, f);\n                }\n                  } catch (Exception ignored) {\n                        /* Should this be handled somehow? (defaults to \"no boost\", if\n             * boost number is invalid)\n             */\n                  }\n      }\n      if (group) { q = new GroupQueryNode(q);}\n      {if (true) return q;}\n    throw new Error(\"Missing return statement in function\");\n  }\n\n","sourceOld":"  final public QueryNode Clause(CharSequence field) throws ParseException {\n  QueryNode q;\n  Token fieldToken=null, boost=null, operator=null, term=null;\n  ParametricQueryNode qLower, qUpper;\n\n  boolean group = false;\n    if (jj_2_2(3)) {\n      fieldToken = jj_consume_token(TERM);\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case OP_COLON:\n      case OP_EQUAL:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_COLON:\n          jj_consume_token(OP_COLON);\n          break;\n        case OP_EQUAL:\n          jj_consume_token(OP_EQUAL);\n          break;\n        default:\n          jj_la1[7] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        q = Term(field);\n        break;\n      case OP_LESSTHAN:\n      case OP_LESSTHANEQ:\n      case OP_MORETHAN:\n      case OP_MORETHANEQ:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_LESSTHAN:\n          operator = jj_consume_token(OP_LESSTHAN);\n          break;\n        case OP_LESSTHANEQ:\n          operator = jj_consume_token(OP_LESSTHANEQ);\n          break;\n        case OP_MORETHAN:\n          operator = jj_consume_token(OP_MORETHAN);\n          break;\n        case OP_MORETHANEQ:\n          operator = jj_consume_token(OP_MORETHANEQ);\n          break;\n        default:\n          jj_la1[8] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                                                                                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case TERM:\n          term = jj_consume_token(TERM);\n          break;\n        case QUOTED:\n          term = jj_consume_token(QUOTED);\n          break;\n        case NUMBER:\n          term = jj_consume_token(NUMBER);\n          break;\n        default:\n          jj_la1[9] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        if (term.kind == QUOTED) {\n            term.image = term.image.substring(1, term.image.length()-1);\n        }\n        switch (operator.kind) {\n            case OP_LESSTHAN:\n                qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE,\n                                         \"*\", term.beginColumn, term.endColumn);\n                qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LT,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                break;\n            case OP_LESSTHANEQ:\n                qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE,\n                                         \"*\", term.beginColumn, term.endColumn);\n                qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHAN:\n                qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GT,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHANEQ:\n                qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            default:\n                {if (true) throw new Error(\"Unhandled case: operator=\"+operator.toString());}\n        }\n        q = new ParametricRangeQueryNode(qLower, qUpper);\n        break;\n      default:\n        jj_la1[10] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case LPAREN:\n      case QUOTED:\n      case TERM:\n      case REGEXPTERM:\n      case RANGEIN_START:\n      case RANGEEX_START:\n      case NUMBER:\n        if (jj_2_1(2)) {\n          fieldToken = jj_consume_token(TERM);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case OP_COLON:\n            jj_consume_token(OP_COLON);\n            break;\n          case OP_EQUAL:\n            jj_consume_token(OP_EQUAL);\n            break;\n          default:\n            jj_la1[11] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n          }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        } else {\n          ;\n        }\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case QUOTED:\n        case TERM:\n        case REGEXPTERM:\n        case RANGEIN_START:\n        case RANGEEX_START:\n        case NUMBER:\n          q = Term(field);\n          break;\n        case LPAREN:\n          jj_consume_token(LPAREN);\n          q = Query(field);\n          jj_consume_token(RPAREN);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case CARAT:\n            jj_consume_token(CARAT);\n            boost = jj_consume_token(NUMBER);\n            break;\n          default:\n            jj_la1[12] = jj_gen;\n            ;\n          }\n                                                                 group=true;\n          break;\n        default:\n          jj_la1[13] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n      default:\n        jj_la1[14] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n      if (boost != null) {\n                  float f = (float)1.0;\n                  try {\n                    f = Float.valueOf(boost.image).floatValue();\n                    // avoid boosting null queries, such as those caused by stop words\n                if (q != null) {\n                        q = new BoostQueryNode(q, f);\n                }\n                  } catch (Exception ignored) {\n                        /* Should this be handled somehow? (defaults to \"no boost\", if\n             * boost number is invalid)\n             */\n                  }\n      }\n      if (group) { q = new GroupQueryNode(q);}\n      {if (true) return q;}\n    throw new Error(\"Missing return statement in function\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser#Clause(CharSequence).mjava","pathOld":"modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser#Clause(CharSequence).mjava","sourceNew":"  final public QueryNode Clause(CharSequence field) throws ParseException {\n  QueryNode q;\n  Token fieldToken=null, boost=null, operator=null, term=null;\n  FieldQueryNode qLower, qUpper;\n  boolean lowerInclusive, upperInclusive;\n\n  boolean group = false;\n    if (jj_2_2(3)) {\n      fieldToken = jj_consume_token(TERM);\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case OP_COLON:\n      case OP_EQUAL:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_COLON:\n          jj_consume_token(OP_COLON);\n          break;\n        case OP_EQUAL:\n          jj_consume_token(OP_EQUAL);\n          break;\n        default:\n          jj_la1[7] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        q = Term(field);\n        break;\n      case OP_LESSTHAN:\n      case OP_LESSTHANEQ:\n      case OP_MORETHAN:\n      case OP_MORETHANEQ:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_LESSTHAN:\n          operator = jj_consume_token(OP_LESSTHAN);\n          break;\n        case OP_LESSTHANEQ:\n          operator = jj_consume_token(OP_LESSTHANEQ);\n          break;\n        case OP_MORETHAN:\n          operator = jj_consume_token(OP_MORETHAN);\n          break;\n        case OP_MORETHANEQ:\n          operator = jj_consume_token(OP_MORETHANEQ);\n          break;\n        default:\n          jj_la1[8] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                                                                                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case TERM:\n          term = jj_consume_token(TERM);\n          break;\n        case QUOTED:\n          term = jj_consume_token(QUOTED);\n          break;\n        case NUMBER:\n          term = jj_consume_token(NUMBER);\n          break;\n        default:\n          jj_la1[9] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        if (term.kind == QUOTED) {\n            term.image = term.image.substring(1, term.image.length()-1);\n        }\n        switch (operator.kind) {\n            case OP_LESSTHAN:\n                lowerInclusive = true;\n                upperInclusive = false;\n\n                qLower = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                        qUpper = new FieldQueryNode(field,\n                                 EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n\n                break;\n            case OP_LESSTHANEQ:\n                lowerInclusive = true;\n                upperInclusive = true;\n\n                qLower = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                qUpper = new FieldQueryNode(field,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHAN:\n                lowerInclusive = false;\n                upperInclusive = true;\n\n                qLower = new FieldQueryNode(field,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHANEQ:\n                lowerInclusive = true;\n                upperInclusive = true;\n\n                qLower = new FieldQueryNode(field,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            default:\n                {if (true) throw new Error(\"Unhandled case: operator=\"+operator.toString());}\n        }\n        q = new TermRangeQueryNode(qLower, qUpper, lowerInclusive, upperInclusive);\n        break;\n      default:\n        jj_la1[10] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case LPAREN:\n      case QUOTED:\n      case TERM:\n      case REGEXPTERM:\n      case RANGEIN_START:\n      case RANGEEX_START:\n      case NUMBER:\n        if (jj_2_1(2)) {\n          fieldToken = jj_consume_token(TERM);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case OP_COLON:\n            jj_consume_token(OP_COLON);\n            break;\n          case OP_EQUAL:\n            jj_consume_token(OP_EQUAL);\n            break;\n          default:\n            jj_la1[11] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n          }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        } else {\n          ;\n        }\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case QUOTED:\n        case TERM:\n        case REGEXPTERM:\n        case RANGEIN_START:\n        case RANGEEX_START:\n        case NUMBER:\n          q = Term(field);\n          break;\n        case LPAREN:\n          jj_consume_token(LPAREN);\n          q = Query(field);\n          jj_consume_token(RPAREN);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case CARAT:\n            jj_consume_token(CARAT);\n            boost = jj_consume_token(NUMBER);\n            break;\n          default:\n            jj_la1[12] = jj_gen;\n            ;\n          }\n                                                                 group=true;\n          break;\n        default:\n          jj_la1[13] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n      default:\n        jj_la1[14] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n      if (boost != null) {\n                  float f = (float)1.0;\n                  try {\n                    f = Float.valueOf(boost.image).floatValue();\n                    // avoid boosting null queries, such as those caused by stop words\n                if (q != null) {\n                        q = new BoostQueryNode(q, f);\n                }\n                  } catch (Exception ignored) {\n                        /* Should this be handled somehow? (defaults to \"no boost\", if\n             * boost number is invalid)\n             */\n                  }\n      }\n      if (group) { q = new GroupQueryNode(q);}\n      {if (true) return q;}\n    throw new Error(\"Missing return statement in function\");\n  }\n\n","sourceOld":"  final public QueryNode Clause(CharSequence field) throws ParseException {\n  QueryNode q;\n  Token fieldToken=null, boost=null, operator=null, term=null;\n  FieldQueryNode qLower, qUpper;\n  boolean lowerInclusive, upperInclusive;\n\n  boolean group = false;\n    if (jj_2_2(3)) {\n      fieldToken = jj_consume_token(TERM);\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case OP_COLON:\n      case OP_EQUAL:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_COLON:\n          jj_consume_token(OP_COLON);\n          break;\n        case OP_EQUAL:\n          jj_consume_token(OP_EQUAL);\n          break;\n        default:\n          jj_la1[7] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        q = Term(field);\n        break;\n      case OP_LESSTHAN:\n      case OP_LESSTHANEQ:\n      case OP_MORETHAN:\n      case OP_MORETHANEQ:\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case OP_LESSTHAN:\n          operator = jj_consume_token(OP_LESSTHAN);\n          break;\n        case OP_LESSTHANEQ:\n          operator = jj_consume_token(OP_LESSTHANEQ);\n          break;\n        case OP_MORETHAN:\n          operator = jj_consume_token(OP_MORETHAN);\n          break;\n        case OP_MORETHANEQ:\n          operator = jj_consume_token(OP_MORETHANEQ);\n          break;\n        default:\n          jj_la1[8] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n                                                                                                               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case TERM:\n          term = jj_consume_token(TERM);\n          break;\n        case QUOTED:\n          term = jj_consume_token(QUOTED);\n          break;\n        case NUMBER:\n          term = jj_consume_token(NUMBER);\n          break;\n        default:\n          jj_la1[9] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        if (term.kind == QUOTED) {\n            term.image = term.image.substring(1, term.image.length()-1);\n        }\n        switch (operator.kind) {\n            case OP_LESSTHAN:\n                lowerInclusive = true;\n                upperInclusive = false;\n\n                qLower = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                        qUpper = new FieldQueryNode(field,\n                                 EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n\n                break;\n            case OP_LESSTHANEQ:\n                lowerInclusive = true;\n                upperInclusive = true;\n\n                qLower = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                qUpper = new FieldQueryNode(field,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHAN:\n                lowerInclusive = false;\n                upperInclusive = true;\n\n                qLower = new FieldQueryNode(field,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            case OP_MORETHANEQ:\n                lowerInclusive = true;\n                upperInclusive = true;\n\n                qLower = new FieldQueryNode(field,\n                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);\n                qUpper = new FieldQueryNode(field,\n                                         \"*\", term.beginColumn, term.endColumn);\n                break;\n            default:\n                {if (true) throw new Error(\"Unhandled case: operator=\"+operator.toString());}\n        }\n        q = new TermRangeQueryNode(qLower, qUpper, lowerInclusive, upperInclusive);\n        break;\n      default:\n        jj_la1[10] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case LPAREN:\n      case QUOTED:\n      case TERM:\n      case REGEXPTERM:\n      case RANGEIN_START:\n      case RANGEEX_START:\n      case NUMBER:\n        if (jj_2_1(2)) {\n          fieldToken = jj_consume_token(TERM);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case OP_COLON:\n            jj_consume_token(OP_COLON);\n            break;\n          case OP_EQUAL:\n            jj_consume_token(OP_EQUAL);\n            break;\n          default:\n            jj_la1[11] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n          }\n                                 field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);\n        } else {\n          ;\n        }\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case QUOTED:\n        case TERM:\n        case REGEXPTERM:\n        case RANGEIN_START:\n        case RANGEEX_START:\n        case NUMBER:\n          q = Term(field);\n          break;\n        case LPAREN:\n          jj_consume_token(LPAREN);\n          q = Query(field);\n          jj_consume_token(RPAREN);\n          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n          case CARAT:\n            jj_consume_token(CARAT);\n            boost = jj_consume_token(NUMBER);\n            break;\n          default:\n            jj_la1[12] = jj_gen;\n            ;\n          }\n                                                                 group=true;\n          break;\n        default:\n          jj_la1[13] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n      default:\n        jj_la1[14] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n      if (boost != null) {\n                  float f = (float)1.0;\n                  try {\n                    f = Float.valueOf(boost.image).floatValue();\n                    // avoid boosting null queries, such as those caused by stop words\n                if (q != null) {\n                        q = new BoostQueryNode(q, f);\n                }\n                  } catch (Exception ignored) {\n                        /* Should this be handled somehow? (defaults to \"no boost\", if\n             * boost number is invalid)\n             */\n                  }\n      }\n      if (group) { q = new GroupQueryNode(q);}\n      {if (true) return q;}\n    throw new Error(\"Missing return statement in function\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["aff8a13a1bad7d9e3a7180e3f64825fa93b1ed25"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"aff8a13a1bad7d9e3a7180e3f64825fa93b1ed25":["e91b7614171e0a6a82351457c2870d2a0124ba9a"],"e91b7614171e0a6a82351457c2870d2a0124ba9a":["4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1":["e91b7614171e0a6a82351457c2870d2a0124ba9a"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1"],"aff8a13a1bad7d9e3a7180e3f64825fa93b1ed25":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"e91b7614171e0a6a82351457c2870d2a0124ba9a":["aff8a13a1bad7d9e3a7180e3f64825fa93b1ed25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}