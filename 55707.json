{"path":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","commits":[{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#doTest().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We cannot validate distributed grouping with scoring as first sort. since there is no global idf. We can check if no errors occur\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We cannot validate distributed grouping with scoring as first sort. since there is no global idf. We can check if no errors occur\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f932d2f40e796e652d4b3f45ad3761dcc37b01f0","date":1433851536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We cannot validate distributed grouping with scoring as first sort. since there is no global idf. We can check if no errors occur\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We cannot validate distributed grouping with scoring as first sort. since there is no global idf. We can check if no errors occur\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e74728bf33a99680da79803cdb3017f609d7dd17","date":1433854700,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We cannot validate distributed grouping with scoring as first sort. since there is no global idf. We can check if no errors occur\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We cannot validate distributed grouping with scoring as first sort. since there is no global idf. We can check if no errors occur\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10f1ec454f37e3f7a5de3b1a04e77d0158001bb8","date":1433930546,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We cannot validate distributed grouping with scoring as first sort. since there is no global idf. We can check if no errors occur\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We cannot validate distributed grouping with scoring as first sort. since there is no global idf. We can check if no errors occur\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","date":1448513807,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We cannot validate distributed grouping with scoring as first sort. since there is no global idf. We can check if no errors occur\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":["d423443db06bfcac81733aafcce04ee491880cc7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8caae639c4263eb96d3c071f3b1b3b4cf6a7a25e","date":1464736344,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", 10,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":["286e1dbf267cac3961c3fc116b9069797ad7d1c2","d423443db06bfcac81733aafcce04ee491880cc7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b8ee93140fd0efef7e101786e3ed5160a700b5f","date":1464820111,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", 10,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","date":1464821470,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", 10,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", 10,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d423443db06bfcac81733aafcce04ee491880cc7","date":1477501011,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", 10,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","0414a20d73ebe5c96a6e7e70e337083ec37f01fd","ccc08aa684aee4964baee0644a6ba047bfd70829","612521de57bdf68711c68b6d8565e4a80ca0d7f6","af20870f6eab3807c968eec0b24e0c4358d0c1e5","79c2f883e7a3be9dc62d29014544d769df774aae","8caae639c4263eb96d3c071f3b1b3b4cf6a7a25e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", 10,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", 10,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a144790859eb303122988cd315215ff30f449d2","date":1493938430,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a71f63026529f3c1f03cfdd664910873ab2369ae","date":1497543264,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), 22, docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), 21, docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"286e1dbf267cac3961c3fc116b9069797ad7d1c2","date":1556472718,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    \n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":["27270b721a573cf4b774ce70b062078ef490388e","ccc08aa684aee4964baee0644a6ba047bfd70829","8caae639c4263eb96d3c071f3b1b3b4cf6a7a25e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1313c74c6d619d0d98d1284bc17513c9a4b40345","date":1562035273,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertTrue(exception.getMessage().contains(\"'group.offset' parameter cannot be negative\"));\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    handle.put(t1 + \":this_will_never_match\", SKIP); // :TODO: SOLR-4181\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"053bf01497af10659a59b6ce2f85e4be8cdc3b9e","date":1564977464,"type":3,"author":"Diego","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertTrue(exception.getMessage().contains(\"'group.offset' parameter cannot be negative\"));\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertTrue(exception.getMessage().contains(\"'group.offset' parameter cannot be negative\"));\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","date":1565097295,"type":3,"author":"Jan Hydahl","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertTrue(exception.getMessage().contains(\"'group.offset' parameter cannot be negative\"));\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6069837581413356deecd17ffb9cd92ff3bc7b44","date":1567533718,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIP);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    \n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // grouping shouldn't care if there are multiple fl params, or what order the fl field names are in\n    variantQuery(params(\"q\", \"*:*\",\n                        \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", \"10\",\n                        \"sort\", i1 + \" asc, id asc\")\n                 , params(\"fl\", \"id,\" + i1dv)\n                 , params(\"fl\", i1dv + \",id\")\n                 , params(\"fl\", \"id\", \"fl\", i1dv)\n                 , params(\"fl\", i1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", \"id,\" + s1dv + \",\" + tdate_a)\n                 , params(\"fl\", \"id\", \"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", s1dv + \",\" + tdate_a)\n                 , params(\"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv)\n                 );\n    variantQuery(params(\"q\", \"{!func}id_i1\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                        \"sort\", tlong+\" asc, id desc\")\n                 , params(\"fl\", t1 + \",score,\" + i1dv)\n                 , params(\"fl\", t1, \"fl\", \"score\", \"fl\", i1dv)\n                 , params(\"fl\", \"score\", \"fl\", t1, \"fl\", i1dv)\n                 );\n                             \n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    for (boolean withFL : new boolean[] {true, false}) {\n      if (withFL) {\n        rsp = variantQuery(params(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                                  \"rows\", \"100\",\n                                  \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                                  \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\")\n                           , params(\"fl\", tlong + \",id,\" + i1)\n                           , params(\"fl\", tlong, \"fl\", \"id\", \"fl\", i1)\n                           , params(\"fl\", \"id\", \"fl\", i1, \"fl\", tlong)\n                           );\n      } else {\n        // special check: same query, but empty fl...\n        rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                    \"rows\", \"100\",\n                    \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                    \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\");\n      }\n      nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n      nl = (NamedList<?>) nl.get(i1);\n      assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n      assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n      nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n      assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n      SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n      assertEquals(docs.toString(), 5, docs.getNumFound());\n      //\n      assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 732L, docs.get(0).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(0).getFirstValue(i1));\n      //\n      assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 632L, docs.get(4).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(4).getFirstValue(i1));\n      //\n      if (withFL == false) {\n        // exact number varies based on test randomization, but there should always be at least the 8\n        // explicitly indexed in these 2 docs...\n        assertTrue(docs.toString(), 8 <= docs.get(0).getFieldNames().size());\n        assertTrue(docs.toString(), 8 <= docs.get(4).getFieldNames().size());\n      }\n    }\n    \n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n    \n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n                \"group.field\", i1, \"group.limit\", -1,\n                \"sort\", tlong+\" asc\",\n                \"group.sort\", oddField+\" asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(i1);\n    assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 5, docs.getNumFound());\n    assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n    assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n\n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n\n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38bbc20b9f0152f78a6f08c072856630e9b89fa1","date":1571567239,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIP);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    \n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-9802\n    query(\"q\", \"*:*\", \"group\", \"true\", \"group.field\", tdate_a, \"sort\", i1 + \" asc, id asc\", \"fl\", \"id\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // grouping shouldn't care if there are multiple fl params, or what order the fl field names are in\n    variantQuery(params(\"q\", \"*:*\",\n                        \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", \"10\",\n                        \"sort\", i1 + \" asc, id asc\")\n                 , params(\"fl\", \"id,\" + i1dv)\n                 , params(\"fl\", i1dv + \",id\")\n                 , params(\"fl\", \"id\", \"fl\", i1dv)\n                 , params(\"fl\", i1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", \"id,\" + s1dv + \",\" + tdate_a)\n                 , params(\"fl\", \"id\", \"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", s1dv + \",\" + tdate_a)\n                 , params(\"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv)\n                 );\n    variantQuery(params(\"q\", \"{!func}id_i1\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                        \"sort\", tlong+\" asc, id desc\")\n                 , params(\"fl\", t1 + \",score,\" + i1dv)\n                 , params(\"fl\", t1, \"fl\", \"score\", \"fl\", i1dv)\n                 , params(\"fl\", \"score\", \"fl\", t1, \"fl\", i1dv)\n                 );\n                             \n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    for (boolean withFL : new boolean[] {true, false}) {\n      if (withFL) {\n        rsp = variantQuery(params(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                                  \"rows\", \"100\",\n                                  \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                                  \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\")\n                           , params(\"fl\", tlong + \",id,\" + i1)\n                           , params(\"fl\", tlong, \"fl\", \"id\", \"fl\", i1)\n                           , params(\"fl\", \"id\", \"fl\", i1, \"fl\", tlong)\n                           );\n      } else {\n        // special check: same query, but empty fl...\n        rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                    \"rows\", \"100\",\n                    \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                    \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\");\n      }\n      nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n      nl = (NamedList<?>) nl.get(i1);\n      assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n      assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n      nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n      assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n      SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n      assertEquals(docs.toString(), 5, docs.getNumFound());\n      //\n      assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 732L, docs.get(0).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(0).getFirstValue(i1));\n      //\n      assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 632L, docs.get(4).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(4).getFirstValue(i1));\n      //\n      if (withFL == false) {\n        // exact number varies based on test randomization, but there should always be at least the 8\n        // explicitly indexed in these 2 docs...\n        assertTrue(docs.toString(), 8 <= docs.get(0).getFieldNames().size());\n        assertTrue(docs.toString(), 8 <= docs.get(4).getFieldNames().size());\n      }\n    }\n    \n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n    \n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIP);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    \n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // grouping shouldn't care if there are multiple fl params, or what order the fl field names are in\n    variantQuery(params(\"q\", \"*:*\",\n                        \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", \"10\",\n                        \"sort\", i1 + \" asc, id asc\")\n                 , params(\"fl\", \"id,\" + i1dv)\n                 , params(\"fl\", i1dv + \",id\")\n                 , params(\"fl\", \"id\", \"fl\", i1dv)\n                 , params(\"fl\", i1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", \"id,\" + s1dv + \",\" + tdate_a)\n                 , params(\"fl\", \"id\", \"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", s1dv + \",\" + tdate_a)\n                 , params(\"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv)\n                 );\n    variantQuery(params(\"q\", \"{!func}id_i1\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                        \"sort\", tlong+\" asc, id desc\")\n                 , params(\"fl\", t1 + \",score,\" + i1dv)\n                 , params(\"fl\", t1, \"fl\", \"score\", \"fl\", i1dv)\n                 , params(\"fl\", \"score\", \"fl\", t1, \"fl\", i1dv)\n                 );\n                             \n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    for (boolean withFL : new boolean[] {true, false}) {\n      if (withFL) {\n        rsp = variantQuery(params(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                                  \"rows\", \"100\",\n                                  \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                                  \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\")\n                           , params(\"fl\", tlong + \",id,\" + i1)\n                           , params(\"fl\", tlong, \"fl\", \"id\", \"fl\", i1)\n                           , params(\"fl\", \"id\", \"fl\", i1, \"fl\", tlong)\n                           );\n      } else {\n        // special check: same query, but empty fl...\n        rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                    \"rows\", \"100\",\n                    \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                    \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\");\n      }\n      nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n      nl = (NamedList<?>) nl.get(i1);\n      assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n      assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n      nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n      assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n      SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n      assertEquals(docs.toString(), 5, docs.getNumFound());\n      //\n      assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 732L, docs.get(0).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(0).getFirstValue(i1));\n      //\n      assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 632L, docs.get(4).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(4).getFirstValue(i1));\n      //\n      if (withFL == false) {\n        // exact number varies based on test randomization, but there should always be at least the 8\n        // explicitly indexed in these 2 docs...\n        assertTrue(docs.toString(), 8 <= docs.get(0).getFieldNames().size());\n        assertTrue(docs.toString(), 8 <= docs.get(4).getFieldNames().size());\n      }\n    }\n    \n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n    \n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2761c3f53e738e28c17c75124aa305e4e63c989d","date":1572337563,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIP);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    \n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-9802\n    query(\"q\", \"*:*\", \"group\", \"true\", \"group.field\", tdate_a, \"sort\", i1 + \" asc, id asc\", \"fl\", \"id\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id,score\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id,score\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id,score\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // grouping shouldn't care if there are multiple fl params, or what order the fl field names are in\n    variantQuery(params(\"q\", \"*:*\",\n                        \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", \"10\",\n                        \"sort\", i1 + \" asc, id asc\")\n                 , params(\"fl\", \"id,\" + i1dv)\n                 , params(\"fl\", i1dv + \",id\")\n                 , params(\"fl\", \"id\", \"fl\", i1dv)\n                 , params(\"fl\", i1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", \"id,\" + s1dv + \",\" + tdate_a)\n                 , params(\"fl\", \"id\", \"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", s1dv + \",\" + tdate_a)\n                 , params(\"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv)\n                 );\n    variantQuery(params(\"q\", \"{!func}id_i1\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                        \"sort\", tlong+\" asc, id desc\")\n                 , params(\"fl\", t1 + \",score,\" + i1dv)\n                 , params(\"fl\", t1, \"fl\", \"score\", \"fl\", i1dv)\n                 , params(\"fl\", \"score\", \"fl\", t1, \"fl\", i1dv)\n                 );\n                             \n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    for (boolean withFL : new boolean[] {true, false}) {\n      if (withFL) {\n        rsp = variantQuery(params(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                                  \"rows\", \"100\",\n                                  \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                                  \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\")\n                           , params(\"fl\", tlong + \",id,\" + i1)\n                           , params(\"fl\", tlong, \"fl\", \"id\", \"fl\", i1)\n                           , params(\"fl\", \"id\", \"fl\", i1, \"fl\", tlong)\n                           );\n      } else {\n        // special check: same query, but empty fl...\n        rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                    \"rows\", \"100\",\n                    \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                    \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\");\n      }\n      nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n      nl = (NamedList<?>) nl.get(i1);\n      assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n      assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n      nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n      assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n      SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n      assertEquals(docs.toString(), 5, docs.getNumFound());\n      //\n      assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 732L, docs.get(0).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(0).getFirstValue(i1));\n      //\n      assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 632L, docs.get(4).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(4).getFirstValue(i1));\n      //\n      if (withFL == false) {\n        // exact number varies based on test randomization, but there should always be at least the 8\n        // explicitly indexed in these 2 docs...\n        assertTrue(docs.toString(), 8 <= docs.get(0).getFieldNames().size());\n        assertTrue(docs.toString(), 8 <= docs.get(4).getFieldNames().size());\n      }\n    }\n    \n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n    \n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIP);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    \n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-9802\n    query(\"q\", \"*:*\", \"group\", \"true\", \"group.field\", tdate_a, \"sort\", i1 + \" asc, id asc\", \"fl\", \"id\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    // grouping shouldn't care if there are multiple fl params, or what order the fl field names are in\n    variantQuery(params(\"q\", \"*:*\",\n                        \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", \"10\",\n                        \"sort\", i1 + \" asc, id asc\")\n                 , params(\"fl\", \"id,\" + i1dv)\n                 , params(\"fl\", i1dv + \",id\")\n                 , params(\"fl\", \"id\", \"fl\", i1dv)\n                 , params(\"fl\", i1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", \"id,\" + s1dv + \",\" + tdate_a)\n                 , params(\"fl\", \"id\", \"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", s1dv + \",\" + tdate_a)\n                 , params(\"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv)\n                 );\n    variantQuery(params(\"q\", \"{!func}id_i1\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                        \"sort\", tlong+\" asc, id desc\")\n                 , params(\"fl\", t1 + \",score,\" + i1dv)\n                 , params(\"fl\", t1, \"fl\", \"score\", \"fl\", i1dv)\n                 , params(\"fl\", \"score\", \"fl\", t1, \"fl\", i1dv)\n                 );\n                             \n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    for (boolean withFL : new boolean[] {true, false}) {\n      if (withFL) {\n        rsp = variantQuery(params(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                                  \"rows\", \"100\",\n                                  \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                                  \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\")\n                           , params(\"fl\", tlong + \",id,\" + i1)\n                           , params(\"fl\", tlong, \"fl\", \"id\", \"fl\", i1)\n                           , params(\"fl\", \"id\", \"fl\", i1, \"fl\", tlong)\n                           );\n      } else {\n        // special check: same query, but empty fl...\n        rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                    \"rows\", \"100\",\n                    \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                    \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\");\n      }\n      nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n      nl = (NamedList<?>) nl.get(i1);\n      assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n      assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n      nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n      assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n      SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n      assertEquals(docs.toString(), 5, docs.getNumFound());\n      //\n      assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 732L, docs.get(0).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(0).getFirstValue(i1));\n      //\n      assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 632L, docs.get(4).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(4).getFirstValue(i1));\n      //\n      if (withFL == false) {\n        // exact number varies based on test randomization, but there should always be at least the 8\n        // explicitly indexed in these 2 docs...\n        assertTrue(docs.toString(), 8 <= docs.get(0).getFieldNames().size());\n        assertTrue(docs.toString(), 8 <= docs.get(4).getFieldNames().size());\n      }\n    }\n    \n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n    \n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedGrouping#test().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIP);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    \n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-9802\n    query(\"q\", \"*:*\", \"group\", \"true\", \"group.field\", tdate_a, \"sort\", i1 + \" asc, id asc\", \"fl\", \"id\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id,score\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id,score\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id,score\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // grouping shouldn't care if there are multiple fl params, or what order the fl field names are in\n    variantQuery(params(\"q\", \"*:*\",\n                        \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", \"10\",\n                        \"sort\", i1 + \" asc, id asc\")\n                 , params(\"fl\", \"id,\" + i1dv)\n                 , params(\"fl\", i1dv + \",id\")\n                 , params(\"fl\", \"id\", \"fl\", i1dv)\n                 , params(\"fl\", i1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", \"id,\" + s1dv + \",\" + tdate_a)\n                 , params(\"fl\", \"id\", \"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", s1dv + \",\" + tdate_a)\n                 , params(\"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv)\n                 );\n    variantQuery(params(\"q\", \"{!func}id_i1\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                        \"sort\", tlong+\" asc, id desc\")\n                 , params(\"fl\", t1 + \",score,\" + i1dv)\n                 , params(\"fl\", t1, \"fl\", \"score\", \"fl\", i1dv)\n                 , params(\"fl\", \"score\", \"fl\", t1, \"fl\", i1dv)\n                 );\n                             \n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    for (boolean withFL : new boolean[] {true, false}) {\n      if (withFL) {\n        rsp = variantQuery(params(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                                  \"rows\", \"100\",\n                                  \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                                  \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\")\n                           , params(\"fl\", tlong + \",id,\" + i1)\n                           , params(\"fl\", tlong, \"fl\", \"id\", \"fl\", i1)\n                           , params(\"fl\", \"id\", \"fl\", i1, \"fl\", tlong)\n                           );\n      } else {\n        // special check: same query, but empty fl...\n        rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                    \"rows\", \"100\",\n                    \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                    \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\");\n      }\n      nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n      nl = (NamedList<?>) nl.get(i1);\n      assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n      assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n      nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n      assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n      SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n      assertEquals(docs.toString(), 5, docs.getNumFound());\n      //\n      assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 732L, docs.get(0).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(0).getFirstValue(i1));\n      //\n      assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 632L, docs.get(4).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(4).getFirstValue(i1));\n      //\n      if (withFL == false) {\n        // exact number varies based on test randomization, but there should always be at least the 8\n        // explicitly indexed in these 2 docs...\n        assertTrue(docs.toString(), 8 <= docs.get(0).getFieldNames().size());\n        assertTrue(docs.toString(), 8 <= docs.get(4).getFieldNames().size());\n      }\n    }\n    \n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n    \n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"_version_\", SKIP);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    // Test distributed grouping with empty indices\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", i1);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    indexr(id,1, i1, 100, tlong, 100, i1dv, 100, t1,\"now is the time for all good men\",\n           tdate_a, \"2010-04-20T11:00:00Z\", b1dv, true,\n           tdate_b, \"2009-08-20T11:00:00Z\", s1dv, \"Trillian\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50, i1dv, 50, t1,\"to come to the aid of their country.\",\n           tdate_a, \"2010-05-02T11:00:00Z\", b1dv, false,\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\",\n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101, i1dv, 101,\n           t1,\"the quick fox jumped over the lazy dog\", b1dv, true, s1dv, \"Zaphod\",\n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 , i1dv, 500,\n           t1,\"the quick fox jumped way over the lazy dog\",\n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 , i1dv, 600, t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,i1dv, 123, t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7, i1dv, 7, t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321, i1dv, 4321, t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987, i1dv, 2015,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379, i1dv, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    indexr(\n        id, 18, i1, 232, tlong, 332, i1dv, 150,\n        t1,\"no eggs on wall, lesson learned\", b1dv, true, s1dv, \"dent\",\n        oddField, \"odd man out\"\n    );\n    indexr(\n        id, 19, i1, 232, tlong, 432, i1dv, 300,\n        t1, \"many eggs on wall\", b1dv, false, s1dv, \"dent\",\n        oddField, \"odd man in\"\n    );\n    indexr(\n        id, 20, i1, 232, tlong, 532, i1dv, 150,\n        t1, \"some eggs on wall\", b1dv, false, s1dv, \"author\",\n        oddField, \"odd man between\"\n    );\n    indexr(\n        id, 21, i1, 232, tlong, 632, i1dv, 120,\n        t1, \"a few eggs on wall\", b1dv, true, s1dv, \"ford prefect\",\n        oddField, \"odd man under\"\n    );\n    indexr(\n        id, 22, i1, 232, tlong, 732, i1dv, 120,\n        t1, \"any eggs on wall\", b1dv, false, s1dv, \"ford prefect\",\n        oddField, \"odd man above\"\n    );\n    indexr(\n        id, 23, i1, 233, tlong, 734, i1dv, 120,\n        t1, \"dirty eggs\", b1dv, true, s1dv, \"Marvin\",\n        oddField, \"odd eggs\"\n    );\n\n    for (int i = 100; i < 150; i++) {\n      indexr(id, i);\n    }\n\n    int[] values = new int[]{9999, 99999, 999999, 9999999};\n    for (int shard = 0; shard < clients.size(); shard++) {\n      int groupValue = values[shard];\n      for (int i = 500; i < 600; i++) {\n        index_specific(shard, \n                       i1, groupValue, \n                       s1, \"a\", \n                       id, i * (shard + 1), \n                       t1, random().nextInt(7));\n      }\n    }\n\n    commit();\n\n    // test grouping\n    // The second sort = id asc . The sorting behaviour is different in dist mode. See TopDocs#merge\n    // The shard the result came from matters in the order if both document sortvalues are equal\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 0, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"id asc, _docid_ asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"{!func}add(\" + i1 + \",5) asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"stats\", \"true\", \"stats.field\", tlong);\n    query(\"q\", \"kings\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"spellcheck\", \"true\", \"spellcheck.build\", \"true\", \"qt\", \"spellCheckCompRH\", \"df\", \"subject\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"hl\",\"true\",\"hl.fl\",t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.sort\", \"id desc\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"group.offset\", 5, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"offset\", 5, \"rows\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.format\", \"simple\", \"offset\", 5, \"rows\", 5);\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.offset\", 5, \"group.limit\", 5, \"sort\", i1 + \" asc, id asc\", \"group.main\", \"true\", \"offset\", 5, \"rows\", 5);\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + i1dv, \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    \n    // SOLR-4150: what if group.query has no matches, \n    // or only matches on one shard\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", \"id:5\", // single doc, so only one shard will have it\n          \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\",\n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-4164: main query matches nothing, or only matches on one shard\n    query(\"q\", \"bogus_s:nothing\", // no docs match\n          \"group\", \"true\", \n          \"group.query\", t1 + \":this_will_never_match\",\n          \"group.field\", i1, \n          \"fl\", \"id\", \"group.limit\", \"2\", \"group.format\", \"simple\");\n    query(\"q\", \"id:5\", // one doc matches, so only one shard\n          \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \n          \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \n          \"group.field\", i1,\n          \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-13404\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"2\", \"group.offset\", \"2\",\n        \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.format\", \"grouped\", \"group.limit\", \"-12\",\n        \"sort\", i1 + \" asc, id asc\");\n\n    ignoreException(\"'group.offset' parameter cannot be negative\");\n    SolrException exception = expectThrows(SolrException.class, () -> query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.offset\", \"-1\")\n    );\n    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, exception.code());\n    assertThat(exception.getMessage(), containsString(\"'group.offset' parameter cannot be negative\"));\n    resetExceptionIgnores();\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"rows\", \"13\", \"start\", \"2\",\n        \"fl\", \"id\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // SOLR-9802\n    query(\"q\", \"*:*\", \"group\", \"true\", \"group.field\", tdate_a, \"sort\", i1 + \" asc, id asc\", \"fl\", \"id\");\n\n    // SOLR-3109\n    query(\"q\", t1 + \":eggs\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n    query(\"q\", i1 + \":232\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", tlong + \" asc, id asc\");\n\n    // SOLR-12248\n    query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + s1dv, \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", -1, \"sort\", b1dv + \" asc, id asc\", \"group.sort\", \"id desc\");\n    query(\"q\", \"*:*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", s1dv + \" asc, id asc\");\n    query(\"q\", s1dv + \":dent\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\", b1dv, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\");\n\n    // In order to validate this we need to make sure that during indexing that all documents of one group only occur on the same shard\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n    for (String gfacet : new String[] { \"true\", \"false\" }) {\n      for (String flimit : new String[] { \"-100\",\"-1\", \"1\", \"2\", \"10000\" }) {\n        for (String foffset : new String[] { \"0\",\"1\", \"2\", \"1000\" }) {\n          query(\"q\", \"*:*\", \"fq\", s1+\":a\", \n                \"rows\", 100, \"fl\", \"id,\"+i1, \"sort\", i1+\" asc, id asc\", \n                \"group\", \"true\", \"group.field\", i1, \"group.limit\", 10, \n                \"facet\", \"true\", \"facet.field\", t1, \"group.facet\", gfacet, \n                \"facet.limit\", flimit, \"facet.offset\", foffset);\n        }\n      }\n    }\n\n    // SOLR-3316\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" asc, id asc\", \"group.truncate\", \"true\", \"facet\", \"true\", \"facet.field\", t1);\n\n    // SOLR-3436\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n    query(\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 0, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"sort\", i1 + \" asc, id asc\", \"group.ngroups\", \"true\");\n\n    // SOLR-3960 - include a postfilter\n    for (String facet : new String[] { \"false\", \"true\"}) {\n      for (String fcache : new String[] { \"\", \" cache=false cost=200\"}) {\n      query(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \n            \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\",\n            \"group\", \"true\", \"group.field\", i1, \n            \"fq\", \"{!frange l=50 \"+fcache+\"}\"+tlong,\n            \"facet.field\", t1,\n            \"facet\", facet\n            );\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    Object[] q =  {\"q\", \"*:*\", \"fq\", s1 + \":a\", \"rows\", 1, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"group.ngroups\", \"true\"};\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n\n    setDistributedParams(params);\n\n    int which = r.nextInt(clients.size());\n    SolrClient client = clients.get(which);\n    QueryResponse rsp = client.query(params);\n    NamedList nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.getVal(0);\n    int matches = (Integer) nl.getVal(0);\n    int groupCount = (Integer) nl.get(\"ngroups\");\n    assertEquals(100 * shardsArr.length, matches);\n    assertEquals(shardsArr.length, groupCount);\n\n\n    // We validate distributed grouping with scoring as first sort.\n    // note: this 'q' matches all docs and returns the 'id' as the score, which is unique and so our results should be deterministic.\n    handle.put(\"maxScore\", SKIP);// TODO see SOLR-6612\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", i1 + \" desc\", \"group.sort\", \"score desc\"); // SOLR-2955\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1, \"sort\", \"score desc, _docid_ asc, id asc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", \"score,id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"group.limit\", -1);\n\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id,score\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id,score\", \"group.format\", \"simple\", \"sort\", i1 + \" asc, id asc\");\n    query(\"q\", \"*:*\",\n        \"group\", \"true\",\n        \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", \"3\",\n        \"fl\", \"id,score\", \"group.main\", \"true\", \"sort\", i1 + \" asc, id asc\");\n\n    // grouping shouldn't care if there are multiple fl params, or what order the fl field names are in\n    variantQuery(params(\"q\", \"*:*\",\n                        \"group\", \"true\", \"group.field\", i1dv, \"group.limit\", \"10\",\n                        \"sort\", i1 + \" asc, id asc\")\n                 , params(\"fl\", \"id,\" + i1dv)\n                 , params(\"fl\", i1dv + \",id\")\n                 , params(\"fl\", \"id\", \"fl\", i1dv)\n                 , params(\"fl\", i1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", \"id,\" + s1dv + \",\" + tdate_a)\n                 , params(\"fl\", \"id\", \"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv, \"fl\", \"id\")\n                 );\n    variantQuery(params(\"q\", \"*:*\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", s1dv, \"group.limit\", \"-1\", \n                        \"sort\", b1dv + \" asc, id asc\",\n                        \"group.sort\", \"id desc\")\n                 , params(\"fl\", s1dv + \",\" + tdate_a)\n                 , params(\"fl\", s1dv, \"fl\", tdate_a)\n                 , params(\"fl\", tdate_a, \"fl\", s1dv)\n                 );\n    variantQuery(params(\"q\", \"{!func}id_i1\", \"rows\", \"100\",\n                        \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                        \"sort\", tlong+\" asc, id desc\")\n                 , params(\"fl\", t1 + \",score,\" + i1dv)\n                 , params(\"fl\", t1, \"fl\", \"score\", \"fl\", i1dv)\n                 , params(\"fl\", \"score\", \"fl\", t1, \"fl\", i1dv)\n                 );\n                             \n    // some explicit checks of non default sorting, and sort/group.sort with diff clauses\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", \"id asc\",\n          \"group.sort\", tlong+\" asc, id desc\");\n    query(\"q\", \"{!func}id_i1\", \"rows\", 100, \"fl\", tlong + \",id,\" + i1, \"group\", \"true\",\n          \"group.field\", i1, \"group.limit\", -1,\n          \"sort\", tlong+\" asc, id desc\",\n          \"group.sort\", \"id asc\");\n    for (boolean withFL : new boolean[] {true, false}) {\n      if (withFL) {\n        rsp = variantQuery(params(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                                  \"rows\", \"100\",\n                                  \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                                  \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\")\n                           , params(\"fl\", tlong + \",id,\" + i1)\n                           , params(\"fl\", tlong, \"fl\", \"id\", \"fl\", i1)\n                           , params(\"fl\", \"id\", \"fl\", i1, \"fl\", tlong)\n                           );\n      } else {\n        // special check: same query, but empty fl...\n        rsp = query(\"q\", \"{!func}id_i1\", \"fq\", oddField+\":[* TO *]\",\n                    \"rows\", \"100\",\n                    \"group\", \"true\", \"group.field\", i1, \"group.limit\", \"-1\",\n                    \"sort\", tlong+\" asc\", \"group.sort\", oddField+\" asc\");\n      }\n      nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n      nl = (NamedList<?>) nl.get(i1);\n      assertEquals(rsp.toString(), 6, nl.get(\"matches\"));\n      assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n      nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n      assertEquals(rsp.toString(), 232, nl.get(\"groupValue\"));\n      SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n      assertEquals(docs.toString(), 5, docs.getNumFound());\n      //\n      assertEquals(docs.toString(), \"22\", docs.get(0).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 732L, docs.get(0).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(0).getFirstValue(i1));\n      //\n      assertEquals(docs.toString(), \"21\", docs.get(4).getFirstValue(\"id\"));\n      assertEquals(docs.toString(), 632L, docs.get(4).getFirstValue(tlong));\n      assertEquals(docs.toString(), 232,  docs.get(4).getFirstValue(i1));\n      //\n      if (withFL == false) {\n        // exact number varies based on test randomization, but there should always be at least the 8\n        // explicitly indexed in these 2 docs...\n        assertTrue(docs.toString(), 8 <= docs.get(0).getFieldNames().size());\n        assertTrue(docs.toString(), 8 <= docs.get(4).getFieldNames().size());\n      }\n    }\n    \n    // grouping on boolean non-stored docValued enabled field\n    rsp = query(\"q\", b1dv + \":*\", \"fl\", \"id,\" + b1dv, \"group\", \"true\", \"group.field\",\n        b1dv, \"group.limit\", 10, \"sort\", b1dv + \" asc, id asc\");\n    nl = (NamedList<?>) rsp.getResponse().get(\"grouped\");\n    nl = (NamedList<?>) nl.get(b1dv);\n    assertEquals(rsp.toString(), 9, nl.get(\"matches\"));\n    assertEquals(rsp.toString(), 2, ((List<NamedList<?>>)nl.get(\"groups\")).size());\n    nl = ((List<NamedList<?>>)nl.get(\"groups\")).get(0);\n    assertEquals(rsp.toString(), false, nl.get(\"groupValue\"));\n    SolrDocumentList docs = (SolrDocumentList) nl.get(\"doclist\");\n    assertEquals(docs.toString(), 4, docs.getNumFound());\n    \n    // Can't validate the response, but can check if no errors occur.\n    simpleQuery(\"q\", \"*:*\", \"rows\", 100, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.query\", t1 + \":kings OR \" + t1 + \":eggs\", \"group.limit\", 10, \"sort\", i1 + \" asc, id asc\", CommonParams.TIME_ALLOWED, 1);\n    \n    //Debug\n    simpleQuery(\"q\", \"*:*\", \"rows\", 10, \"fl\", \"id,\" + i1, \"group\", \"true\", \"group.field\", i1, \"debug\", \"true\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1313c74c6d619d0d98d1284bc17513c9a4b40345":["286e1dbf267cac3961c3fc116b9069797ad7d1c2"],"38bbc20b9f0152f78a6f08c072856630e9b89fa1":["6069837581413356deecd17ffb9cd92ff3bc7b44"],"8caae639c4263eb96d3c071f3b1b3b4cf6a7a25e":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"abb23fcc2461782ab204e61213240feb77d355aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["1a144790859eb303122988cd315215ff30f449d2"],"10f1ec454f37e3f7a5de3b1a04e77d0158001bb8":["e74728bf33a99680da79803cdb3017f609d7dd17"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["10f1ec454f37e3f7a5de3b1a04e77d0158001bb8"],"e98520789adb1d5ad05afb4956eca0944a929688":["2761c3f53e738e28c17c75124aa305e4e63c989d"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["d423443db06bfcac81733aafcce04ee491880cc7","1a144790859eb303122988cd315215ff30f449d2"],"6069837581413356deecd17ffb9cd92ff3bc7b44":["053bf01497af10659a59b6ce2f85e4be8cdc3b9e"],"1a144790859eb303122988cd315215ff30f449d2":["d423443db06bfcac81733aafcce04ee491880cc7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"053bf01497af10659a59b6ce2f85e4be8cdc3b9e":["1313c74c6d619d0d98d1284bc17513c9a4b40345"],"d423443db06bfcac81733aafcce04ee491880cc7":["8caae639c4263eb96d3c071f3b1b3b4cf6a7a25e"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":["1313c74c6d619d0d98d1284bc17513c9a4b40345","053bf01497af10659a59b6ce2f85e4be8cdc3b9e"],"2761c3f53e738e28c17c75124aa305e4e63c989d":["38bbc20b9f0152f78a6f08c072856630e9b89fa1"],"f932d2f40e796e652d4b3f45ad3761dcc37b01f0":["abb23fcc2461782ab204e61213240feb77d355aa"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","8caae639c4263eb96d3c071f3b1b3b4cf6a7a25e"],"28288370235ed02234a64753cdbf0c6ec096304a":["1a144790859eb303122988cd315215ff30f449d2","a71f63026529f3c1f03cfdd664910873ab2369ae"],"f8061ddd97f3352007d927dae445884a6f3d857b":["1313c74c6d619d0d98d1284bc17513c9a4b40345","053bf01497af10659a59b6ce2f85e4be8cdc3b9e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","8caae639c4263eb96d3c071f3b1b3b4cf6a7a25e"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","5b8ee93140fd0efef7e101786e3ed5160a700b5f"],"286e1dbf267cac3961c3fc116b9069797ad7d1c2":["28288370235ed02234a64753cdbf0c6ec096304a"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d423443db06bfcac81733aafcce04ee491880cc7"],"e74728bf33a99680da79803cdb3017f609d7dd17":["f932d2f40e796e652d4b3f45ad3761dcc37b01f0"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","a71f63026529f3c1f03cfdd664910873ab2369ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"]},"commit2Childs":{"1313c74c6d619d0d98d1284bc17513c9a4b40345":["053bf01497af10659a59b6ce2f85e4be8cdc3b9e","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","f8061ddd97f3352007d927dae445884a6f3d857b"],"38bbc20b9f0152f78a6f08c072856630e9b89fa1":["2761c3f53e738e28c17c75124aa305e4e63c989d"],"8caae639c4263eb96d3c071f3b1b3b4cf6a7a25e":["d423443db06bfcac81733aafcce04ee491880cc7","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"abb23fcc2461782ab204e61213240feb77d355aa":["f932d2f40e796e652d4b3f45ad3761dcc37b01f0"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"10f1ec454f37e3f7a5de3b1a04e77d0158001bb8":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["8caae639c4263eb96d3c071f3b1b3b4cf6a7a25e","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"6069837581413356deecd17ffb9cd92ff3bc7b44":["38bbc20b9f0152f78a6f08c072856630e9b89fa1"],"1a144790859eb303122988cd315215ff30f449d2":["a71f63026529f3c1f03cfdd664910873ab2369ae","e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["abb23fcc2461782ab204e61213240feb77d355aa"],"053bf01497af10659a59b6ce2f85e4be8cdc3b9e":["6069837581413356deecd17ffb9cd92ff3bc7b44","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","f8061ddd97f3352007d927dae445884a6f3d857b"],"d423443db06bfcac81733aafcce04ee491880cc7":["e9017cf144952056066919f1ebc7897ff9bd71b1","1a144790859eb303122988cd315215ff30f449d2","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":[],"2761c3f53e738e28c17c75124aa305e4e63c989d":["e98520789adb1d5ad05afb4956eca0944a929688"],"f932d2f40e796e652d4b3f45ad3761dcc37b01f0":["e74728bf33a99680da79803cdb3017f609d7dd17"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"28288370235ed02234a64753cdbf0c6ec096304a":["286e1dbf267cac3961c3fc116b9069797ad7d1c2"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":[],"286e1dbf267cac3961c3fc116b9069797ad7d1c2":["1313c74c6d619d0d98d1284bc17513c9a4b40345"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"e74728bf33a99680da79803cdb3017f609d7dd17":["10f1ec454f37e3f7a5de3b1a04e77d0158001bb8"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","f8061ddd97f3352007d927dae445884a6f3d857b","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}