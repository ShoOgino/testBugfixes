{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygon#donePoints().mjava","commits":[{"id":"851e4197476b684154a7b65f996f535522e67400","date":1428926498,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygon#donePoints().mjava","pathOld":"/dev/null","sourceNew":"    /** Finish the polygon, by connecting the last added point with the starting point.\n    */\n    public void donePoints() {\n        // If fewer than 3 points, can't do it.\n        if (points.size() < 3)\n            throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n        // Time to construct the planes.  If the polygon is truly convex, then any adjacent point\n        edges = new SidedPlane[points.size()];\n        // to a segment can provide an interior measurement.\n        for (int i = 0; i < points.size(); i++) {\n            GeoPoint start = points.get(i);\n            GeoPoint end = points.get(legalIndex(i+1));\n            GeoPoint check = points.get(legalIndex(i+2));\n            SidedPlane sp = new SidedPlane(check,start,end);\n            //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n            edges[i] = sp;\n        }\n        \n        // In order to naively confirm that the polygon is convex, I would need to\n        // check every edge, and verify that every point (other than the edge endpoints)\n        // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n        // not wrong, though, because everything else about polygons has a similar cost.\n        for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n            SidedPlane edge = edges[edgeIndex];\n            for (int pointIndex =0; pointIndex < points.size(); pointIndex++) {\n                if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex+1)) {\n                    if (!edge.isWithin(points.get(pointIndex)))\n                        throw new IllegalArgumentException(\"Polygon is not convex: Point \"+points.get(pointIndex)+\" Edge \"+edge);\n                }\n            }\n        }\n        \n        // Finally, we need to compute a single interior point that will satisfy\n        // all edges.  If the polygon is convex, we know that such a point exists.\n        \n        // This is actually surprisingly hard.  I believe merely averaging the x, y, and z\n        // values of the points will produce a point inside the shape, but it won't be\n        // on the unit sphere, and it may be in fact degenerate and have a zero magnitude.\n        // In that case, an alternate algorithm would be required.  But since such cases\n        // are very special (or very contrived), I'm just going to not worry about that\n        // for the moment.\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumZ = 0.0;\n        for (GeoPoint p : points) {\n            sumX += p.x;\n            sumY += p.y;\n            sumZ += p.z;\n        }\n        double denom = 1.0 / (double)points.size();\n        sumX *= denom;\n        sumY *= denom;\n        sumZ *= denom;\n        double magnitude = Math.sqrt(sumX * sumX + sumY * sumY + sumZ * sumZ);\n        if (magnitude < 1.0e-10)\n            throw new IllegalArgumentException(\"Polygon interior point cannot be determined\");\n        denom = 1.0/magnitude;\n        \n        interiorPoint = new GeoPoint(sumX*denom,sumY*denom,sumZ*denom);\n        \n        // Let's be sure that our interior point is really inside\n        for (SidedPlane sp : edges) {\n            if (!sp.isWithin(interiorPoint))\n                throw new IllegalArgumentException(\"Interior point logic failed to produce an interior point\");\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab7d51740456adc459ec788c8fe27746bdc60a55","date":1429185101,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygon#donePoints().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygon#donePoints().mjava","sourceNew":"    /** Finish the polygon, by connecting the last added point with the starting point.\n    */\n    public void donePoints() {\n        // If fewer than 3 points, can't do it.\n        if (points.size() < 3)\n            throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n        // Time to construct the planes.  If the polygon is truly convex, then any adjacent point\n        edges = new SidedPlane[points.size()];\n        // to a segment can provide an interior measurement.\n        for (int i = 0; i < points.size(); i++) {\n            GeoPoint start = points.get(i);\n            GeoPoint end = points.get(legalIndex(i+1));\n            GeoPoint check = points.get(legalIndex(i+2));\n            SidedPlane sp = new SidedPlane(check,start,end);\n            //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n            edges[i] = sp;\n        }\n        \n        // In order to naively confirm that the polygon is convex, I would need to\n        // check every edge, and verify that every point (other than the edge endpoints)\n        // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n        // not wrong, though, because everything else about polygons has a similar cost.\n        for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n            SidedPlane edge = edges[edgeIndex];\n            for (int pointIndex =0; pointIndex < points.size(); pointIndex++) {\n                if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex+1)) {\n                    if (!edge.isWithin(points.get(pointIndex)))\n                        throw new IllegalArgumentException(\"Polygon is not convex: Point \"+points.get(pointIndex)+\" Edge \"+edge);\n                }\n            }\n        }\n        \n        // Finally, we need to compute a single interior point that will satisfy\n        // all edges.  If the polygon is convex, we know that such a point exists.\n        \n        // This is actually surprisingly hard.  I believe merely averaging the x, y, and z\n        // values of the points will produce a point inside the shape, but it won't be\n        // on the unit sphere, and it may be in fact degenerate and have a zero magnitude.\n        // In that case, an alternate algorithm would be required.  But since such cases\n        // are very special (or very contrived), I'm just going to not worry about that\n        // for the moment.\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumZ = 0.0;\n        for (GeoPoint p : points) {\n            sumX += p.x;\n            sumY += p.y;\n            sumZ += p.z;\n        }\n        double denom = 1.0 / (double)points.size();\n        sumX *= denom;\n        sumY *= denom;\n        sumZ *= denom;\n        double magnitude = Math.sqrt(sumX * sumX + sumY * sumY + sumZ * sumZ);\n        if (magnitude < 1.0e-10)\n            throw new IllegalArgumentException(\"Polygon interior point cannot be determined\");\n        denom = 1.0/magnitude;\n        \n        interiorPoint = new GeoPoint(sumX*denom,sumY*denom,sumZ*denom);\n        \n        // Let's be sure that our interior point is really inside\n        for (SidedPlane sp : edges) {\n            if (!sp.isWithin(interiorPoint)) {\n                StringBuilder sb = new StringBuilder(\"Interior point logic failed to produce an interior point.  Vertices: \");\n                for (GeoPoint p : points) {\n                    sb.append(p).append(\" \");\n                }\n                sb.append(\". Interior point: \").append(interiorPoint);\n                throw new IllegalArgumentException(sb.toString());\n            }\n        }\n    }\n\n","sourceOld":"    /** Finish the polygon, by connecting the last added point with the starting point.\n    */\n    public void donePoints() {\n        // If fewer than 3 points, can't do it.\n        if (points.size() < 3)\n            throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n        // Time to construct the planes.  If the polygon is truly convex, then any adjacent point\n        edges = new SidedPlane[points.size()];\n        // to a segment can provide an interior measurement.\n        for (int i = 0; i < points.size(); i++) {\n            GeoPoint start = points.get(i);\n            GeoPoint end = points.get(legalIndex(i+1));\n            GeoPoint check = points.get(legalIndex(i+2));\n            SidedPlane sp = new SidedPlane(check,start,end);\n            //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n            edges[i] = sp;\n        }\n        \n        // In order to naively confirm that the polygon is convex, I would need to\n        // check every edge, and verify that every point (other than the edge endpoints)\n        // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n        // not wrong, though, because everything else about polygons has a similar cost.\n        for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n            SidedPlane edge = edges[edgeIndex];\n            for (int pointIndex =0; pointIndex < points.size(); pointIndex++) {\n                if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex+1)) {\n                    if (!edge.isWithin(points.get(pointIndex)))\n                        throw new IllegalArgumentException(\"Polygon is not convex: Point \"+points.get(pointIndex)+\" Edge \"+edge);\n                }\n            }\n        }\n        \n        // Finally, we need to compute a single interior point that will satisfy\n        // all edges.  If the polygon is convex, we know that such a point exists.\n        \n        // This is actually surprisingly hard.  I believe merely averaging the x, y, and z\n        // values of the points will produce a point inside the shape, but it won't be\n        // on the unit sphere, and it may be in fact degenerate and have a zero magnitude.\n        // In that case, an alternate algorithm would be required.  But since such cases\n        // are very special (or very contrived), I'm just going to not worry about that\n        // for the moment.\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumZ = 0.0;\n        for (GeoPoint p : points) {\n            sumX += p.x;\n            sumY += p.y;\n            sumZ += p.z;\n        }\n        double denom = 1.0 / (double)points.size();\n        sumX *= denom;\n        sumY *= denom;\n        sumZ *= denom;\n        double magnitude = Math.sqrt(sumX * sumX + sumY * sumY + sumZ * sumZ);\n        if (magnitude < 1.0e-10)\n            throw new IllegalArgumentException(\"Polygon interior point cannot be determined\");\n        denom = 1.0/magnitude;\n        \n        interiorPoint = new GeoPoint(sumX*denom,sumY*denom,sumZ*denom);\n        \n        // Let's be sure that our interior point is really inside\n        for (SidedPlane sp : edges) {\n            if (!sp.isWithin(interiorPoint))\n                throw new IllegalArgumentException(\"Interior point logic failed to produce an interior point\");\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fb9dbed1415914caa27460f8abb7afadaa61451","date":1429504289,"type":4,"author":"David Wayne Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygon#donePoints().mjava","sourceNew":null,"sourceOld":"    /** Finish the polygon, by connecting the last added point with the starting point.\n    */\n    public void donePoints() {\n        // If fewer than 3 points, can't do it.\n        if (points.size() < 3)\n            throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n        // Time to construct the planes.  If the polygon is truly convex, then any adjacent point\n        edges = new SidedPlane[points.size()];\n        // to a segment can provide an interior measurement.\n        for (int i = 0; i < points.size(); i++) {\n            GeoPoint start = points.get(i);\n            GeoPoint end = points.get(legalIndex(i+1));\n            GeoPoint check = points.get(legalIndex(i+2));\n            SidedPlane sp = new SidedPlane(check,start,end);\n            //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n            edges[i] = sp;\n        }\n        \n        // In order to naively confirm that the polygon is convex, I would need to\n        // check every edge, and verify that every point (other than the edge endpoints)\n        // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n        // not wrong, though, because everything else about polygons has a similar cost.\n        for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n            SidedPlane edge = edges[edgeIndex];\n            for (int pointIndex =0; pointIndex < points.size(); pointIndex++) {\n                if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex+1)) {\n                    if (!edge.isWithin(points.get(pointIndex)))\n                        throw new IllegalArgumentException(\"Polygon is not convex: Point \"+points.get(pointIndex)+\" Edge \"+edge);\n                }\n            }\n        }\n        \n        // Finally, we need to compute a single interior point that will satisfy\n        // all edges.  If the polygon is convex, we know that such a point exists.\n        \n        // This is actually surprisingly hard.  I believe merely averaging the x, y, and z\n        // values of the points will produce a point inside the shape, but it won't be\n        // on the unit sphere, and it may be in fact degenerate and have a zero magnitude.\n        // In that case, an alternate algorithm would be required.  But since such cases\n        // are very special (or very contrived), I'm just going to not worry about that\n        // for the moment.\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumZ = 0.0;\n        for (GeoPoint p : points) {\n            sumX += p.x;\n            sumY += p.y;\n            sumZ += p.z;\n        }\n        double denom = 1.0 / (double)points.size();\n        sumX *= denom;\n        sumY *= denom;\n        sumZ *= denom;\n        double magnitude = Math.sqrt(sumX * sumX + sumY * sumY + sumZ * sumZ);\n        if (magnitude < 1.0e-10)\n            throw new IllegalArgumentException(\"Polygon interior point cannot be determined\");\n        denom = 1.0/magnitude;\n        \n        interiorPoint = new GeoPoint(sumX*denom,sumY*denom,sumZ*denom);\n        \n        // Let's be sure that our interior point is really inside\n        for (SidedPlane sp : edges) {\n            if (!sp.isWithin(interiorPoint)) {\n                StringBuilder sb = new StringBuilder(\"Interior point logic failed to produce an interior point.  Vertices: \");\n                for (GeoPoint p : points) {\n                    sb.append(p).append(\" \");\n                }\n                sb.append(\". Interior point: \").append(interiorPoint);\n                throw new IllegalArgumentException(sb.toString());\n            }\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0fb9dbed1415914caa27460f8abb7afadaa61451":["ab7d51740456adc459ec788c8fe27746bdc60a55"],"ab7d51740456adc459ec788c8fe27746bdc60a55":["851e4197476b684154a7b65f996f535522e67400"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"851e4197476b684154a7b65f996f535522e67400":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0fb9dbed1415914caa27460f8abb7afadaa61451":[],"ab7d51740456adc459ec788c8fe27746bdc60a55":["0fb9dbed1415914caa27460f8abb7afadaa61451"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["851e4197476b684154a7b65f996f535522e67400","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"851e4197476b684154a7b65f996f535522e67400":["ab7d51740456adc459ec788c8fe27746bdc60a55"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0fb9dbed1415914caa27460f8abb7afadaa61451","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}