{"path":"solr/solrj/src/java/org/apache/solr/common/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","commits":[{"id":"1b52553b383e6cf68c783d177daafd0b32d6347a","date":1327690866,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","pathOld":"/dev/null","sourceNew":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);\n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7","date":1327763052,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","pathOld":"/dev/null","sourceNew":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);\n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","pathOld":"/dev/null","sourceNew":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);\n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1b52553b383e6cf68c783d177daafd0b32d6347a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd92b8bcc88e969302510acf77bd6970da3994c4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1b52553b383e6cf68c783d177daafd0b32d6347a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1b52553b383e6cf68c783d177daafd0b32d6347a"],"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1b52553b383e6cf68c783d177daafd0b32d6347a"]},"commit2Childs":{"1b52553b383e6cf68c783d177daafd0b32d6347a":["fd92b8bcc88e969302510acf77bd6970da3994c4","cd5edd1f2b162a5cfa08efd17851a07373a96817","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1b52553b383e6cf68c783d177daafd0b32d6347a","fd92b8bcc88e969302510acf77bd6970da3994c4","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7":[]},"heads":["fd92b8bcc88e969302510acf77bd6970da3994c4","cd5edd1f2b162a5cfa08efd17851a07373a96817","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}