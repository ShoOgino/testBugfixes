{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","commits":[{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n      }\n    }\n    String collection = cd.getCloudDescriptor().getCollectionName();\n\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(collection);\n\n    try {\n      if (cd != null && cd.getName() != null)\n        MDCUtils.setCore(cd.getName());\n      log.info(\"publishing core={} state={} collection={}\", cd.getName(), state.toString(), collection);\n      //System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { //XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n      MDCUtils.setShard(shardId);\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, null);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, null);\n            }\n          }\n        }\n      }\n\n      Map<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n\n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(ZkStateReader.toJSON(m));\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final String state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n      }\n    }\n    String collection = cd.getCloudDescriptor().getCollectionName();\n\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(collection);\n\n    try {\n      if (cd != null && cd.getName() != null)\n        MDCUtils.setCore(cd.getName());\n      log.info(\"publishing core={} state={} collection={}\", cd.getName(), state, collection);\n      //System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { //XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n      MDCUtils.setShard(shardId);\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (!ZkStateReader.DOWN.equals(state)) {\n        String lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (ZkStateReader.ACTIVE.equals(state)) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (ZkStateReader.RECOVERING.equals(lirState)) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, ZkStateReader.ACTIVE, null, true);\n            } else if (ZkStateReader.DOWN.equals(lirState)) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (ZkStateReader.RECOVERING.equals(state)) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (ZkStateReader.DOWN.equals(lirState)) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, ZkStateReader.RECOVERING, null, true);\n            }\n          }\n        }\n      }\n\n      Map<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state);\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n\n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(ZkStateReader.toJSON(m));\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, null);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, null);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      \n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(ZkStateReader.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n      }\n    }\n    String collection = cd.getCloudDescriptor().getCollectionName();\n\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(collection);\n\n    try {\n      if (cd != null && cd.getName() != null)\n        MDCUtils.setCore(cd.getName());\n      log.info(\"publishing core={} state={} collection={}\", cd.getName(), state.toString(), collection);\n      //System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { //XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n      MDCUtils.setShard(shardId);\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, null);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, null);\n            }\n          }\n        }\n      }\n\n      Map<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n\n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(ZkStateReader.toJSON(m));\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, null);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, null);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      \n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, null);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, null);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      \n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(ZkStateReader.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22859cb40e09867e7da8de84a31956c07259f82f","date":1441822065,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, null, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, null, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      \n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, null);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, null);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      \n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"bugIntro":["3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e0300d1df37d7e9662d491269e91b6f66dca8bd","date":1443011762,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      \n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, null, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, null, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      \n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["22859cb40e09867e7da8de84a31956c07259f82f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff94e4cae4a92d7aeee5e1b15b8ca2229738ee7e","date":1461168315,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      \n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b701e0fcef214f86bab1daf107adce0b0131212","date":1461241874,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      \n      if (ClusterStateUtil.isAutoAddReplicas(getZkStateReader(), collection)) {\n        try (SolrCore core = cc.getCore(cd.getName())) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.info(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.info(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"359aab8d0284ad77917fc39712289950b39edbec","date":1490727391,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49998598398261debaeb6b3e59d6e06bec3c1ffd","date":1490873946,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e87998750c1408b8af3248e55cff794d51d37166","date":1501426220,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n      \n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws KeeperException, InterruptedException {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c","date":1512481565,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // This flag is used for testing rolling updates and should be removed in SOLR-11812\n      boolean isRunningInNewLIR = \"new\".equals(cd.getCoreProperty(\"lirVersion\", \"new\"));\n      if (state == Replica.State.RECOVERING && isRunningInNewLIR) {\n        getShardTerms(collection, shardId).setEqualsToMax(coreNodeName);\n      }\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n      \n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","date":1520143025,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // This flag is used for testing rolling updates and should be removed in SOLR-11812\n      boolean isRunningInNewLIR = \"new\".equals(cd.getCoreProperty(\"lirVersion\", \"new\"));\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && isRunningInNewLIR && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && isRunningInNewLIR && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // This flag is used for testing rolling updates and should be removed in SOLR-11812\n      boolean isRunningInNewLIR = \"new\".equals(cd.getCoreProperty(\"lirVersion\", \"new\"));\n      if (state == Replica.State.RECOVERING && isRunningInNewLIR) {\n        getShardTerms(collection, shardId).setEqualsToMax(coreNodeName);\n      }\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().lastPublished = state;\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28ba172425e443e0f08a49de6d73586c418d7251","date":1523970991,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // This flag is used for testing rolling updates and should be removed in SOLR-11812\n      boolean isRunningInNewLIR = \"new\".equals(cd.getCoreProperty(\"lirVersion\", \"new\"));\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && isRunningInNewLIR && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && isRunningInNewLIR && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // This flag is used for testing rolling updates and should be removed in SOLR-11812\n      boolean isRunningInNewLIR = \"new\".equals(cd.getCoreProperty(\"lirVersion\", \"new\"));\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && isRunningInNewLIR && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && isRunningInNewLIR && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180","date":1539076849,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      // If the leader initiated recovery, then verify that this replica has performed\n      // recovery as requested before becoming active; don't even look at lirState if going down\n      if (state != Replica.State.DOWN) {\n        final Replica.State lirState = getLeaderInitiatedRecoveryState(collection, shardId, coreNodeName);\n        if (lirState != null) {\n          assert cd.getCloudDescriptor().getReplicaType() != Replica.Type.PULL: \"LIR should not happen for pull replicas!\";\n          if (state == Replica.State.ACTIVE) {\n            // trying to become active, so leader-initiated state must be recovering\n            if (lirState == Replica.State.RECOVERING) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.ACTIVE, cd, true);\n            } else if (lirState == Replica.State.DOWN) {\n              throw new SolrException(ErrorCode.INVALID_STATE,\n                  \"Cannot publish state of core '\" + cd.getName() + \"' as active without recovering first!\");\n            }\n          } else if (state == Replica.State.RECOVERING) {\n            // if it is currently DOWN, then trying to enter into recovering state is good\n            if (lirState == Replica.State.DOWN) {\n              updateLeaderInitiatedRecoveryState(collection, shardId, coreNodeName, Replica.State.RECOVERING, cd, true);\n            }\n          }\n        }\n      }\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // This flag is used for testing rolling updates and should be removed in SOLR-11812\n      boolean isRunningInNewLIR = \"new\".equals(cd.getCoreProperty(\"lirVersion\", \"new\"));\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && isRunningInNewLIR && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && isRunningInNewLIR && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n\n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n      \n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n      \n      assert collection != null && collection.length() > 0;\n      \n      String shardId = cd.getCloudDescriptor().getShardId();\n      \n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n      \n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ed5005b977107bba28c700351216f1595e7abe4f","date":1585964712,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n      }\n    }\n    MDCLoggingContext.setCoreDescriptor(cc, cd);\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n\n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n        MDCLoggingContext.setCore(core);\n      }\n    } else {\n      MDCLoggingContext.setCoreDescriptor(cc, cd);\n    }\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n\n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n      }\n    }\n    MDCLoggingContext.setCoreDescriptor(cc, cd);\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n\n      log.debug(\"publishing state={}\", state);\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        if (log.isInfoEnabled()) {\n          log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n        }\n      }\n\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n      }\n    }\n    MDCLoggingContext.setCoreDescriptor(cc, cd);\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n\n      log.debug(\"publishing state={}\", state.toString());\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n      }\n\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publish(CoreDescriptor,Replica.State,boolean,boolean).mjava","sourceNew":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n      }\n    }\n    MDCLoggingContext.setCoreDescriptor(cc, cd);\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n\n      log.debug(\"publishing state={}\", state);\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        if (log.isInfoEnabled()) {\n          log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n        }\n      }\n\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /**\n   * Publish core state to overseer.\n   */\n  public void publish(final CoreDescriptor cd, final Replica.State state, boolean updateLastState, boolean forcePublish) throws Exception {\n    if (!forcePublish) {\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core == null || core.isClosed()) {\n          return;\n        }\n      }\n    }\n    MDCLoggingContext.setCoreDescriptor(cc, cd);\n    try {\n      String collection = cd.getCloudDescriptor().getCollectionName();\n\n      log.debug(\"publishing state={}\", state);\n      // System.out.println(Thread.currentThread().getStackTrace()[3]);\n      Integer numShards = cd.getCloudDescriptor().getNumShards();\n      if (numShards == null) { // XXX sys prop hack\n        log.debug(\"numShards not found on descriptor - reading it from system property\");\n        numShards = Integer.getInteger(ZkStateReader.NUM_SHARDS_PROP);\n      }\n\n      assert collection != null && collection.length() > 0;\n\n      String shardId = cd.getCloudDescriptor().getShardId();\n\n      String coreNodeName = cd.getCloudDescriptor().getCoreNodeName();\n\n      Map<String,Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"state\");\n      props.put(ZkStateReader.STATE_PROP, state.toString());\n      props.put(ZkStateReader.BASE_URL_PROP, getBaseUrl());\n      props.put(ZkStateReader.CORE_NAME_PROP, cd.getName());\n      props.put(ZkStateReader.ROLES_PROP, cd.getCloudDescriptor().getRoles());\n      props.put(ZkStateReader.NODE_NAME_PROP, getNodeName());\n      props.put(ZkStateReader.SHARD_ID_PROP, cd.getCloudDescriptor().getShardId());\n      props.put(ZkStateReader.COLLECTION_PROP, collection);\n      props.put(ZkStateReader.REPLICA_TYPE, cd.getCloudDescriptor().getReplicaType().toString());\n      if (!Overseer.isLegacy(zkStateReader)) {\n        props.put(ZkStateReader.FORCE_SET_STATE_PROP, \"false\");\n      }\n      if (numShards != null) {\n        props.put(ZkStateReader.NUM_SHARDS_PROP, numShards.toString());\n      }\n      if (coreNodeName != null) {\n        props.put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n      }\n      try (SolrCore core = cc.getCore(cd.getName())) {\n        if (core != null && state == Replica.State.ACTIVE) {\n          ensureRegisteredSearcher(core);\n        }\n        if (core != null && core.getDirectoryFactory().isSharedStorage()) {\n          if (core.getDirectoryFactory().isSharedStorage()) {\n            props.put(ZkStateReader.SHARED_STORAGE_PROP, \"true\");\n            props.put(\"dataDir\", core.getDataDir());\n            UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n            if (ulog != null) {\n              props.put(\"ulogDir\", ulog.getLogDir());\n            }\n          }\n        }\n      } catch (SolrCoreInitializationException ex) {\n        // The core had failed to initialize (in a previous request, not this one), hence nothing to do here.\n        if (log.isInfoEnabled()) {\n          log.info(\"The core '{}' had failed to initialize before.\", cd.getName());\n        }\n      }\n\n      // pull replicas are excluded because their terms are not considered\n      if (state == Replica.State.RECOVERING && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        // state is used by client, state of replica can change from RECOVERING to DOWN without needed to finish recovery\n        // by calling this we will know that a replica actually finished recovery or not\n        getShardTerms(collection, shardId).startRecovering(coreNodeName);\n      }\n      if (state == Replica.State.ACTIVE && cd.getCloudDescriptor().getReplicaType() != Type.PULL) {\n        getShardTerms(collection, shardId).doneRecovering(coreNodeName);\n      }\n\n      ZkNodeProps m = new ZkNodeProps(props);\n\n      if (updateLastState) {\n        cd.getCloudDescriptor().setLastPublished(state);\n      }\n      overseerJobQueue.offer(Utils.toJSON(m));\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["28ba172425e443e0f08a49de6d73586c418d7251"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["49998598398261debaeb6b3e59d6e06bec3c1ffd"],"ff94e4cae4a92d7aeee5e1b15b8ca2229738ee7e":["3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"ed5005b977107bba28c700351216f1595e7abe4f":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"ad4957cde742defe6db19689abdc267c5d948066":["ed5005b977107bba28c700351216f1595e7abe4f"],"84f20f331d8001864545c7021812d8c6509c7593":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["28ba172425e443e0f08a49de6d73586c418d7251"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["84f20f331d8001864545c7021812d8c6509c7593"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","61c45e99cf6676da48f19d7511c73712ad39402b"],"22859cb40e09867e7da8de84a31956c07259f82f":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"359aab8d0284ad77917fc39712289950b39edbec":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["9b701e0fcef214f86bab1daf107adce0b0131212","962cd4f5e313777f35da8f521265323e84184929"],"e87998750c1408b8af3248e55cff794d51d37166":["61c45e99cf6676da48f19d7511c73712ad39402b"],"9b701e0fcef214f86bab1daf107adce0b0131212":["3e0300d1df37d7e9662d491269e91b6f66dca8bd","ff94e4cae4a92d7aeee5e1b15b8ca2229738ee7e"],"962cd4f5e313777f35da8f521265323e84184929":["9b701e0fcef214f86bab1daf107adce0b0131212"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["ad4957cde742defe6db19689abdc267c5d948066"],"61c45e99cf6676da48f19d7511c73712ad39402b":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"3e0300d1df37d7e9662d491269e91b6f66dca8bd":["22859cb40e09867e7da8de84a31956c07259f82f"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["e87998750c1408b8af3248e55cff794d51d37166"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["359aab8d0284ad77917fc39712289950b39edbec"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9b701e0fcef214f86bab1daf107adce0b0131212","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["e9017cf144952056066919f1ebc7897ff9bd71b1","e87998750c1408b8af3248e55cff794d51d37166"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"28ba172425e443e0f08a49de6d73586c418d7251":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"49998598398261debaeb6b3e59d6e06bec3c1ffd":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"ff94e4cae4a92d7aeee5e1b15b8ca2229738ee7e":["9b701e0fcef214f86bab1daf107adce0b0131212"],"ed5005b977107bba28c700351216f1595e7abe4f":["ad4957cde742defe6db19689abdc267c5d948066"],"ad4957cde742defe6db19689abdc267c5d948066":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"84f20f331d8001864545c7021812d8c6509c7593":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["28ba172425e443e0f08a49de6d73586c418d7251"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"22859cb40e09867e7da8de84a31956c07259f82f":["3e0300d1df37d7e9662d491269e91b6f66dca8bd"],"359aab8d0284ad77917fc39712289950b39edbec":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["359aab8d0284ad77917fc39712289950b39edbec","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","49998598398261debaeb6b3e59d6e06bec3c1ffd"],"e87998750c1408b8af3248e55cff794d51d37166":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"9b701e0fcef214f86bab1daf107adce0b0131212":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","962cd4f5e313777f35da8f521265323e84184929","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"962cd4f5e313777f35da8f521265323e84184929":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","e87998750c1408b8af3248e55cff794d51d37166"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"3e0300d1df37d7e9662d491269e91b6f66dca8bd":["ff94e4cae4a92d7aeee5e1b15b8ca2229738ee7e","9b701e0fcef214f86bab1daf107adce0b0131212"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["22859cb40e09867e7da8de84a31956c07259f82f"],"b869898f50ca80263bac2e3ae0949f7700e5c977":[],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["61c45e99cf6676da48f19d7511c73712ad39402b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["ed5005b977107bba28c700351216f1595e7abe4f"],"28ba172425e443e0f08a49de6d73586c418d7251":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["84f20f331d8001864545c7021812d8c6509c7593"],"49998598398261debaeb6b3e59d6e06bec3c1ffd":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b869898f50ca80263bac2e3ae0949f7700e5c977","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}