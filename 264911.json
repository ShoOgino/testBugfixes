{"path":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","commits":[{"id":"aa8dcd4adc562c6e8da67c42872ef9194f8598fa","date":1108145465,"type":1,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"sandbox/contributions/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"    /**\n     * Suggest similar words (restricted or not of a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param IndexReader the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null ,the suggest\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteri\n     * first criteria : the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","sourceOld":"    /**\n     * Suggest similar words (restricted or not of a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param IndexReader the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null ,the suggest\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteri\n     * first criteria : the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a614b98c1cfd216f3f63751e3ae13364a3bb2810","date":1113263282,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"    /**\n     * Suggest similar words (restricted or not of a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param ir the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null ,the suggest\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteri\n     * first criteria : the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","sourceOld":"    /**\n     * Suggest similar words (restricted or not of a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param IndexReader the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null ,the suggest\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteri\n     * first criteria : the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"377b35e5a387cec525f01e277610588118902dd5","date":1117308109,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"    /**\n     * Suggest similar words (restricted or not to a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param ir the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null, the suggested\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteria:\n     * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","sourceOld":"    /**\n     * Suggest similar words (restricted or not of a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param ir the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null ,the suggest\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteri\n     * first criteria : the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f9e55f1144a02aa9e891161b50c49a9911b58ac","date":1138468924,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"    /**\n     * Suggest similar words (restricted or not to a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param ir the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null, the suggested\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteria:\n     * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string.equals(word)) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","sourceOld":"    /**\n     * Suggest similar words (restricted or not to a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param ir the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null, the suggested\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteria:\n     * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string==word) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efa83cecbb73110d95920d115fe81525e8b770c2","date":1149197773,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"    /**\n     * Suggest similar words (restricted or not to a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param ir the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null, the suggested\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteria:\n     * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        float min = this.min;\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string.equals(word)) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","sourceOld":"    /**\n     * Suggest similar words (restricted or not to a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param ir the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null, the suggested\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteria:\n     * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string.equals(word)) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7cd0a7a7985f8ec8f8f5af8022077ddc4846d515","date":1153458899,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (restricted or not to a field of a user index)\n   * @param word String the word you want a spell check done on\n   * @param num_sug int the number of suggest words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field String the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with this 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int num_sug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.min;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(\n        field, word)) : 0;\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word }; // return the word if it exist in the index and i don't want a more popular word\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n\n    }\n\n    IndexSearcher searcher = new IndexSearcher(this.spellindex);\n    Hits hits = searcher.search(query);\n    SuggestWordQueue sugqueue = new SuggestWordQueue(num_sug);\n\n    int stop = Math.min(hits.length(), 10 * num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n    SuggestWord sugword = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugword.string = hits.doc(i).get(F_WORD); // get orig word)\n\n      if (sugword.string.equals(word)) {\n        continue; // don't suggest a word for itself, that would be silly\n      }\n\n      //edit distance/normalize with the min word length\n      sugword.score = 1.0f - ((float) sd.getDistance(sugword.string) / Math\n          .min(sugword.string.length(), lengthWord));\n      if (sugword.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugword.freq = ir.docFreq(new Term(field, sugword.string)); // freq in the index\n        if ((morePopular && goalFreq > sugword.freq) || sugword.freq < 1) { // don't suggest a word that is not present in the field\n          continue;\n        }\n      }\n      sugqueue.insert(sugword);\n      if (sugqueue.size() == num_sug) {\n        //if queue full , maintain the min score\n        min = ((SuggestWord) sugqueue.top()).score;\n      }\n      sugword = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugqueue.size()];\n    for (int i = sugqueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugqueue.pop()).string;\n    }\n\n    searcher.close();\n    return list;\n  }\n\n","sourceOld":"    /**\n     * Suggest similar words (restricted or not to a field of a user index)\n     * @param word String the word you want a spell check done on\n     * @param num_sug int the number of suggest words\n     * @param ir the indexReader of the user index (can be null see field param)\n     * @param field String the field of the user index: if field is not null, the suggested\n     * words are restricted to the words present in this field.\n     * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n     * (only if restricted mode = (indexReader!=null and field!=null)\n     * @throws IOException\n     * @return String[] the sorted list of the suggest words with this 2 criteria:\n     * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n     * of the suggest words in the field of the user index\n     */\n    public String[] suggestSimilar (String word, int num_sug, IndexReader ir, String field\n    , boolean morePopular) throws IOException {\n\n        float min = this.min;\n        final TRStringDistance sd=new TRStringDistance(word);\n        final int lengthWord=word.length();\n\n        final int goalFreq=(morePopular&&ir!=null)?ir.docFreq(new Term(field, word)):0;\n        if (!morePopular&&goalFreq>0) {\n            return new String[] {\n            word}; // return the word if it exist in the index and i don't want a more popular word\n        }\n\n        BooleanQuery query=new BooleanQuery();\n        String[] grams;\n        String key;\n\n        for (int ng=getMin(lengthWord); ng<=getMax(lengthWord); ng++) {\n\n            key=\"gram\"+ng; // form key\n\n            grams=formGrams(word, ng); // form word into ngrams (allow dups too)\n\n            if (grams.length==0) {\n                continue; // hmm\n            }\n\n            if (bStart>0) { // should we boost prefixes?\n                add(query, \"start\"+ng, grams[0], bStart); // matches start of word\n\n            }\n            if (bEnd>0) { // should we boost suffixes\n                add(query, \"end\"+ng, grams[grams.length-1], bEnd); // matches end of word\n\n            }\n            for (int i=0; i<grams.length; i++) {\n                add(query, key, grams[i]);\n            }\n\n        }\n\n        IndexSearcher searcher=new IndexSearcher(this.spellindex);\n        Hits hits=searcher.search(query);\n        SuggestWordQueue sugqueue=new SuggestWordQueue(num_sug);\n\n        int stop=Math.min(hits.length(), 10*num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n        SuggestWord sugword=new SuggestWord();\n        for (int i=0; i<stop; i++) {\n\n            sugword.string=hits.doc(i).get(F_WORD); // get orig word)\n\n            if (sugword.string.equals(word)) {\n                continue; // don't suggest a word for itself, that would be silly\n            }\n\n            //edit distance/normalize with the min word length\n            sugword.score=1.0f-((float) sd.getDistance(sugword.string)/Math.min(sugword.string.length(), lengthWord));\n            if (sugword.score<min) {\n                continue;\n            }\n\n            if (ir!=null) { // use the user index\n                sugword.freq=ir.docFreq(new Term(field, sugword.string)); // freq in the index\n                if ((morePopular&&goalFreq>sugword.freq)||sugword.freq<1) { // don't suggest a word that is not present in the field\n                    continue;\n                }\n            }\n            sugqueue.insert(sugword);\n            if (sugqueue.size()==num_sug) {\n                //if queue full , maintain the min score\n                min=((SuggestWord) sugqueue.top()).score;\n            }\n            sugword=new SuggestWord();\n        }\n\n        // convert to array string\n        String[] list=new String[sugqueue.size()];\n        for (int i=sugqueue.size()-1; i>=0; i--) {\n            list[i]=((SuggestWord) sugqueue.pop()).string;\n        }\n\n        searcher.close();\n        return list;\n    }\n\n","bugFix":null,"bugIntro":["06f9496ffee71a7a7baed7d7ffa015dc6811bdba","af25e7aa79fb729d817ae81accf4a112a0c69014"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d6c8635b7359c78703bca99eed29c45ed44ac7f","date":1153471142,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (restricted or not to a field of a user index)\n   * @param word String the word you want a spell check done on\n   * @param num_sug int the number of suggest words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field String the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with this 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int num_sug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.min;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(field, word)) : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n    SuggestWordQueue sugqueue = new SuggestWordQueue(num_sug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * num_sug);\n    SuggestWord sugword = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugword.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugword.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the min word length\n      sugword.score = 1.0f - ((float) sd.getDistance(sugword.string) / Math\n          .min(sugword.string.length(), lengthWord));\n      if (sugword.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugword.freq = ir.docFreq(new Term(field, sugword.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugword.freq) || sugword.freq < 1) {\n          continue;\n        }\n      }\n      sugqueue.insert(sugword);\n      if (sugqueue.size() == num_sug) {\n        // if queue full, maintain the min score\n        min = ((SuggestWord) sugqueue.top()).score;\n      }\n      sugword = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugqueue.size()];\n    for (int i = sugqueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugqueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (restricted or not to a field of a user index)\n   * @param word String the word you want a spell check done on\n   * @param num_sug int the number of suggest words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field String the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with this 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int num_sug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.min;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(\n        field, word)) : 0;\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word }; // return the word if it exist in the index and i don't want a more popular word\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n\n    }\n\n    IndexSearcher searcher = new IndexSearcher(this.spellindex);\n    Hits hits = searcher.search(query);\n    SuggestWordQueue sugqueue = new SuggestWordQueue(num_sug);\n\n    int stop = Math.min(hits.length(), 10 * num_sug); // go thru more than 'maxr' matches in case the distance filter triggers\n    SuggestWord sugword = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugword.string = hits.doc(i).get(F_WORD); // get orig word)\n\n      if (sugword.string.equals(word)) {\n        continue; // don't suggest a word for itself, that would be silly\n      }\n\n      //edit distance/normalize with the min word length\n      sugword.score = 1.0f - ((float) sd.getDistance(sugword.string) / Math\n          .min(sugword.string.length(), lengthWord));\n      if (sugword.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugword.freq = ir.docFreq(new Term(field, sugword.string)); // freq in the index\n        if ((morePopular && goalFreq > sugword.freq) || sugword.freq < 1) { // don't suggest a word that is not present in the field\n          continue;\n        }\n      }\n      sugqueue.insert(sugword);\n      if (sugqueue.size() == num_sug) {\n        //if queue full , maintain the min score\n        min = ((SuggestWord) sugqueue.top()).score;\n      }\n      sugword = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugqueue.size()];\n    for (int i = sugqueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugqueue.pop()).string;\n    }\n\n    searcher.close();\n    return list;\n  }\n\n","bugFix":null,"bugIntro":["af25e7aa79fb729d817ae81accf4a112a0c69014"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"66021102b0be85b9577e1882bf9835c9c3aad214","date":1153473052,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (restricted or not to a field of a user index)\n   * @param word String the word you want a spell check done on\n   * @param numSug int the number of suggest words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field String the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with this 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(field, word)) : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (restricted or not to a field of a user index)\n   * @param word String the word you want a spell check done on\n   * @param num_sug int the number of suggest words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field String the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with this 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int num_sug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.min;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(field, word)) : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n    SuggestWordQueue sugqueue = new SuggestWordQueue(num_sug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * num_sug);\n    SuggestWord sugword = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugword.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugword.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the min word length\n      sugword.score = 1.0f - ((float) sd.getDistance(sugword.string) / Math\n          .min(sugword.string.length(), lengthWord));\n      if (sugword.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugword.freq = ir.docFreq(new Term(field, sugword.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugword.freq) || sugword.freq < 1) {\n          continue;\n        }\n      }\n      sugqueue.insert(sugword);\n      if (sugqueue.size() == num_sug) {\n        // if queue full, maintain the min score\n        min = ((SuggestWord) sugqueue.top()).score;\n      }\n      sugword = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugqueue.size()];\n    for (int i = sugqueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugqueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c2dacb7de68407adf10cda93ee1edf49502cc14","date":1172860135,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * Suggest similar words (restricted or not to a field of a user index)\n   * @param word String the word you want a spell check done on\n   * @param numSug int the number of suggest words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field String the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with this 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(field, word)) : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (restricted or not to a field of a user index)\n   * @param word String the word you want a spell check done on\n   * @param numSug int the number of suggest words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field String the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with this 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(field, word)) : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96308b901685e8ec12a3856f788a7d9d98c22e50","date":1180177598,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(field, word)) : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * Suggest similar words (restricted or not to a field of a user index)\n   * @param word String the word you want a spell check done on\n   * @param numSug int the number of suggest words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field String the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular boolean return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with this 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(field, word)) : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":["af25e7aa79fb729d817ae81accf4a112a0c69014"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af25e7aa79fb729d817ae81accf4a112a0c69014","date":1211438058,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int goalFreq = (morePopular && ir != null) ? ir.docFreq(new Term(field, word)) : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && goalFreq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","bugFix":["7cd0a7a7985f8ec8f8f5af8022077ddc4846d515","96308b901685e8ec12a3856f788a7d9d98c22e50","3d6c8635b7359c78703bca99eed29c45ed44ac7f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06f9496ffee71a7a7baed7d7ffa015dc6811bdba","date":1212682328,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","bugFix":["7cd0a7a7985f8ec8f8f5af8022077ddc4846d515"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6000179efff4c320dafa76c7f0f088e44c4df0d0","date":1213765317,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance\n      sugWord.score = sd.getDistance(word,sugWord.string);\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final TRStringDistance sd = new TRStringDistance(word);\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance/normalize with the minScore word length\n      sugWord.score = 1.0f - ((float) sd.getDistance(sugWord.string) / Math\n          .min(sugWord.string.length(), lengthWord));\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f148c02ddd6ba981c65ca685d0e56c3a98368e1","date":1254892102,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n    int maxHits = 10 * numSug;\n    \n//    System.out.println(\"Q: \" + query);\n    ScoreDoc[] hits = searcher.search(query, null, maxHits).scoreDocs;\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length, maxHits);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = searcher.doc(hits[i].doc).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance\n      sugWord.score = sd.getDistance(word,sugWord.string);\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n//    System.out.println(\"Q: \" + query);\n    Hits hits = searcher.search(query);\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length(), 10 * numSug);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = hits.doc(i).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance\n      sugWord.score = sd.getDistance(word,sugWord.string);\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0731e137bcbb58121034de6ddaa67332fbe6e5d1","date":1255233265,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n    int maxHits = 10 * numSug;\n    \n//    System.out.println(\"Q: \" + query);\n    ScoreDoc[] hits = searcher.search(query, null, maxHits).scoreDocs;\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length, maxHits);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = searcher.doc(hits[i].doc).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance\n      sugWord.score = sd.getDistance(word,sugWord.string);\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insertWithOverflow(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n    int maxHits = 10 * numSug;\n    \n//    System.out.println(\"Q: \" + query);\n    ScoreDoc[] hits = searcher.search(query, null, maxHits).scoreDocs;\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length, maxHits);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = searcher.doc(hits[i].doc).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance\n      sugWord.score = sd.getDistance(word,sugWord.string);\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insert(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60cdc0e643184821eb066795a8791cd82559f46e","date":1257941914,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n    int maxHits = 10 * numSug;\n    \n//    System.out.println(\"Q: \" + query);\n    ScoreDoc[] hits = searcher.search(query, null, maxHits).scoreDocs;\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length, maxHits);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = searcher.doc(hits[i].doc).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance\n      sugWord.score = sd.getDistance(word,sugWord.string);\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insertWithOverflow(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = sugQueue.top().score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = sugQueue.pop().string;\n    }\n\n    return list;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n    int maxHits = 10 * numSug;\n    \n//    System.out.println(\"Q: \" + query);\n    ScoreDoc[] hits = searcher.search(query, null, maxHits).scoreDocs;\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length, maxHits);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = searcher.doc(hits[i].doc).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance\n      sugWord.score = sd.getDistance(word,sugWord.string);\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insertWithOverflow(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = ((SuggestWord) sugQueue.top()).score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = ((SuggestWord) sugQueue.pop()).string;\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edfb471a48a4bd226eefc6d6fd96195d9ce1db73","date":1260015437,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException if the underlying index throws an {@link IOException}\n   * @throws AlreadyClosedException if the Spellchecker is already closed\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n    // obtainSearcher calls ensureOpen\n    final IndexSearcher indexSearcher = obtainSearcher();\n    try{\n      float min = this.minScore;\n      final int lengthWord = word.length();\n  \n      final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n      final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n      // if the word exists in the real index and we don't care for word frequency, return the word itself\n      if (!morePopular && freq > 0) {\n        return new String[] { word };\n      }\n  \n      BooleanQuery query = new BooleanQuery();\n      String[] grams;\n      String key;\n  \n      for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n  \n        key = \"gram\" + ng; // form key\n  \n        grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n  \n        if (grams.length == 0) {\n          continue; // hmm\n        }\n  \n        if (bStart > 0) { // should we boost prefixes?\n          add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n  \n        }\n        if (bEnd > 0) { // should we boost suffixes\n          add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n  \n        }\n        for (int i = 0; i < grams.length; i++) {\n          add(query, key, grams[i]);\n        }\n      }\n  \n      int maxHits = 10 * numSug;\n      \n  //    System.out.println(\"Q: \" + query);\n      ScoreDoc[] hits = indexSearcher.search(query, null, maxHits).scoreDocs;\n  //    System.out.println(\"HITS: \" + hits.length());\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n  \n      // go thru more than 'maxr' matches in case the distance filter triggers\n      int stop = Math.min(hits.length, maxHits);\n      SuggestWord sugWord = new SuggestWord();\n      for (int i = 0; i < stop; i++) {\n  \n        sugWord.string = indexSearcher.doc(hits[i].doc).get(F_WORD); // get orig word\n  \n        // don't suggest a word for itself, that would be silly\n        if (sugWord.string.equals(word)) {\n          continue;\n        }\n  \n        // edit distance\n        sugWord.score = sd.getDistance(word,sugWord.string);\n        if (sugWord.score < min) {\n          continue;\n        }\n  \n        if (ir != null && field != null) { // use the user index\n          sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n          // don't suggest a word that is not present in the field\n          if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n            continue;\n          }\n        }\n        sugQueue.insertWithOverflow(sugWord);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n        sugWord = new SuggestWord();\n      }\n  \n      // convert to array string\n      String[] list = new String[sugQueue.size()];\n      for (int i = sugQueue.size() - 1; i >= 0; i--) {\n        list[i] = sugQueue.pop().string;\n      }\n  \n      return list;\n    } finally {\n      releaseSearcher(indexSearcher);\n    }\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n\n    float min = this.minScore;\n    final int lengthWord = word.length();\n\n    final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n    final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n    // if the word exists in the real index and we don't care for word frequency, return the word itself\n    if (!morePopular && freq > 0) {\n      return new String[] { word };\n    }\n\n    BooleanQuery query = new BooleanQuery();\n    String[] grams;\n    String key;\n\n    for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n\n      key = \"gram\" + ng; // form key\n\n      grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n\n      if (grams.length == 0) {\n        continue; // hmm\n      }\n\n      if (bStart > 0) { // should we boost prefixes?\n        add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n\n      }\n      if (bEnd > 0) { // should we boost suffixes\n        add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n\n      }\n      for (int i = 0; i < grams.length; i++) {\n        add(query, key, grams[i]);\n      }\n    }\n\n    int maxHits = 10 * numSug;\n    \n//    System.out.println(\"Q: \" + query);\n    ScoreDoc[] hits = searcher.search(query, null, maxHits).scoreDocs;\n//    System.out.println(\"HITS: \" + hits.length());\n    SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n\n    // go thru more than 'maxr' matches in case the distance filter triggers\n    int stop = Math.min(hits.length, maxHits);\n    SuggestWord sugWord = new SuggestWord();\n    for (int i = 0; i < stop; i++) {\n\n      sugWord.string = searcher.doc(hits[i].doc).get(F_WORD); // get orig word\n\n      // don't suggest a word for itself, that would be silly\n      if (sugWord.string.equals(word)) {\n        continue;\n      }\n\n      // edit distance\n      sugWord.score = sd.getDistance(word,sugWord.string);\n      if (sugWord.score < min) {\n        continue;\n      }\n\n      if (ir != null && field != null) { // use the user index\n        sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n        // don't suggest a word that is not present in the field\n        if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n          continue;\n        }\n      }\n      sugQueue.insertWithOverflow(sugWord);\n      if (sugQueue.size() == numSug) {\n        // if queue full, maintain the minScore score\n        min = sugQueue.top().score;\n      }\n      sugWord = new SuggestWord();\n    }\n\n    // convert to array string\n    String[] list = new String[sugQueue.size()];\n    for (int i = sugQueue.size() - 1; i >= 0; i--) {\n      list[i] = sugQueue.pop().string;\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker#suggestSimilar(String,int,IndexReader,String,boolean).mjava","sourceNew":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException if the underlying index throws an {@link IOException}\n   * @throws AlreadyClosedException if the Spellchecker is already closed\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n    // obtainSearcher calls ensureOpen\n    final IndexSearcher indexSearcher = obtainSearcher();\n    try{\n      float min = this.minScore;\n      final int lengthWord = word.length();\n  \n      final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n      final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n      // if the word exists in the real index and we don't care for word frequency, return the word itself\n      if (!morePopular && freq > 0) {\n        return new String[] { word };\n      }\n  \n      BooleanQuery query = new BooleanQuery();\n      String[] grams;\n      String key;\n  \n      for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n  \n        key = \"gram\" + ng; // form key\n  \n        grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n  \n        if (grams.length == 0) {\n          continue; // hmm\n        }\n  \n        if (bStart > 0) { // should we boost prefixes?\n          add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n  \n        }\n        if (bEnd > 0) { // should we boost suffixes\n          add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n  \n        }\n        for (int i = 0; i < grams.length; i++) {\n          add(query, key, grams[i]);\n        }\n      }\n  \n      int maxHits = 10 * numSug;\n      \n  //    System.out.println(\"Q: \" + query);\n      ScoreDoc[] hits = indexSearcher.search(query, null, maxHits).scoreDocs;\n  //    System.out.println(\"HITS: \" + hits.length());\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n  \n      // go thru more than 'maxr' matches in case the distance filter triggers\n      int stop = Math.min(hits.length, maxHits);\n      SuggestWord sugWord = new SuggestWord();\n      for (int i = 0; i < stop; i++) {\n  \n        sugWord.string = indexSearcher.doc(hits[i].doc).get(F_WORD); // get orig word\n  \n        // don't suggest a word for itself, that would be silly\n        if (sugWord.string.equals(word)) {\n          continue;\n        }\n  \n        // edit distance\n        sugWord.score = sd.getDistance(word,sugWord.string);\n        if (sugWord.score < min) {\n          continue;\n        }\n  \n        if (ir != null && field != null) { // use the user index\n          sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n          // don't suggest a word that is not present in the field\n          if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n            continue;\n          }\n        }\n        sugQueue.insertWithOverflow(sugWord);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n        sugWord = new SuggestWord();\n      }\n  \n      // convert to array string\n      String[] list = new String[sugQueue.size()];\n      for (int i = sugQueue.size() - 1; i >= 0; i--) {\n        list[i] = sugQueue.pop().string;\n      }\n  \n      return list;\n    } finally {\n      releaseSearcher(indexSearcher);\n    }\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words (optionally restricted to a field of an index).\n   * \n   * <p>As the Lucene similarity that is used to fetch the most relevant n-grammed terms\n   * is not the same as the edit distance strategy used to calculate the best\n   * matching spell-checked word from the hits that Lucene found, one usually has\n   * to retrieve a couple of numSug's in order to get the true best match.\n   *\n   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.\n   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.\n   *\n   * @param word the word you want a spell check done on\n   * @param numSug the number of suggested words\n   * @param ir the indexReader of the user index (can be null see field param)\n   * @param field the field of the user index: if field is not null, the suggested\n   * words are restricted to the words present in this field.\n   * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word\n   * (only if restricted mode = (indexReader!=null and field!=null)\n   * @throws IOException if the underlying index throws an {@link IOException}\n   * @throws AlreadyClosedException if the Spellchecker is already closed\n   * @return String[] the sorted list of the suggest words with these 2 criteria:\n   * first criteria: the edit distance, second criteria (only if restricted mode): the popularity\n   * of the suggest words in the field of the user index\n   */\n  public String[] suggestSimilar(String word, int numSug, IndexReader ir,\n      String field, boolean morePopular) throws IOException {\n    // obtainSearcher calls ensureOpen\n    final IndexSearcher indexSearcher = obtainSearcher();\n    try{\n      float min = this.minScore;\n      final int lengthWord = word.length();\n  \n      final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;\n      final int goalFreq = (morePopular && ir != null && field != null) ? freq : 0;\n      // if the word exists in the real index and we don't care for word frequency, return the word itself\n      if (!morePopular && freq > 0) {\n        return new String[] { word };\n      }\n  \n      BooleanQuery query = new BooleanQuery();\n      String[] grams;\n      String key;\n  \n      for (int ng = getMin(lengthWord); ng <= getMax(lengthWord); ng++) {\n  \n        key = \"gram\" + ng; // form key\n  \n        grams = formGrams(word, ng); // form word into ngrams (allow dups too)\n  \n        if (grams.length == 0) {\n          continue; // hmm\n        }\n  \n        if (bStart > 0) { // should we boost prefixes?\n          add(query, \"start\" + ng, grams[0], bStart); // matches start of word\n  \n        }\n        if (bEnd > 0) { // should we boost suffixes\n          add(query, \"end\" + ng, grams[grams.length - 1], bEnd); // matches end of word\n  \n        }\n        for (int i = 0; i < grams.length; i++) {\n          add(query, key, grams[i]);\n        }\n      }\n  \n      int maxHits = 10 * numSug;\n      \n  //    System.out.println(\"Q: \" + query);\n      ScoreDoc[] hits = indexSearcher.search(query, null, maxHits).scoreDocs;\n  //    System.out.println(\"HITS: \" + hits.length());\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n  \n      // go thru more than 'maxr' matches in case the distance filter triggers\n      int stop = Math.min(hits.length, maxHits);\n      SuggestWord sugWord = new SuggestWord();\n      for (int i = 0; i < stop; i++) {\n  \n        sugWord.string = indexSearcher.doc(hits[i].doc).get(F_WORD); // get orig word\n  \n        // don't suggest a word for itself, that would be silly\n        if (sugWord.string.equals(word)) {\n          continue;\n        }\n  \n        // edit distance\n        sugWord.score = sd.getDistance(word,sugWord.string);\n        if (sugWord.score < min) {\n          continue;\n        }\n  \n        if (ir != null && field != null) { // use the user index\n          sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index\n          // don't suggest a word that is not present in the field\n          if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {\n            continue;\n          }\n        }\n        sugQueue.insertWithOverflow(sugWord);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n        sugWord = new SuggestWord();\n      }\n  \n      // convert to array string\n      String[] list = new String[sugQueue.size()];\n      for (int i = sugQueue.size() - 1; i >= 0; i--) {\n        list[i] = sugQueue.pop().string;\n      }\n  \n      return list;\n    } finally {\n      releaseSearcher(indexSearcher);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60cdc0e643184821eb066795a8791cd82559f46e":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"7cd0a7a7985f8ec8f8f5af8022077ddc4846d515":["efa83cecbb73110d95920d115fe81525e8b770c2"],"96308b901685e8ec12a3856f788a7d9d98c22e50":["2c2dacb7de68407adf10cda93ee1edf49502cc14"],"3d6c8635b7359c78703bca99eed29c45ed44ac7f":["7cd0a7a7985f8ec8f8f5af8022077ddc4846d515"],"edfb471a48a4bd226eefc6d6fd96195d9ce1db73":["60cdc0e643184821eb066795a8791cd82559f46e"],"2c2dacb7de68407adf10cda93ee1edf49502cc14":["66021102b0be85b9577e1882bf9835c9c3aad214"],"66021102b0be85b9577e1882bf9835c9c3aad214":["3d6c8635b7359c78703bca99eed29c45ed44ac7f"],"06f9496ffee71a7a7baed7d7ffa015dc6811bdba":["af25e7aa79fb729d817ae81accf4a112a0c69014"],"377b35e5a387cec525f01e277610588118902dd5":["a614b98c1cfd216f3f63751e3ae13364a3bb2810"],"a614b98c1cfd216f3f63751e3ae13364a3bb2810":["aa8dcd4adc562c6e8da67c42872ef9194f8598fa"],"af25e7aa79fb729d817ae81accf4a112a0c69014":["96308b901685e8ec12a3856f788a7d9d98c22e50"],"aa8dcd4adc562c6e8da67c42872ef9194f8598fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"efa83cecbb73110d95920d115fe81525e8b770c2":["1f9e55f1144a02aa9e891161b50c49a9911b58ac"],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["0f148c02ddd6ba981c65ca685d0e56c3a98368e1"],"1f9e55f1144a02aa9e891161b50c49a9911b58ac":["377b35e5a387cec525f01e277610588118902dd5"],"0f148c02ddd6ba981c65ca685d0e56c3a98368e1":["6000179efff4c320dafa76c7f0f088e44c4df0d0"],"6000179efff4c320dafa76c7f0f088e44c4df0d0":["06f9496ffee71a7a7baed7d7ffa015dc6811bdba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["edfb471a48a4bd226eefc6d6fd96195d9ce1db73"]},"commit2Childs":{"60cdc0e643184821eb066795a8791cd82559f46e":["edfb471a48a4bd226eefc6d6fd96195d9ce1db73"],"7cd0a7a7985f8ec8f8f5af8022077ddc4846d515":["3d6c8635b7359c78703bca99eed29c45ed44ac7f"],"96308b901685e8ec12a3856f788a7d9d98c22e50":["af25e7aa79fb729d817ae81accf4a112a0c69014"],"3d6c8635b7359c78703bca99eed29c45ed44ac7f":["66021102b0be85b9577e1882bf9835c9c3aad214"],"edfb471a48a4bd226eefc6d6fd96195d9ce1db73":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"2c2dacb7de68407adf10cda93ee1edf49502cc14":["96308b901685e8ec12a3856f788a7d9d98c22e50"],"66021102b0be85b9577e1882bf9835c9c3aad214":["2c2dacb7de68407adf10cda93ee1edf49502cc14"],"06f9496ffee71a7a7baed7d7ffa015dc6811bdba":["6000179efff4c320dafa76c7f0f088e44c4df0d0"],"377b35e5a387cec525f01e277610588118902dd5":["1f9e55f1144a02aa9e891161b50c49a9911b58ac"],"a614b98c1cfd216f3f63751e3ae13364a3bb2810":["377b35e5a387cec525f01e277610588118902dd5"],"af25e7aa79fb729d817ae81accf4a112a0c69014":["06f9496ffee71a7a7baed7d7ffa015dc6811bdba"],"aa8dcd4adc562c6e8da67c42872ef9194f8598fa":["a614b98c1cfd216f3f63751e3ae13364a3bb2810"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aa8dcd4adc562c6e8da67c42872ef9194f8598fa"],"efa83cecbb73110d95920d115fe81525e8b770c2":["7cd0a7a7985f8ec8f8f5af8022077ddc4846d515"],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["60cdc0e643184821eb066795a8791cd82559f46e"],"1f9e55f1144a02aa9e891161b50c49a9911b58ac":["efa83cecbb73110d95920d115fe81525e8b770c2"],"0f148c02ddd6ba981c65ca685d0e56c3a98368e1":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"6000179efff4c320dafa76c7f0f088e44c4df0d0":["0f148c02ddd6ba981c65ca685d0e56c3a98368e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}