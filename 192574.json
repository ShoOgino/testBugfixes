{"path":"solr/src/java/org/apache/solr/response/ReturnFields#getReturnFields(String,SolrQueryRequest).mjava","commits":[{"id":"6aedf81f068e430dec27d94310415cc6ff52731c","date":1301070261,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/response/ReturnFields#getReturnFields(String,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  public static ReturnFields getReturnFields(String fl, SolrQueryRequest req)\n  {\n    ReturnFields rf = new ReturnFields();\n    rf.wantsScore = false;\n    rf.fields = new LinkedHashSet<String>(); // order is important for CSVResponseWriter\n    boolean allFields = false;\n\n    DocTransformers augmenters = new DocTransformers();\n    if (fl != null) {\n      // TODO - this could become more efficient if widely used.\n      String[] flst = SolrPluginUtils.split(fl);\n      if (flst.length > 0 && !(flst.length==1 && flst[0].length()==0)) {\n        IndexSchema schema = req.getSchema();\n        for (String name : flst) {\n          if( \"*\".equals( name ) ) {\n            allFields = true;\n          }\n          else if( SCORE.equals( name ) ) {\n            rf.fields.add( name );\n            rf.wantsScore = true;\n            augmenters.addTransformer( new ScoreAugmenter( SCORE ) );\n          }\n          else {\n            rf.fields.add( name );\n\n            // Check if it is a real score\n            SchemaField sf = schema.getFieldOrNull( name );\n            if( sf == null ) {\n              // not a field name, but possibly return value\n              if( DOCID.equals( name ) ) {\n                augmenters.addTransformer( new DocIdAugmenter( DOCID ) );\n              }\n              else if( SHARD.equals( name ) ) {\n                String id = \"getshardid???\";\n                augmenters.addTransformer( new ValueAugmenter( SHARD, id ) );\n              }\n              else if( EXPLAIN.equals( name ) ) {\n                augmenters.addTransformer( new ExplainAugmenter( EXPLAIN ) );\n              }\n              else if( name.startsWith( \"{!func}\") ) {\n                // help?  not sure how to parse a ValueSorce\n                // -- not to mention, we probably want to reuse existing ones!\n                augmenters.addTransformer( new ValueAugmenter( name, \"TODO:\"+name ) );\n//                try {\n//                  String func = name.substring( \"{!func}\".length() );\n//                  SolrParams local = null;\n//                  FunctionQParser p = new FunctionQParser( func, local, req.getParams(), req );\n//                  Query q = p.parse();\n//                  ValueSource vs = p.parseValueSource();\n//                  AtomicReaderContext ctx = new AtomicReaderContext( req.getSearcher().getIndexReader() );\n//                  Map mmm = null; // ?????\n//                  DocValues values = p.parseValueSource().getValues( mmm, ctx );\n//                  augmenters.addAugmenter( new DocValuesAugmenter( name, values ) );\n//                }\n//                catch( Exception ex ) {\n//                  throw new SolrException( org.apache.solr.common.SolrException.ErrorCode.BAD_REQUEST,\n//                      \"Unable to parse augmented field: \"+name, ex );\n//                }\n              }\n              else { \n                // maybe throw an exception?\n//                throw new SolrException( org.apache.solr.common.SolrException.ErrorCode.BAD_REQUEST,\n//                    \"Unknown Return Field: \"+name );\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Legacy behavior? \"score\" == \"*,score\"\n    if( rf.fields.size() == 1 && rf.wantsScore ) {\n      allFields = true;\n    }\n    \n    if( allFields || rf.fields.isEmpty() ) {\n      rf.fields = null;\n    }\n    \n    if( augmenters.size() == 1 ) {\n      rf.transformer = augmenters.getTransformer(0);\n    }\n    else if( augmenters.size() > 1 ) {\n      rf.transformer = augmenters;\n    }\n    return rf;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"794957d0f3853445bdf9319bfb72f8b8c2443a7d","date":1301088393,"type":4,"author":"Ryan McKinley","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/response/ReturnFields#getReturnFields(String,SolrQueryRequest).mjava","sourceNew":null,"sourceOld":"  public static ReturnFields getReturnFields(String fl, SolrQueryRequest req)\n  {\n    ReturnFields rf = new ReturnFields();\n    rf.wantsScore = false;\n    rf.fields = new LinkedHashSet<String>(); // order is important for CSVResponseWriter\n    boolean allFields = false;\n\n    DocTransformers augmenters = new DocTransformers();\n    if (fl != null) {\n      // TODO - this could become more efficient if widely used.\n      String[] flst = SolrPluginUtils.split(fl);\n      if (flst.length > 0 && !(flst.length==1 && flst[0].length()==0)) {\n        IndexSchema schema = req.getSchema();\n        for (String name : flst) {\n          if( \"*\".equals( name ) ) {\n            allFields = true;\n          }\n          else if( SCORE.equals( name ) ) {\n            rf.fields.add( name );\n            rf.wantsScore = true;\n            augmenters.addTransformer( new ScoreAugmenter( SCORE ) );\n          }\n          else {\n            rf.fields.add( name );\n\n            // Check if it is a real score\n            SchemaField sf = schema.getFieldOrNull( name );\n            if( sf == null ) {\n              // not a field name, but possibly return value\n              if( DOCID.equals( name ) ) {\n                augmenters.addTransformer( new DocIdAugmenter( DOCID ) );\n              }\n              else if( SHARD.equals( name ) ) {\n                String id = \"getshardid???\";\n                augmenters.addTransformer( new ValueAugmenter( SHARD, id ) );\n              }\n              else if( EXPLAIN.equals( name ) ) {\n                augmenters.addTransformer( new ExplainAugmenter( EXPLAIN ) );\n              }\n              else if( name.startsWith( \"{!func}\") ) {\n                // help?  not sure how to parse a ValueSorce\n                // -- not to mention, we probably want to reuse existing ones!\n                augmenters.addTransformer( new ValueAugmenter( name, \"TODO:\"+name ) );\n//                try {\n//                  String func = name.substring( \"{!func}\".length() );\n//                  SolrParams local = null;\n//                  FunctionQParser p = new FunctionQParser( func, local, req.getParams(), req );\n//                  Query q = p.parse();\n//                  ValueSource vs = p.parseValueSource();\n//                  AtomicReaderContext ctx = new AtomicReaderContext( req.getSearcher().getIndexReader() );\n//                  Map mmm = null; // ?????\n//                  DocValues values = p.parseValueSource().getValues( mmm, ctx );\n//                  augmenters.addAugmenter( new DocValuesAugmenter( name, values ) );\n//                }\n//                catch( Exception ex ) {\n//                  throw new SolrException( org.apache.solr.common.SolrException.ErrorCode.BAD_REQUEST,\n//                      \"Unable to parse augmented field: \"+name, ex );\n//                }\n              }\n              else { \n                // maybe throw an exception?\n//                throw new SolrException( org.apache.solr.common.SolrException.ErrorCode.BAD_REQUEST,\n//                    \"Unknown Return Field: \"+name );\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Legacy behavior? \"score\" == \"*,score\"\n    if( rf.fields.size() == 1 && rf.wantsScore ) {\n      allFields = true;\n    }\n    \n    if( allFields || rf.fields.isEmpty() ) {\n      rf.fields = null;\n    }\n    \n    if( augmenters.size() == 1 ) {\n      rf.transformer = augmenters.getTransformer(0);\n    }\n    else if( augmenters.size() > 1 ) {\n      rf.transformer = augmenters;\n    }\n    return rf;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"794957d0f3853445bdf9319bfb72f8b8c2443a7d":["6aedf81f068e430dec27d94310415cc6ff52731c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6aedf81f068e430dec27d94310415cc6ff52731c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["794957d0f3853445bdf9319bfb72f8b8c2443a7d"]},"commit2Childs":{"794957d0f3853445bdf9319bfb72f8b8c2443a7d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6aedf81f068e430dec27d94310415cc6ff52731c"],"6aedf81f068e430dec27d94310415cc6ff52731c":["794957d0f3853445bdf9319bfb72f8b8c2443a7d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}