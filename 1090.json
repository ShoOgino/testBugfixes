{"path":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsReaderImpl#readTerm(IndexInput,FieldInfo,TermState,boolean).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsReaderImpl#readTerm(IndexInput,FieldInfo,TermState,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void readTerm(IndexInput termsIn, FieldInfo fieldInfo, TermState _termState, boolean isIndexTerm) throws IOException {\n\n    PulsingTermState termState = (PulsingTermState) _termState;\n\n    termState.pendingIndexTerm |= isIndexTerm;\n\n    if (termState.docFreq <= maxPulsingDocFreq) {\n\n      // Inlined into terms dict -- read everything in\n\n      // TODO: maybe only read everything in lazily?  But\n      // then we'd need to store length so we could seek\n      // over it when docs/pos enum was not requested\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      int docID = 0;\n      for(int i=0;i<termState.docFreq;i++) {\n        Document doc = termState.docs[i];\n        if (doc == null) {\n          doc = termState.docs[i] = new Document();\n        }\n        final int code = termsIn.readVInt();\n        if (fieldInfo.omitTermFreqAndPositions) {\n          docID += code;\n          doc.numPositions = 1;\n        } else {\n          docID += code>>>1;\n          if ((code & 1) != 0) {\n            doc.numPositions = 1;\n          } else {\n            doc.numPositions = termsIn.readVInt();\n          }\n            \n          if (doc.numPositions > doc.positions.length) {\n            doc.reallocPositions(doc.numPositions);\n          }\n\n          int position = 0;\n          int payloadLength = -1;\n\n          for(int j=0;j<doc.numPositions;j++) {\n            final Position pos = doc.positions[j];\n            final int code2 = termsIn.readVInt();\n            if (fieldInfo.storePayloads) {\n              position += code2 >>> 1;\n              if ((code2 & 1) != 0) {\n                payloadLength = termsIn.readVInt();\n              }\n\n              if (payloadLength > 0) {\n                if (pos.payload == null) {\n                  pos.payload = new BytesRef();\n                  pos.payload.bytes = new byte[payloadLength];\n                } else if (payloadLength > pos.payload.bytes.length) {\n                  pos.payload.grow(payloadLength);\n                }\n                pos.payload.length = payloadLength;\n                termsIn.readBytes(pos.payload.bytes, 0, payloadLength);\n              } else if (pos.payload != null) {\n                pos.payload.length = 0;\n              }\n            } else {\n              position += code2;\n            }\n            pos.pos = position;\n          }\n        }\n        doc.docID = docID;\n      }\n    } else {\n      termState.wrappedTermState.docFreq = termState.docFreq;\n      wrappedPostingsReader.readTerm(termsIn, fieldInfo, termState.wrappedTermState, termState.pendingIndexTerm);\n      termState.pendingIndexTerm = false;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d53c3f769ca0f9e7434937b792877770271aecf","date":1294785129,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsReaderImpl#readTerm(IndexInput,FieldInfo,TermState,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsReaderImpl#readTerm(IndexInput,FieldInfo,TermState,boolean).mjava","sourceNew":"  @Override\n  public void readTerm(IndexInput termsIn, FieldInfo fieldInfo, TermState _termState, boolean isIndexTerm) throws IOException {\n\n    PulsingTermState termState = (PulsingTermState) _termState;\n\n    termState.pendingIndexTerm |= isIndexTerm;\n\n    // TODO: wasteful to use whole byte for this (need just a 1 bit);\n    if (termsIn.readByte() == 1) {\n\n      // Inlined into terms dict -- just read the byte[] blob in,\n      // but don't decode it now (we only decode when a DocsEnum\n      // or D&PEnum is pulled):\n      termState.postingsSize = termsIn.readVInt();\n      if (termState.postings == null || termState.postings.length < termState.postingsSize) {\n        termState.postings = new byte[ArrayUtil.oversize(termState.postingsSize, 1)];\n      }\n      termsIn.readBytes(termState.postings, 0, termState.postingsSize);\n    } else {\n      termState.postingsSize = -1;\n      termState.wrappedTermState.docFreq = termState.docFreq;\n      wrappedPostingsReader.readTerm(termsIn, fieldInfo, termState.wrappedTermState, termState.pendingIndexTerm);\n      termState.pendingIndexTerm = false;\n    }\n  }\n\n","sourceOld":"  @Override\n  public void readTerm(IndexInput termsIn, FieldInfo fieldInfo, TermState _termState, boolean isIndexTerm) throws IOException {\n\n    PulsingTermState termState = (PulsingTermState) _termState;\n\n    termState.pendingIndexTerm |= isIndexTerm;\n\n    if (termState.docFreq <= maxPulsingDocFreq) {\n\n      // Inlined into terms dict -- read everything in\n\n      // TODO: maybe only read everything in lazily?  But\n      // then we'd need to store length so we could seek\n      // over it when docs/pos enum was not requested\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      int docID = 0;\n      for(int i=0;i<termState.docFreq;i++) {\n        Document doc = termState.docs[i];\n        if (doc == null) {\n          doc = termState.docs[i] = new Document();\n        }\n        final int code = termsIn.readVInt();\n        if (fieldInfo.omitTermFreqAndPositions) {\n          docID += code;\n          doc.numPositions = 1;\n        } else {\n          docID += code>>>1;\n          if ((code & 1) != 0) {\n            doc.numPositions = 1;\n          } else {\n            doc.numPositions = termsIn.readVInt();\n          }\n            \n          if (doc.numPositions > doc.positions.length) {\n            doc.reallocPositions(doc.numPositions);\n          }\n\n          int position = 0;\n          int payloadLength = -1;\n\n          for(int j=0;j<doc.numPositions;j++) {\n            final Position pos = doc.positions[j];\n            final int code2 = termsIn.readVInt();\n            if (fieldInfo.storePayloads) {\n              position += code2 >>> 1;\n              if ((code2 & 1) != 0) {\n                payloadLength = termsIn.readVInt();\n              }\n\n              if (payloadLength > 0) {\n                if (pos.payload == null) {\n                  pos.payload = new BytesRef();\n                  pos.payload.bytes = new byte[payloadLength];\n                } else if (payloadLength > pos.payload.bytes.length) {\n                  pos.payload.grow(payloadLength);\n                }\n                pos.payload.length = payloadLength;\n                termsIn.readBytes(pos.payload.bytes, 0, payloadLength);\n              } else if (pos.payload != null) {\n                pos.payload.length = 0;\n              }\n            } else {\n              position += code2;\n            }\n            pos.pos = position;\n          }\n        }\n        doc.docID = docID;\n      }\n    } else {\n      termState.wrappedTermState.docFreq = termState.docFreq;\n      wrappedPostingsReader.readTerm(termsIn, fieldInfo, termState.wrappedTermState, termState.pendingIndexTerm);\n      termState.pendingIndexTerm = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa1a999d6674423e5c4ac858b410283f6fe03f20","date":1294868331,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsReaderImpl#readTerm(IndexInput,FieldInfo,PrefixCodedTermState,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsReaderImpl#readTerm(IndexInput,FieldInfo,TermState,boolean).mjava","sourceNew":"  @Override\n  public void readTerm(IndexInput termsIn, FieldInfo fieldInfo, PrefixCodedTermState _termState, boolean isIndexTerm) throws IOException {\n    PulsingTermState termState = (PulsingTermState) _termState;\n\n    termState.pendingIndexTerm |= isIndexTerm;\n\n    // TODO: wasteful to use whole byte for this (need just a 1 bit);\n    if (termsIn.readByte() == 1) {\n\n      // Inlined into terms dict -- just read the byte[] blob in,\n      // but don't decode it now (we only decode when a DocsEnum\n      // or D&PEnum is pulled):\n      termState.postingsSize = termsIn.readVInt();\n      if (termState.postings == null || termState.postings.length < termState.postingsSize) {\n        termState.postings = new byte[ArrayUtil.oversize(termState.postingsSize, 1)];\n      }\n      termsIn.readBytes(termState.postings, 0, termState.postingsSize);\n    } else {\n      termState.postingsSize = -1;\n      termState.wrappedTermState.docFreq = termState.docFreq;\n      wrappedPostingsReader.readTerm(termsIn, fieldInfo, termState.wrappedTermState, termState.pendingIndexTerm);\n      termState.pendingIndexTerm = false;\n    }\n  }\n\n","sourceOld":"  @Override\n  public void readTerm(IndexInput termsIn, FieldInfo fieldInfo, TermState _termState, boolean isIndexTerm) throws IOException {\n\n    PulsingTermState termState = (PulsingTermState) _termState;\n\n    termState.pendingIndexTerm |= isIndexTerm;\n\n    // TODO: wasteful to use whole byte for this (need just a 1 bit);\n    if (termsIn.readByte() == 1) {\n\n      // Inlined into terms dict -- just read the byte[] blob in,\n      // but don't decode it now (we only decode when a DocsEnum\n      // or D&PEnum is pulled):\n      termState.postingsSize = termsIn.readVInt();\n      if (termState.postings == null || termState.postings.length < termState.postingsSize) {\n        termState.postings = new byte[ArrayUtil.oversize(termState.postingsSize, 1)];\n      }\n      termsIn.readBytes(termState.postings, 0, termState.postingsSize);\n    } else {\n      termState.postingsSize = -1;\n      termState.wrappedTermState.docFreq = termState.docFreq;\n      wrappedPostingsReader.readTerm(termsIn, fieldInfo, termState.wrappedTermState, termState.pendingIndexTerm);\n      termState.pendingIndexTerm = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsReaderImpl#readTerm(IndexInput,FieldInfo,TermState,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void readTerm(IndexInput termsIn, FieldInfo fieldInfo, TermState _termState, boolean isIndexTerm) throws IOException {\n\n    PulsingTermState termState = (PulsingTermState) _termState;\n\n    termState.pendingIndexTerm |= isIndexTerm;\n\n    if (termState.docFreq <= maxPulsingDocFreq) {\n\n      // Inlined into terms dict -- read everything in\n\n      // TODO: maybe only read everything in lazily?  But\n      // then we'd need to store length so we could seek\n      // over it when docs/pos enum was not requested\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      int docID = 0;\n      for(int i=0;i<termState.docFreq;i++) {\n        Document doc = termState.docs[i];\n        if (doc == null) {\n          doc = termState.docs[i] = new Document();\n        }\n        final int code = termsIn.readVInt();\n        if (fieldInfo.omitTermFreqAndPositions) {\n          docID += code;\n          doc.numPositions = 1;\n        } else {\n          docID += code>>>1;\n          if ((code & 1) != 0) {\n            doc.numPositions = 1;\n          } else {\n            doc.numPositions = termsIn.readVInt();\n          }\n            \n          if (doc.numPositions > doc.positions.length) {\n            doc.reallocPositions(doc.numPositions);\n          }\n\n          int position = 0;\n          int payloadLength = -1;\n\n          for(int j=0;j<doc.numPositions;j++) {\n            final Position pos = doc.positions[j];\n            final int code2 = termsIn.readVInt();\n            if (fieldInfo.storePayloads) {\n              position += code2 >>> 1;\n              if ((code2 & 1) != 0) {\n                payloadLength = termsIn.readVInt();\n              }\n\n              if (payloadLength > 0) {\n                if (pos.payload == null) {\n                  pos.payload = new BytesRef();\n                  pos.payload.bytes = new byte[payloadLength];\n                } else if (payloadLength > pos.payload.bytes.length) {\n                  pos.payload.grow(payloadLength);\n                }\n                pos.payload.length = payloadLength;\n                termsIn.readBytes(pos.payload.bytes, 0, payloadLength);\n              } else if (pos.payload != null) {\n                pos.payload.length = 0;\n              }\n            } else {\n              position += code2;\n            }\n            pos.pos = position;\n          }\n        }\n        doc.docID = docID;\n      }\n    } else {\n      termState.wrappedTermState.docFreq = termState.docFreq;\n      wrappedPostingsReader.readTerm(termsIn, fieldInfo, termState.wrappedTermState, termState.pendingIndexTerm);\n      termState.pendingIndexTerm = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsReaderImpl#readTerm(IndexInput,FieldInfo,TermState,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void readTerm(IndexInput termsIn, FieldInfo fieldInfo, TermState _termState, boolean isIndexTerm) throws IOException {\n\n    PulsingTermState termState = (PulsingTermState) _termState;\n\n    termState.pendingIndexTerm |= isIndexTerm;\n\n    if (termState.docFreq <= maxPulsingDocFreq) {\n\n      // Inlined into terms dict -- read everything in\n\n      // TODO: maybe only read everything in lazily?  But\n      // then we'd need to store length so we could seek\n      // over it when docs/pos enum was not requested\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      int docID = 0;\n      for(int i=0;i<termState.docFreq;i++) {\n        Document doc = termState.docs[i];\n        if (doc == null) {\n          doc = termState.docs[i] = new Document();\n        }\n        final int code = termsIn.readVInt();\n        if (fieldInfo.omitTermFreqAndPositions) {\n          docID += code;\n          doc.numPositions = 1;\n        } else {\n          docID += code>>>1;\n          if ((code & 1) != 0) {\n            doc.numPositions = 1;\n          } else {\n            doc.numPositions = termsIn.readVInt();\n          }\n            \n          if (doc.numPositions > doc.positions.length) {\n            doc.reallocPositions(doc.numPositions);\n          }\n\n          int position = 0;\n          int payloadLength = -1;\n\n          for(int j=0;j<doc.numPositions;j++) {\n            final Position pos = doc.positions[j];\n            final int code2 = termsIn.readVInt();\n            if (fieldInfo.storePayloads) {\n              position += code2 >>> 1;\n              if ((code2 & 1) != 0) {\n                payloadLength = termsIn.readVInt();\n              }\n\n              if (payloadLength > 0) {\n                if (pos.payload == null) {\n                  pos.payload = new BytesRef();\n                  pos.payload.bytes = new byte[payloadLength];\n                } else if (payloadLength > pos.payload.bytes.length) {\n                  pos.payload.grow(payloadLength);\n                }\n                pos.payload.length = payloadLength;\n                termsIn.readBytes(pos.payload.bytes, 0, payloadLength);\n              } else if (pos.payload != null) {\n                pos.payload.length = 0;\n              }\n            } else {\n              position += code2;\n            }\n            pos.pos = position;\n          }\n        }\n        doc.docID = docID;\n      }\n    } else {\n      termState.wrappedTermState.docFreq = termState.docFreq;\n      wrappedPostingsReader.readTerm(termsIn, fieldInfo, termState.wrappedTermState, termState.pendingIndexTerm);\n      termState.pendingIndexTerm = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"29ef99d61cda9641b6250bf9567329a6e65f901d":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","fa1a999d6674423e5c4ac858b410283f6fe03f20"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3d53c3f769ca0f9e7434937b792877770271aecf":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fa1a999d6674423e5c4ac858b410283f6fe03f20":["3d53c3f769ca0f9e7434937b792877770271aecf"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","fa1a999d6674423e5c4ac858b410283f6fe03f20"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fa1a999d6674423e5c4ac858b410283f6fe03f20"]},"commit2Childs":{"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["29ef99d61cda9641b6250bf9567329a6e65f901d","3d53c3f769ca0f9e7434937b792877770271aecf","868da859b43505d9d2a023bfeae6dd0c795f5295"],"3d53c3f769ca0f9e7434937b792877770271aecf":["fa1a999d6674423e5c4ac858b410283f6fe03f20"],"fa1a999d6674423e5c4ac858b410283f6fe03f20":["29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}