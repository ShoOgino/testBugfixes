{"path":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHistoryHandler#collectLocalReplicaMetrics().mjava","commits":[{"id":"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","date":1527582939,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHistoryHandler#collectLocalReplicaMetrics().mjava","pathOld":"/dev/null","sourceNew":"  private void collectLocalReplicaMetrics() {\n    List<Group> groups = new ArrayList<>();\n    if (enableNodes) {\n      groups.add(Group.jvm);\n      groups.add(Group.node);\n    }\n    if (enableReplicas) {\n      groups.add(Group.core);\n    }\n    for (Group group : groups) {\n      if (Thread.interrupted()) {\n        return;\n      }\n      log.debug(\"--  collecting local \" + group + \"...\");\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(MetricsHandler.GROUP_PARAM, group.toString());\n      params.add(MetricsHandler.COMPACT_PARAM, \"true\");\n      counters.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      gauges.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      AtomicReference<Object> result = new AtomicReference<>();\n      try {\n        metricsHandler.handleRequest(params, (k, v) -> {\n          if (k.equals(\"metrics\")) {\n            result.set(v);\n          }\n        });\n        NamedList nl = (NamedList)result.get();\n        if (nl != null) {\n          for (Iterator<Map.Entry<String, Object>> it = nl.iterator(); it.hasNext(); ) {\n            Map.Entry<String, Object> entry = it.next();\n            String registry = entry.getKey();\n            if (group != Group.core) { // add nodeName suffix\n              registry = registry + \".\" + nodeName;\n            }\n\n            RrdDb db = getOrCreateDb(registry, group);\n            if (db == null) {\n              continue;\n            }\n            // set the timestamp\n            Sample s = db.createSample(TimeUnit.SECONDS.convert(timeSource.getEpochTimeNs(), TimeUnit.NANOSECONDS));\n            NamedList<Object> values = (NamedList<Object>)entry.getValue();\n            AtomicBoolean dirty = new AtomicBoolean(false);\n            counters.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            gauges.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            if (dirty.get()) {\n              s.update();\n            }\n          }\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"257a6da104932110fa3a53e12d46e146db5d8eb6","date":1553203323,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHistoryHandler#collectLocalReplicaMetrics().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHistoryHandler#collectLocalReplicaMetrics().mjava","sourceNew":"  private void collectLocalReplicaMetrics() {\n    List<Group> groups = new ArrayList<>();\n    if (enableNodes) {\n      groups.add(Group.jvm);\n      groups.add(Group.node);\n    }\n    if (enableReplicas) {\n      groups.add(Group.core);\n    }\n    for (Group group : groups) {\n      if (Thread.interrupted()) {\n        return;\n      }\n      log.debug(\"--  collecting local \" + group + \"...\");\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(MetricsHandler.GROUP_PARAM, group.toString());\n      params.add(MetricsHandler.COMPACT_PARAM, \"true\");\n      counters.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      gauges.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      AtomicReference<Object> result = new AtomicReference<>();\n      try {\n        metricsHandler.handleRequest(params, (k, v) -> {\n          if (k.equals(\"metrics\")) {\n            result.set(v);\n          }\n        });\n        NamedList nl = (NamedList)result.get();\n        if (nl != null) {\n          for (Iterator<Map.Entry<String, Object>> it = nl.iterator(); it.hasNext(); ) {\n            Map.Entry<String, Object> entry = it.next();\n            String registry = entry.getKey();\n            if (group != Group.core) { // add nodeName suffix\n              registry = registry + \".\" + nodeName;\n            }\n\n            RrdDb db = getOrCreateDb(registry, group);\n            if (db == null) {\n              continue;\n            }\n            // set the timestamp\n            Sample s = db.createSample(TimeUnit.SECONDS.convert(timeSource.getEpochTimeNs(), TimeUnit.NANOSECONDS));\n            NamedList<Object> values = (NamedList<Object>)entry.getValue();\n            AtomicBoolean dirty = new AtomicBoolean(false);\n            counters.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            gauges.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            if (dirty.get()) {\n              s.update();\n            }\n          }\n        }\n      } catch (Exception e) {\n        log.warn(\"Exception retrieving local metrics for group {}: {}\", group, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void collectLocalReplicaMetrics() {\n    List<Group> groups = new ArrayList<>();\n    if (enableNodes) {\n      groups.add(Group.jvm);\n      groups.add(Group.node);\n    }\n    if (enableReplicas) {\n      groups.add(Group.core);\n    }\n    for (Group group : groups) {\n      if (Thread.interrupted()) {\n        return;\n      }\n      log.debug(\"--  collecting local \" + group + \"...\");\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(MetricsHandler.GROUP_PARAM, group.toString());\n      params.add(MetricsHandler.COMPACT_PARAM, \"true\");\n      counters.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      gauges.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      AtomicReference<Object> result = new AtomicReference<>();\n      try {\n        metricsHandler.handleRequest(params, (k, v) -> {\n          if (k.equals(\"metrics\")) {\n            result.set(v);\n          }\n        });\n        NamedList nl = (NamedList)result.get();\n        if (nl != null) {\n          for (Iterator<Map.Entry<String, Object>> it = nl.iterator(); it.hasNext(); ) {\n            Map.Entry<String, Object> entry = it.next();\n            String registry = entry.getKey();\n            if (group != Group.core) { // add nodeName suffix\n              registry = registry + \".\" + nodeName;\n            }\n\n            RrdDb db = getOrCreateDb(registry, group);\n            if (db == null) {\n              continue;\n            }\n            // set the timestamp\n            Sample s = db.createSample(TimeUnit.SECONDS.convert(timeSource.getEpochTimeNs(), TimeUnit.NANOSECONDS));\n            NamedList<Object> values = (NamedList<Object>)entry.getValue();\n            AtomicBoolean dirty = new AtomicBoolean(false);\n            counters.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            gauges.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            if (dirty.get()) {\n              s.update();\n            }\n          }\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHistoryHandler#collectLocalReplicaMetrics().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHistoryHandler#collectLocalReplicaMetrics().mjava","sourceNew":"  private void collectLocalReplicaMetrics() {\n    List<Group> groups = new ArrayList<>();\n    if (enableNodes) {\n      groups.add(Group.jvm);\n      groups.add(Group.node);\n    }\n    if (enableReplicas) {\n      groups.add(Group.core);\n    }\n    for (Group group : groups) {\n      if (Thread.interrupted()) {\n        return;\n      }\n      log.debug(\"--  collecting local {}...\", group);\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(MetricsHandler.GROUP_PARAM, group.toString());\n      params.add(MetricsHandler.COMPACT_PARAM, \"true\");\n      counters.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      gauges.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      AtomicReference<Object> result = new AtomicReference<>();\n      try {\n        metricsHandler.handleRequest(params, (k, v) -> {\n          if (k.equals(\"metrics\")) {\n            result.set(v);\n          }\n        });\n        NamedList nl = (NamedList)result.get();\n        if (nl != null) {\n          for (Iterator<Map.Entry<String, Object>> it = nl.iterator(); it.hasNext(); ) {\n            Map.Entry<String, Object> entry = it.next();\n            String registry = entry.getKey();\n            if (group != Group.core) { // add nodeName suffix\n              registry = registry + \".\" + nodeName;\n            }\n\n            RrdDb db = getOrCreateDb(registry, group);\n            if (db == null) {\n              continue;\n            }\n            // set the timestamp\n            Sample s = db.createSample(TimeUnit.SECONDS.convert(timeSource.getEpochTimeNs(), TimeUnit.NANOSECONDS));\n            NamedList<Object> values = (NamedList<Object>)entry.getValue();\n            AtomicBoolean dirty = new AtomicBoolean(false);\n            counters.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            gauges.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            if (dirty.get()) {\n              s.update();\n            }\n          }\n        }\n      } catch (Exception e) {\n        log.warn(\"Exception retrieving local metrics for group {}: {}\", group, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void collectLocalReplicaMetrics() {\n    List<Group> groups = new ArrayList<>();\n    if (enableNodes) {\n      groups.add(Group.jvm);\n      groups.add(Group.node);\n    }\n    if (enableReplicas) {\n      groups.add(Group.core);\n    }\n    for (Group group : groups) {\n      if (Thread.interrupted()) {\n        return;\n      }\n      log.debug(\"--  collecting local \" + group + \"...\");\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(MetricsHandler.GROUP_PARAM, group.toString());\n      params.add(MetricsHandler.COMPACT_PARAM, \"true\");\n      counters.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      gauges.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      AtomicReference<Object> result = new AtomicReference<>();\n      try {\n        metricsHandler.handleRequest(params, (k, v) -> {\n          if (k.equals(\"metrics\")) {\n            result.set(v);\n          }\n        });\n        NamedList nl = (NamedList)result.get();\n        if (nl != null) {\n          for (Iterator<Map.Entry<String, Object>> it = nl.iterator(); it.hasNext(); ) {\n            Map.Entry<String, Object> entry = it.next();\n            String registry = entry.getKey();\n            if (group != Group.core) { // add nodeName suffix\n              registry = registry + \".\" + nodeName;\n            }\n\n            RrdDb db = getOrCreateDb(registry, group);\n            if (db == null) {\n              continue;\n            }\n            // set the timestamp\n            Sample s = db.createSample(TimeUnit.SECONDS.convert(timeSource.getEpochTimeNs(), TimeUnit.NANOSECONDS));\n            NamedList<Object> values = (NamedList<Object>)entry.getValue();\n            AtomicBoolean dirty = new AtomicBoolean(false);\n            counters.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            gauges.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            if (dirty.get()) {\n              s.update();\n            }\n          }\n        }\n      } catch (Exception e) {\n        log.warn(\"Exception retrieving local metrics for group {}: {}\", group, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba055e19afc289adcb5bedaf68513793a7254012","date":1591268575,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHistoryHandler#collectLocalReplicaMetrics().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/MetricsHistoryHandler#collectLocalReplicaMetrics().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  private void collectLocalReplicaMetrics() {\n    List<Group> groups = new ArrayList<>();\n    if (enableNodes) {\n      groups.add(Group.jvm);\n      groups.add(Group.node);\n    }\n    if (enableReplicas) {\n      groups.add(Group.core);\n    }\n    for (Group group : groups) {\n      if (Thread.interrupted()) {\n        return;\n      }\n      log.debug(\"--  collecting local {}...\", group);\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(MetricsHandler.GROUP_PARAM, group.toString());\n      params.add(MetricsHandler.COMPACT_PARAM, \"true\");\n      counters.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      gauges.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      AtomicReference<Object> result = new AtomicReference<>();\n      try {\n        metricsHandler.handleRequest(params, (k, v) -> {\n          if (k.equals(\"metrics\")) {\n            result.set(v);\n          }\n        });\n        NamedList nl = (NamedList)result.get();\n        if (nl != null) {\n          for (Iterator<Map.Entry<String, Object>> it = nl.iterator(); it.hasNext(); ) {\n            Map.Entry<String, Object> entry = it.next();\n            String registry = entry.getKey();\n            if (group != Group.core) { // add nodeName suffix\n              registry = registry + \".\" + nodeName;\n            }\n\n            RrdDb db = getOrCreateDb(registry, group);\n            if (db == null) {\n              continue;\n            }\n            // set the timestamp\n            Sample s = db.createSample(TimeUnit.SECONDS.convert(timeSource.getEpochTimeNs(), TimeUnit.NANOSECONDS));\n            NamedList<Object> values = (NamedList<Object>)entry.getValue();\n            AtomicBoolean dirty = new AtomicBoolean(false);\n            counters.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            gauges.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            if (dirty.get()) {\n              s.update();\n            }\n          }\n        }\n      } catch (Exception e) {\n        log.warn(\"Exception retrieving local metrics for group {}: {}\", group, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void collectLocalReplicaMetrics() {\n    List<Group> groups = new ArrayList<>();\n    if (enableNodes) {\n      groups.add(Group.jvm);\n      groups.add(Group.node);\n    }\n    if (enableReplicas) {\n      groups.add(Group.core);\n    }\n    for (Group group : groups) {\n      if (Thread.interrupted()) {\n        return;\n      }\n      log.debug(\"--  collecting local {}...\", group);\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(MetricsHandler.GROUP_PARAM, group.toString());\n      params.add(MetricsHandler.COMPACT_PARAM, \"true\");\n      counters.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      gauges.get(group.toString()).forEach(c -> params.add(MetricsHandler.PREFIX_PARAM, c));\n      AtomicReference<Object> result = new AtomicReference<>();\n      try {\n        metricsHandler.handleRequest(params, (k, v) -> {\n          if (k.equals(\"metrics\")) {\n            result.set(v);\n          }\n        });\n        NamedList nl = (NamedList)result.get();\n        if (nl != null) {\n          for (Iterator<Map.Entry<String, Object>> it = nl.iterator(); it.hasNext(); ) {\n            Map.Entry<String, Object> entry = it.next();\n            String registry = entry.getKey();\n            if (group != Group.core) { // add nodeName suffix\n              registry = registry + \".\" + nodeName;\n            }\n\n            RrdDb db = getOrCreateDb(registry, group);\n            if (db == null) {\n              continue;\n            }\n            // set the timestamp\n            Sample s = db.createSample(TimeUnit.SECONDS.convert(timeSource.getEpochTimeNs(), TimeUnit.NANOSECONDS));\n            NamedList<Object> values = (NamedList<Object>)entry.getValue();\n            AtomicBoolean dirty = new AtomicBoolean(false);\n            counters.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            gauges.get(group.toString()).forEach(c -> {\n              Number val = (Number)values.get(c);\n              if (val != null) {\n                dirty.set(true);\n                s.setValue(c, val.doubleValue());\n              }\n            });\n            if (dirty.get()) {\n              s.update();\n            }\n          }\n        }\n      } catch (Exception e) {\n        log.warn(\"Exception retrieving local metrics for group {}: {}\", group, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba055e19afc289adcb5bedaf68513793a7254012":["575e66bd4b2349209027f6801184da7fc3cba13f"],"257a6da104932110fa3a53e12d46e146db5d8eb6":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["257a6da104932110fa3a53e12d46e146db5d8eb6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba055e19afc289adcb5bedaf68513793a7254012"]},"commit2Childs":{"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["257a6da104932110fa3a53e12d46e146db5d8eb6"],"ba055e19afc289adcb5bedaf68513793a7254012":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"257a6da104932110fa3a53e12d46e146db5d8eb6":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"575e66bd4b2349209027f6801184da7fc3cba13f":["ba055e19afc289adcb5bedaf68513793a7254012"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}