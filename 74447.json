{"path":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","sourceNew":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the enum the state was\n   * obtained from and the enum the state is used for seeking are obtained from\n   * the same {@link IndexReader}.\n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term, true)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the enum the state was\n   * obtained from and the enum the state is used for seeking are obtained from\n   * the same {@link IndexReader}.\n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term, true)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67b14d7d86c9bafba0b1cbe2beb49281c1a8c6eb","date":1373992961,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","sourceNew":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the state was obtained \n   * from the same {@link TermsEnum} instance. \n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term, true)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the enum the state was\n   * obtained from and the enum the state is used for seeking are obtained from\n   * the same {@link IndexReader}.\n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term, true)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","sourceNew":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the state was obtained \n   * from the same {@link TermsEnum} instance. \n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term, true)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the enum the state was\n   * obtained from and the enum the state is used for seeking are obtained from\n   * the same {@link IndexReader}.\n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term, true)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","sourceNew":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the state was obtained \n   * from the same {@link TermsEnum} instance. \n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the state was obtained \n   * from the same {@link TermsEnum} instance. \n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term, true)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["a6a1a39b2854abb66cc1fe2e6bab94a18ada0108"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","sourceNew":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the state was obtained \n   * from the same {@link TermsEnum} instance. \n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the state was obtained \n   * from the same {@link TermsEnum} instance. \n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term, true)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6a1a39b2854abb66cc1fe2e6bab94a18ada0108","date":1550248375,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermsEnum#seekExact(BytesRef,TermState).mjava","sourceNew":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the state was obtained \n   * from the same {@link TermsEnum} instance. \n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public abstract void seekExact(BytesRef term, TermState state) throws IOException;\n\n","sourceOld":"  /**\n   * Expert: Seeks a specific position by {@link TermState} previously obtained\n   * from {@link #termState()}. Callers should maintain the {@link TermState} to\n   * use this method. Low-level implementations may position the TermsEnum\n   * without re-seeking the term dictionary.\n   * <p>\n   * Seeking by {@link TermState} should only be used iff the state was obtained \n   * from the same {@link TermsEnum} instance. \n   * <p>\n   * NOTE: Using this method with an incompatible {@link TermState} might leave\n   * this {@link TermsEnum} in undefined state. On a segment level\n   * {@link TermState} instances are compatible only iff the source and the\n   * target {@link TermsEnum} operate on the same field. If operating on segment\n   * level, TermState instances must not be used across segments.\n   * <p>\n   * NOTE: A seek by {@link TermState} might not restore the\n   * {@link AttributeSource}'s state. {@link AttributeSource} states must be\n   * maintained separately if this method is used.\n   * @param term the term the TermState corresponds to\n   * @param state the {@link TermState}\n   * */\n  public void seekExact(BytesRef term, TermState state) throws IOException {\n    if (!seekExact(term)) {\n      throw new IllegalArgumentException(\"term=\" + term + \" does not exist\");\n    }\n  }\n\n","bugFix":["fd9cc9d77712aba3662f24632df7539ab75e3667","fa1a999d6674423e5c4ac858b410283f6fe03f20","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","67b14d7d86c9bafba0b1cbe2beb49281c1a8c6eb"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["37a0f60745e53927c4c876cfe5b5a58170f0646c"],"67b14d7d86c9bafba0b1cbe2beb49281c1a8c6eb":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["67b14d7d86c9bafba0b1cbe2beb49281c1a8c6eb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a6a1a39b2854abb66cc1fe2e6bab94a18ada0108"],"a6a1a39b2854abb66cc1fe2e6bab94a18ada0108":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"]},"commit2Childs":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["37a0f60745e53927c4c876cfe5b5a58170f0646c","67b14d7d86c9bafba0b1cbe2beb49281c1a8c6eb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"67b14d7d86c9bafba0b1cbe2beb49281c1a8c6eb":["37a0f60745e53927c4c876cfe5b5a58170f0646c","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["a6a1a39b2854abb66cc1fe2e6bab94a18ada0108"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"a6a1a39b2854abb66cc1fe2e6bab94a18ada0108":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}