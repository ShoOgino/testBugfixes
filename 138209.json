{"path":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      valueSource = new ConstValueSource(sp.getFloat());\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    }\n    else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      valueSource = new ConstValueSource(sp.getFloat());\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    }\n    else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      valueSource = new ConstValueSource(sp.getFloat());\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    }\n    else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      valueSource = new ConstValueSource(sp.getFloat());\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    }\n    else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      valueSource = new ConstValueSource(sp.getFloat());\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    }\n    else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a9672b47b5b54b62cbb4f69567f186ce9d8488e","date":1285166890,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      valueSource = new ConstValueSource(sp.getFloat());\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    }\n    else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58f6207f98d96eddff4bee41c445792c249e5b74","date":1285448770,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      valueSource = new ConstValueSource(sp.getFloat());\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    }\n    else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80f6925d29ae169407185d52267ba1969126e1e2","date":1307134127,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c03daa6ddcb4768a702115ec63799cab5fff3d92","date":1307140842,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e7c99bd45fa88a3d93a03fdd773053bef72268e","date":1307218088,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        SchemaField f = req.getSchema().getField(id);\n        valueSource = f.getType().getValueSource(f, this);\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"80f6925d29ae169407185d52267ba1969126e1e2":["58f6207f98d96eddff4bee41c445792c249e5b74"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["80f6925d29ae169407185d52267ba1969126e1e2","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","58f6207f98d96eddff4bee41c445792c249e5b74"],"58f6207f98d96eddff4bee41c445792c249e5b74":["0a9672b47b5b54b62cbb4f69567f186ce9d8488e"],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":["58f6207f98d96eddff4bee41c445792c249e5b74","80f6925d29ae169407185d52267ba1969126e1e2"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["1e7c99bd45fa88a3d93a03fdd773053bef72268e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0a9672b47b5b54b62cbb4f69567f186ce9d8488e":["1da8d55113b689b06716246649de6f62430f15c0"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["80f6925d29ae169407185d52267ba1969126e1e2"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"c03daa6ddcb4768a702115ec63799cab5fff3d92":["58f6207f98d96eddff4bee41c445792c249e5b74","80f6925d29ae169407185d52267ba1969126e1e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"80f6925d29ae169407185d52267ba1969126e1e2":["c26f00b574427b55127e869b935845554afde1fa","1e7c99bd45fa88a3d93a03fdd773053bef72268e","a258fbb26824fd104ed795e5d9033d2d040049ee","c03daa6ddcb4768a702115ec63799cab5fff3d92"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"58f6207f98d96eddff4bee41c445792c249e5b74":["80f6925d29ae169407185d52267ba1969126e1e2","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","1e7c99bd45fa88a3d93a03fdd773053bef72268e","c03daa6ddcb4768a702115ec63799cab5fff3d92"],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"1da8d55113b689b06716246649de6f62430f15c0":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","0a9672b47b5b54b62cbb4f69567f186ce9d8488e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"0a9672b47b5b54b62cbb4f69567f186ce9d8488e":["58f6207f98d96eddff4bee41c445792c249e5b74"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"c03daa6ddcb4768a702115ec63799cab5fff3d92":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","a258fbb26824fd104ed795e5d9033d2d040049ee","c03daa6ddcb4768a702115ec63799cab5fff3d92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}