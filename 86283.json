{"path":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String,boolean).mjava","commits":[{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path, boolean all) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        // pull in external collections too\n        if (\"/clusterstate.json\".equals(path) && all) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(\"/collections\", null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = String.format(\"/collections/%s/state\", collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<String,Object>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"024aa2dd08e51868eaedc7e806186222d94a11e6","date":1397648294,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String,boolean).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path, boolean all) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        // pull in external collections too\n        if (\"/clusterstate.json\".equals(path) && all) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(\"/collections\", null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state\", collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<String,Object>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path, boolean all) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        // pull in external collections too\n        if (\"/clusterstate.json\".equals(path) && all) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(\"/collections\", null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = String.format(\"/collections/%s/state\", collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<String,Object>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String,boolean).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path, boolean all) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        // pull in external collections too\n        if (\"/clusterstate.json\".equals(path) && all) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(\"/collections\", null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state\", collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<String,Object>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"024aa2dd08e51868eaedc7e806186222d94a11e6":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["024aa2dd08e51868eaedc7e806186222d94a11e6"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"]},"commit2Childs":{"024aa2dd08e51868eaedc7e806186222d94a11e6":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["024aa2dd08e51868eaedc7e806186222d94a11e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}