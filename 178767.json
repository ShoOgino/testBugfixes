{"path":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet.Iterator#forwardBinarySearch(int).mjava","commits":[{"id":"6713d909dc80e8c53878ff98bb5376dc1af95956","date":1373964521,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet.Iterator#forwardBinarySearch(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet.Iterator#binarySearch(int).mjava","sourceNew":"    int forwardBinarySearch(int targetWordNum) {\n      // advance forward and double the window at each step\n      final int indexSize = (int) wordNums.size();\n      int lo = sequenceNum / indexInterval, hi = lo + 1;\n      assert sequenceNum == -1 || wordNums.get(lo) <= wordNum;\n      assert lo + 1 == wordNums.size() || wordNums.get(lo + 1) > wordNum;\n      while (true) {\n        if (hi >= indexSize) {\n          hi = indexSize - 1;\n          break;\n        } else if (wordNums.get(hi) >= targetWordNum) {\n          break;\n        }\n        final int newLo = hi;\n        hi += (hi - lo) << 1;\n        lo = newLo;\n      }\n\n      // we found a window containing our target, let's binary search now\n      while (lo <= hi) {\n        final int mid = (lo + hi) >>> 1;\n        final int midWordNum = (int) wordNums.get(mid);\n        if (midWordNum <= targetWordNum) {\n          lo = mid + 1;\n        } else {\n          hi = mid - 1;\n        }\n      }\n      assert wordNums.get(hi) <= targetWordNum;\n      assert hi+1 == wordNums.size() || wordNums.get(hi + 1) > targetWordNum;\n      return hi;\n    }\n\n","sourceOld":"    int binarySearch(int targetWordNum) {\n      int lo = 0, hi = positions.size() - 1;\n      while (lo <= hi) {\n        final int mid = (lo + hi) >>> 1;\n        final int midWordNum = (int) wordNums.get(mid);\n        if (midWordNum <= targetWordNum) {\n          lo = mid + 1;\n        } else {\n          hi = mid - 1;\n        }\n      }\n      assert wordNums.get(hi) <= targetWordNum;\n      assert hi+1 == wordNums.size() || wordNums.get(hi + 1) > targetWordNum;\n      return hi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet.Iterator#forwardBinarySearch(int).mjava","pathOld":"/dev/null","sourceNew":"    int forwardBinarySearch(int targetWordNum) {\n      // advance forward and double the window at each step\n      final int indexSize = (int) wordNums.size();\n      int lo = sequenceNum / indexInterval, hi = lo + 1;\n      assert sequenceNum == -1 || wordNums.get(lo) <= wordNum;\n      assert lo + 1 == wordNums.size() || wordNums.get(lo + 1) > wordNum;\n      while (true) {\n        if (hi >= indexSize) {\n          hi = indexSize - 1;\n          break;\n        } else if (wordNums.get(hi) >= targetWordNum) {\n          break;\n        }\n        final int newLo = hi;\n        hi += (hi - lo) << 1;\n        lo = newLo;\n      }\n\n      // we found a window containing our target, let's binary search now\n      while (lo <= hi) {\n        final int mid = (lo + hi) >>> 1;\n        final int midWordNum = (int) wordNums.get(mid);\n        if (midWordNum <= targetWordNum) {\n          lo = mid + 1;\n        } else {\n          hi = mid - 1;\n        }\n      }\n      assert wordNums.get(hi) <= targetWordNum;\n      assert hi+1 == wordNums.size() || wordNums.get(hi + 1) > targetWordNum;\n      return hi;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8","date":1412674810,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet.Iterator#forwardBinarySearch(int).mjava","sourceNew":null,"sourceOld":"    int forwardBinarySearch(int targetWordNum) {\n      // advance forward and double the window at each step\n      final int indexSize = (int) wordNums.size();\n      int lo = sequenceNum / indexInterval, hi = lo + 1;\n      assert sequenceNum == -1 || wordNums.get(lo) <= wordNum;\n      assert lo + 1 == wordNums.size() || wordNums.get(lo + 1) > wordNum;\n      while (true) {\n        if (hi >= indexSize) {\n          hi = indexSize - 1;\n          break;\n        } else if (wordNums.get(hi) >= targetWordNum) {\n          break;\n        }\n        final int newLo = hi;\n        hi += (hi - lo) << 1;\n        lo = newLo;\n      }\n\n      // we found a window containing our target, let's binary search now\n      while (lo <= hi) {\n        final int mid = (lo + hi) >>> 1;\n        final int midWordNum = (int) wordNums.get(mid);\n        if (midWordNum <= targetWordNum) {\n          lo = mid + 1;\n        } else {\n          hi = mid - 1;\n        }\n      }\n      assert wordNums.get(hi) <= targetWordNum;\n      assert hi+1 == wordNums.size() || wordNums.get(hi + 1) > targetWordNum;\n      return hi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/WAH8DocIdSet.Iterator#forwardBinarySearch(int).mjava","sourceNew":null,"sourceOld":"    int forwardBinarySearch(int targetWordNum) {\n      // advance forward and double the window at each step\n      final int indexSize = (int) wordNums.size();\n      int lo = sequenceNum / indexInterval, hi = lo + 1;\n      assert sequenceNum == -1 || wordNums.get(lo) <= wordNum;\n      assert lo + 1 == wordNums.size() || wordNums.get(lo + 1) > wordNum;\n      while (true) {\n        if (hi >= indexSize) {\n          hi = indexSize - 1;\n          break;\n        } else if (wordNums.get(hi) >= targetWordNum) {\n          break;\n        }\n        final int newLo = hi;\n        hi += (hi - lo) << 1;\n        lo = newLo;\n      }\n\n      // we found a window containing our target, let's binary search now\n      while (lo <= hi) {\n        final int mid = (lo + hi) >>> 1;\n        final int midWordNum = (int) wordNums.get(mid);\n        if (midWordNum <= targetWordNum) {\n          lo = mid + 1;\n        } else {\n          hi = mid - 1;\n        }\n      }\n      assert wordNums.get(hi) <= targetWordNum;\n      assert hi+1 == wordNums.size() || wordNums.get(hi + 1) > targetWordNum;\n      return hi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"55980207f1977bd1463465de1659b821347e2fa8":["6713d909dc80e8c53878ff98bb5376dc1af95956","0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6713d909dc80e8c53878ff98bb5376dc1af95956"],"0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8":["6713d909dc80e8c53878ff98bb5376dc1af95956"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6713d909dc80e8c53878ff98bb5376dc1af95956":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8"]},"commit2Childs":{"55980207f1977bd1463465de1659b821347e2fa8":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","6713d909dc80e8c53878ff98bb5376dc1af95956"],"6713d909dc80e8c53878ff98bb5376dc1af95956":["55980207f1977bd1463465de1659b821347e2fa8","37a0f60745e53927c4c876cfe5b5a58170f0646c","0557ea16725aaafcd3dd3d3ec90445ff1ce22eb8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}