{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector).mjava","commits":[{"id":"8ff44d836e8863507fa8711d2b1b2dd723516ca0","date":1461653163,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector).mjava","pathOld":"/dev/null","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.travelAbovePlane = new Plane(travelPlane, true);\n      this.travelBelowPlane = new Plane(travelPlane, false);\n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n      // Now, find the intersection of the check and test point planes.\n      final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointPlane, testPointCutoffPlane, checkPointCutoffPlane);\n      assert intersectionPoints != null : \"couldn't find any intersections\";\n      assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoints[0]);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n    \n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb","date":1461671204,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n      // Now, find the intersection of the check and test point planes.\n      final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointPlane, testPointCutoffPlane, checkPointCutoffPlane);\n      assert intersectionPoints != null : \"couldn't find any intersections\";\n      assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n      this.intersectionPoint = intersectionPoints[0];\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point\";\n      \n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n      }\n        \n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.travelAbovePlane = new Plane(travelPlane, true);\n      this.travelBelowPlane = new Plane(travelPlane, false);\n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n      // Now, find the intersection of the check and test point planes.\n      final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointPlane, testPointCutoffPlane, checkPointCutoffPlane);\n      assert intersectionPoints != null : \"couldn't find any intersections\";\n      assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoints[0]);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n    \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0108af7050cbe916cac082bcce73081e33e46ce","date":1461692987,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n      // Now, find the intersection of the check and test point planes.\n      final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointPlane, testPointCutoffPlane, checkPointCutoffPlane);\n      assert intersectionPoints != null : \"couldn't find any intersections\";\n      assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n      this.intersectionPoint = intersectionPoints[0];\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point\";\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, travelInsidePlane, insideIntersection);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideIntersection);\n\n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n      // Now, find the intersection of the check and test point planes.\n      final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointPlane, testPointCutoffPlane, checkPointCutoffPlane);\n      assert intersectionPoints != null : \"couldn't find any intersections\";\n      assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n      this.intersectionPoint = intersectionPoints[0];\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point\";\n      \n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n      }\n        \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"265e2d0799e876e7c751a97229b0d8007cd79f0a","date":1461779668,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n        \n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        \n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point\";\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, travelInsidePlane, insideIntersection);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideIntersection);\n\n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n      // Now, find the intersection of the check and test point planes.\n      final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointPlane, testPointCutoffPlane, checkPointCutoffPlane);\n      assert intersectionPoints != null : \"couldn't find any intersections\";\n      assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n      this.intersectionPoint = intersectionPoints[0];\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n        \n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n      \n      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : \"Can be exactly one inside point\";\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, travelInsidePlane, insideIntersection);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideIntersection);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0108af7050cbe916cac082bcce73081e33e46ce":["3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb":["8ff44d836e8863507fa8711d2b1b2dd723516ca0"],"265e2d0799e876e7c751a97229b0d8007cd79f0a":["a0108af7050cbe916cac082bcce73081e33e46ce"],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0108af7050cbe916cac082bcce73081e33e46ce":["265e2d0799e876e7c751a97229b0d8007cd79f0a"],"3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb":["a0108af7050cbe916cac082bcce73081e33e46ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8ff44d836e8863507fa8711d2b1b2dd723516ca0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"265e2d0799e876e7c751a97229b0d8007cd79f0a":[],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":["3ee46d20fdffc22b9a94b7a0154fc2e4e91ea1bb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["265e2d0799e876e7c751a97229b0d8007cd79f0a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}