{"path":"contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","commits":[{"id":"48bedd31c61edafb8baaff4bcbcac19449fb7c3a","date":1251468037,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"contrib/miscellaneous/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList sc = new ArrayList();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = (SpanQuery) sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList positiveClauses = new ArrayList();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = (SpanQuery[]) positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList sc = new ArrayList();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = (SpanQuery) sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList positiveClauses = new ArrayList();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = (SpanQuery[]) positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f11899016a0460a7ea2e4b008d002e1e75c7d867","date":1256772085,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList sc = new ArrayList();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = (SpanQuery) sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList positiveClauses = new ArrayList();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = (SpanQuery[]) positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d57eb7c98c08c03af6e4cd83509df31c81ac16af","date":1257684312,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"48bedd31c61edafb8baaff4bcbcac19449fb7c3a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["f11899016a0460a7ea2e4b008d002e1e75c7d867"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"f11899016a0460a7ea2e4b008d002e1e75c7d867":["48bedd31c61edafb8baaff4bcbcac19449fb7c3a"]},"commit2Childs":{"48bedd31c61edafb8baaff4bcbcac19449fb7c3a":["f11899016a0460a7ea2e4b008d002e1e75c7d867"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["48bedd31c61edafb8baaff4bcbcac19449fb7c3a"],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"f11899016a0460a7ea2e4b008d002e1e75c7d867":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}