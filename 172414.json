{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","commits":[{"id":"1931d98b40b01d5075753b197c2461a5c2652689","date":1471971289,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing();\n\n    int num = (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> missingBuckets = null; // \"_m\" missing buckets that need to specify values for partial facets\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (missingBuckets==null) missingBuckets = new ArrayList<>();\n            missingBuckets.add(bucketRefinement);\n          }\n        }\n\n        // if we didn't add to \"_m\" (missing), then we should add to \"_l\" (leaf missing)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add(bucketRefinement);\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"missing\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || missingBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (missingBuckets != null) refinement.put(\"_m\", missingBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e8220da23feaeb400771f18161c4965dea5ab4cd","84a99d9041ffa5585158e5a283ea1736b6b8b473"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing();\n\n    int num = (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> missingBuckets = null; // \"_m\" missing buckets that need to specify values for partial facets\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (missingBuckets==null) missingBuckets = new ArrayList<>();\n            missingBuckets.add(bucketRefinement);\n          }\n        }\n\n        // if we didn't add to \"_m\" (missing), then we should add to \"_l\" (leaf missing)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add(bucketRefinement);\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"missing\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || missingBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (missingBuckets != null) refinement.put(\"_m\", missingBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb32b2f58e1f02551c5abe6c272b58a970e0bf29","date":1476220416,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or missingBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> missingBuckets = null; // \"_m\" missing buckets that need to specify values for partial facets.. each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (missingBuckets==null) missingBuckets = new ArrayList<>();\n            missingBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_m\" (missing), then we should add to \"_l\" (leaf missing)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"missing\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || missingBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (missingBuckets != null) refinement.put(\"_m\", missingBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing();\n\n    int num = (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> missingBuckets = null; // \"_m\" missing buckets that need to specify values for partial facets\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (missingBuckets==null) missingBuckets = new ArrayList<>();\n            missingBuckets.add(bucketRefinement);\n          }\n        }\n\n        // if we didn't add to \"_m\" (missing), then we should add to \"_l\" (leaf missing)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add(bucketRefinement);\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"missing\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || missingBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (missingBuckets != null) refinement.put(\"_m\", missingBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","bugFix":null,"bugIntro":["e8220da23feaeb400771f18161c4965dea5ab4cd","84a99d9041ffa5585158e5a283ea1736b6b8b473"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or missingBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> missingBuckets = null; // \"_m\" missing buckets that need to specify values for partial facets.. each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (missingBuckets==null) missingBuckets = new ArrayList<>();\n            missingBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_m\" (missing), then we should add to \"_l\" (leaf missing)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"missing\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || missingBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (missingBuckets != null) refinement.put(\"_m\", missingBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85d473096f870b9bf3e231200a07e8eefa30eef8","date":1490745171,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or missingBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> missingBuckets = null; // \"_m\" missing buckets that need to specify values for partial facets.. each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (missingBuckets==null) missingBuckets = new ArrayList<>();\n            missingBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_m\" (missing), then we should add to \"_l\" (leaf missing)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"missing\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || missingBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (missingBuckets != null) refinement.put(\"_m\", missingBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5","date":1490873946,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or missingBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> missingBuckets = null; // \"_m\" missing buckets that need to specify values for partial facets.. each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (missingBuckets==null) missingBuckets = new ArrayList<>();\n            missingBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_m\" (missing), then we should add to \"_l\" (leaf missing)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"missing\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || missingBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (missingBuckets != null) refinement.put(\"_m\", missingBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd","date":1490979270,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14abccfea62dff435ac0457e128ca6bc703087d6","date":1491045405,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    return refinement;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c705a0d590cf911e7c942df49563ca2ea176e22","date":1526916174,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial();\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8220da23feaeb400771f18161c4965dea5ab4cd","date":1530366342,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n    boolean shardHasMore = shardHasMoreBuckets != null && shardHasMoreBuckets.get(mcontext.shardNum);  // shard indicated it has more buckets\n    shardHasMore |= thisMissing;  // if we didn't hear from the shard at all, assume it as more buckets\n\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !shardHasMore && !freq.processEmpty;  // did the shard return all of the possible buckets at this level? (pretend it didn't if processEmpty is set)\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this shard returned all of its possible buckets, and there were no sub-facets with partial results\n      // or sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw && !returnedAllBuckets) {\n        // we didn't see the bucket for this shard, and it's possible that the shard has it\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","bugFix":["1931d98b40b01d5075753b197c2461a5c2652689","fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n    boolean shardHasMore = shardHasMoreBuckets != null && shardHasMoreBuckets.get(mcontext.shardNum);  // shard indicated it has more buckets\n    shardHasMore |= thisMissing;  // if we didn't hear from the shard at all, assume it as more buckets\n\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !shardHasMore && !freq.processEmpty;  // did the shard return all of the possible buckets at this level? (pretend it didn't if processEmpty is set)\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this shard returned all of its possible buckets, and there were no sub-facets with partial results\n      // or sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw && !returnedAllBuckets) {\n        // we didn't see the bucket for this shard, and it's possible that the shard has it\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n    boolean shardHasMore = shardHasMoreBuckets != null && shardHasMoreBuckets.get(mcontext.shardNum);  // shard indicated it has more buckets\n    shardHasMore |= thisMissing;  // if we didn't hear from the shard at all, assume it as more buckets\n\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !shardHasMore && !freq.processEmpty;  // did the shard return all of the possible buckets at this level? (pretend it didn't if processEmpty is set)\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this shard returned all of its possible buckets, and there were no sub-facets with partial results\n      // or sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw && !returnedAllBuckets) {\n        // we didn't see the bucket for this shard, and it's possible that the shard has it\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n\n    // TODO: add information in sub-shard response about dropped buckets (i.e. not all returned due to limit)\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !isCommandPartial && !thisMissing;  // did the shard return all of the possible buckets?\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this facet returned all possible buckets, and there were no sub-facets with partial results\n      // and sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw) {\n        // we didn't see the bucket for this shard\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84a99d9041ffa5585158e5a283ea1736b6b8b473","date":1532019928,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n    boolean shardHasMore = shardHasMoreBuckets != null && shardHasMoreBuckets.get(mcontext.shardNum);  // shard indicated it has more buckets\n    shardHasMore |= thisMissing;  // if we didn't hear from the shard at all, assume it as more buckets\n\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !shardHasMore && !freq.processEmpty;  // did the shard return all of the possible buckets at this level? (pretend it didn't if processEmpty is set)\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this shard returned all of its possible buckets, and there were no sub-facets with partial results\n      // or sub-facets that require refining\n      return null;\n    }\n\n    long numBucketsToCheck = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      numBucketsToCheck = freq.offset + freq.limit; // effective limit\n      if (-1 == freq.overrefine) { // DEFAULT: use heuristic for overrefinement\n\n        // when we don't have to worry about mincount pruning, there is no need for any\n        // over refinement for these sorts..\n        if (freq.mincount <= 1 && (\"index\".equals(freq.sortVariable)\n                                   || (\"count\".equals(freq.sortVariable)\n                                       && FacetRequest.SortDirection.desc == freq.sortDirection))) {\n          // No-Op\n        } else if (0 <= freq.overrequest) {\n          // if user asked for an explicit amount of overrequesting,\n          // (but did not provide an explicit amount of overrefinement)\n          // then use the same amount for overrefinement\n          numBucketsToCheck += freq.overrequest;\n        } else {\n          // default: add 10% plus 4 \n          numBucketsToCheck = (long) (numBucketsToCheck * 1.1 +4); \n        }\n\n        // TODO: should we scale our 'overrefine' (heuristic) value based on 'mincount' ?\n        //\n        // If mincount=M > 1 should we be doing something like numBucketsToCheck *= M ?\n        // Perhaps that would make more sense in the 'overrequest' heuristic calc?\n        //\n        // Maybe we should look at how many buckets were fully populated in phase#1 AND\n        // already meet the 'mincount', and use the the difference between that number\n        // and 'limit' to decide a scaling factor for 'overrefine' ?\n        \n      } else { // user requested an explicit amount of overrefinement\n        numBucketsToCheck += freq.overrefine;\n      }\n    }\n    numBucketsToCheck = Math.min(buckets.size(), numBucketsToCheck);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < numBucketsToCheck) {\n      // no need to sort (yet)\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw && !returnedAllBuckets) {\n        // we didn't see the bucket for this shard, and it's possible that the shard has it\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n    boolean shardHasMore = shardHasMoreBuckets != null && shardHasMoreBuckets.get(mcontext.shardNum);  // shard indicated it has more buckets\n    shardHasMore |= thisMissing;  // if we didn't hear from the shard at all, assume it as more buckets\n\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !shardHasMore && !freq.processEmpty;  // did the shard return all of the possible buckets at this level? (pretend it didn't if processEmpty is set)\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this shard returned all of its possible buckets, and there were no sub-facets with partial results\n      // or sub-facets that require refining\n      return null;\n    }\n\n\n    int num = freq.limit < 0 ? Integer.MAX_VALUE : (int)(freq.offset + freq.limit);\n    int numBucketsToCheck = Math.min(buckets.size(), num);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < num) {\n      // no need to sort\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw && !returnedAllBuckets) {\n        // we didn't see the bucket for this shard, and it's possible that the shard has it\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","bugFix":["1931d98b40b01d5075753b197c2461a5c2652689","fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ce69d020f939568b84a1dbbfbd11bfd9907b73","date":1543618146,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRequestSortedMerger#getRefinement(Context).mjava","sourceNew":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    final FacetRequest.FacetSort initial_sort = null == freq.prelim_sort ? freq.sort : freq.prelim_sort;\n    \n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n    boolean shardHasMore = shardHasMoreBuckets != null && shardHasMoreBuckets.get(mcontext.shardNum);  // shard indicated it has more buckets\n    shardHasMore |= thisMissing;  // if we didn't hear from the shard at all, assume it as more buckets\n\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !shardHasMore && !freq.processEmpty;  // did the shard return all of the possible buckets at this level? (pretend it didn't if processEmpty is set)\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this shard returned all of its possible buckets, and there were no sub-facets with partial results\n      // or sub-facets that require refining\n      return null;\n    }\n\n    long numBucketsToCheck = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      numBucketsToCheck = freq.offset + freq.limit; // effective limit\n      if (-1 == freq.overrefine) { // DEFAULT: use heuristic for overrefinement\n\n        // when we don't have to worry about mincount pruning, there is no need for any\n        // over refinement for these sorts..\n        if (freq.mincount <= 1 && (\"index\".equals(initial_sort.sortVariable)\n                                   || (\"count\".equals(initial_sort.sortVariable)\n                                       && FacetRequest.SortDirection.desc == initial_sort.sortDirection))) {\n          // No-Op\n        } else if (0 <= freq.overrequest) {\n          // if user asked for an explicit amount of overrequesting,\n          // (but did not provide an explicit amount of overrefinement)\n          // then use the same amount for overrefinement\n          numBucketsToCheck += freq.overrequest;\n        } else {\n          // default: add 10% plus 4 \n          numBucketsToCheck = (long) (numBucketsToCheck * 1.1 +4); \n        }\n\n        // TODO: should we scale our 'overrefine' (heuristic) value based on 'mincount' ?\n        //\n        // If mincount=M > 1 should we be doing something like numBucketsToCheck *= M ?\n        // Perhaps that would make more sense in the 'overrequest' heuristic calc?\n        //\n        // Maybe we should look at how many buckets were fully populated in phase#1 AND\n        // already meet the 'mincount', and use the the difference between that number\n        // and 'limit' to decide a scaling factor for 'overrefine' ?\n        \n      } else { // user requested an explicit amount of overrefinement\n        numBucketsToCheck += freq.overrefine;\n      }\n    }\n    numBucketsToCheck = Math.min(buckets.size(), numBucketsToCheck);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < numBucketsToCheck) {\n      // no need to sort (yet)\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // don't re-sort (the prerefinement values) if our subclass already did it\n      if (sortedBuckets == null) {\n        sortBuckets(initial_sort);  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw && !returnedAllBuckets) {\n        // we didn't see the bucket for this shard, and it's possible that the shard has it\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","sourceOld":"  @Override\n  public Map<String, Object> getRefinement(Context mcontext) {\n    // step 1) If this facet request has refining, then we need to fully request top buckets that were not seen by this shard.\n    // step 2) If this facet does not have refining, but some sub-facets do, we need to check/recurse those sub-facets in *every* top bucket.\n    // A combination of the two is possible and makes step 2 redundant for any buckets we fully requested in step 1.\n\n    Map<String,Object> refinement = null;\n\n    Collection<String> tags = mcontext.getSubsWithRefinement(freq);\n    if (tags.isEmpty() && !freq.doRefine()) {\n      // we don't have refining, and neither do our subs\n      return null;\n    }\n\n    // Tags for sub facets that have partial facets somewhere in their children.\n    // If we are missing a bucket for this shard, we'll need to get the specific buckets that need refining.\n    Collection<String> tagsWithPartial = mcontext.getSubsWithPartial(freq);\n\n    boolean thisMissing = mcontext.bucketWasMissing(); // Was this whole facet missing (i.e. inside a bucket that was missing)?\n    boolean shardHasMore = shardHasMoreBuckets != null && shardHasMoreBuckets.get(mcontext.shardNum);  // shard indicated it has more buckets\n    shardHasMore |= thisMissing;  // if we didn't hear from the shard at all, assume it as more buckets\n\n    // If we know we've seen all the buckets from a shard, then we don't have to add to leafBuckets or partialBuckets, only skipBuckets\n    boolean isCommandPartial = freq.returnsPartial() || freq.processEmpty; // TODO: should returnsPartial() check processEmpty internally?\n    boolean returnedAllBuckets = !shardHasMore && !freq.processEmpty;  // did the shard return all of the possible buckets at this level? (pretend it didn't if processEmpty is set)\n\n    if (returnedAllBuckets && tags.isEmpty() && tagsWithPartial.isEmpty()) {\n      // this shard returned all of its possible buckets, and there were no sub-facets with partial results\n      // or sub-facets that require refining\n      return null;\n    }\n\n    long numBucketsToCheck = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      numBucketsToCheck = freq.offset + freq.limit; // effective limit\n      if (-1 == freq.overrefine) { // DEFAULT: use heuristic for overrefinement\n\n        // when we don't have to worry about mincount pruning, there is no need for any\n        // over refinement for these sorts..\n        if (freq.mincount <= 1 && (\"index\".equals(freq.sortVariable)\n                                   || (\"count\".equals(freq.sortVariable)\n                                       && FacetRequest.SortDirection.desc == freq.sortDirection))) {\n          // No-Op\n        } else if (0 <= freq.overrequest) {\n          // if user asked for an explicit amount of overrequesting,\n          // (but did not provide an explicit amount of overrefinement)\n          // then use the same amount for overrefinement\n          numBucketsToCheck += freq.overrequest;\n        } else {\n          // default: add 10% plus 4 \n          numBucketsToCheck = (long) (numBucketsToCheck * 1.1 +4); \n        }\n\n        // TODO: should we scale our 'overrefine' (heuristic) value based on 'mincount' ?\n        //\n        // If mincount=M > 1 should we be doing something like numBucketsToCheck *= M ?\n        // Perhaps that would make more sense in the 'overrequest' heuristic calc?\n        //\n        // Maybe we should look at how many buckets were fully populated in phase#1 AND\n        // already meet the 'mincount', and use the the difference between that number\n        // and 'limit' to decide a scaling factor for 'overrefine' ?\n        \n      } else { // user requested an explicit amount of overrefinement\n        numBucketsToCheck += freq.overrefine;\n      }\n    }\n    numBucketsToCheck = Math.min(buckets.size(), numBucketsToCheck);\n\n    Collection<FacetBucket> bucketList;\n    if (buckets.size() < numBucketsToCheck) {\n      // no need to sort (yet)\n      // todo: but we may need to filter.... simplify by always sorting?\n      bucketList = buckets.values();\n    } else {\n      // only sort once\n      if (sortedBuckets == null) {\n        sortBuckets();  // todo: make sure this filters buckets as well\n      }\n      bucketList = sortedBuckets;\n    }\n\n    ArrayList<Object> leafBuckets = null;    // \"_l\" missing buckets specified by bucket value only (no need to specify anything further)\n    ArrayList<Object> partialBuckets = null; // \"_p\" missing buckets that have a partial sub-facet that need to specify those bucket values... each entry is [bucketval, subs]\n    ArrayList<Object> skipBuckets = null;    // \"_s\" present buckets that we need to recurse into because children facets have refinement requirements. each entry is [bucketval, subs]\n\n    for (FacetBucket bucket : bucketList) {\n      if (numBucketsToCheck-- <= 0) break;\n      // if this bucket is missing,\n      assert thisMissing == false || thisMissing == true && mcontext.getShardFlag(bucket.bucketNumber) == false;\n      boolean saw = !thisMissing && mcontext.getShardFlag(bucket.bucketNumber);\n      if (!saw && !returnedAllBuckets) {\n        // we didn't see the bucket for this shard, and it's possible that the shard has it\n        Map<String,Object> bucketRefinement = null;\n\n        // find facets that we need to fill in buckets for\n        if (!tagsWithPartial.isEmpty()) {\n          boolean prev = mcontext.setBucketWasMissing(true);\n          bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n          mcontext.setBucketWasMissing(prev);\n\n          if (bucketRefinement != null) {\n            if (partialBuckets==null) partialBuckets = new ArrayList<>();\n            partialBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n          }\n        }\n\n        // if we didn't add to \"_p\" (missing with partial sub-facets), then we should add to \"_l\" (missing leaf)\n        if (bucketRefinement == null) {\n          if (leafBuckets == null) leafBuckets = new ArrayList<>();\n          leafBuckets.add(bucket.bucketValue);\n        }\n\n      } else if (!tags.isEmpty()) {\n        // we had this bucket, but we need to recurse to certain children that have refinements\n        Map<String,Object> bucketRefinement = bucket.getRefinement(mcontext, tagsWithPartial);\n        if (bucketRefinement != null) {\n          if (skipBuckets == null) skipBuckets = new ArrayList<>();\n          skipBuckets.add( Arrays.asList(bucket.bucketValue, bucketRefinement) );\n        }\n      }\n\n    }\n\n    // TODO: what if we don't need to refine any variable buckets, but we do need to contribute to numBuckets, missing, allBuckets, etc...\n    // because we were \"partial\".  That will be handled at a higher level (i.e. we'll be in someone's missing bucket?)\n    // TODO: test with a sub-facet with a limit of 0 and something like a missing bucket\n    if (leafBuckets != null || partialBuckets != null || skipBuckets != null) {\n      refinement = new HashMap<>(3);\n      if (leafBuckets != null) refinement.put(\"_l\",leafBuckets);\n      if (partialBuckets != null) refinement.put(\"_p\", partialBuckets);\n      if (skipBuckets != null) refinement.put(\"_s\", skipBuckets);\n    }\n\n    refinement = getRefinementSpecial(mcontext, refinement, tagsWithPartial);\n\n    return refinement;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e8220da23feaeb400771f18161c4965dea5ab4cd":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"14abccfea62dff435ac0457e128ca6bc703087d6":["c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5"],"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd":["85d473096f870b9bf3e231200a07e8eefa30eef8"],"1931d98b40b01d5075753b197c2461a5c2652689":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["84a99d9041ffa5585158e5a283ea1736b6b8b473"],"85d473096f870b9bf3e231200a07e8eefa30eef8":["fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"fb32b2f58e1f02551c5abe6c272b58a970e0bf29":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["09b2046a929f8ee073bf5b75cbbf2b60e413a6bd"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["2c705a0d590cf911e7c942df49563ca2ea176e22","e8220da23feaeb400771f18161c4965dea5ab4cd"],"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5":["fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"84a99d9041ffa5585158e5a283ea1736b6b8b473":["e8220da23feaeb400771f18161c4965dea5ab4cd"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1931d98b40b01d5075753b197c2461a5c2652689"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["2c705a0d590cf911e7c942df49563ca2ea176e22","e8220da23feaeb400771f18161c4965dea5ab4cd"]},"commit2Childs":{"e8220da23feaeb400771f18161c4965dea5ab4cd":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","84a99d9041ffa5585158e5a283ea1736b6b8b473","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"14abccfea62dff435ac0457e128ca6bc703087d6":[],"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"1931d98b40b01d5075753b197c2461a5c2652689":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"85d473096f870b9bf3e231200a07e8eefa30eef8":["09b2046a929f8ee073bf5b75cbbf2b60e413a6bd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"fb32b2f58e1f02551c5abe6c272b58a970e0bf29":["85d473096f870b9bf3e231200a07e8eefa30eef8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["e8220da23feaeb400771f18161c4965dea5ab4cd","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5":["14abccfea62dff435ac0457e128ca6bc703087d6"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1931d98b40b01d5075753b197c2461a5c2652689","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"84a99d9041ffa5585158e5a283ea1736b6b8b473":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["fb32b2f58e1f02551c5abe6c272b58a970e0bf29"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["14abccfea62dff435ac0457e128ca6bc703087d6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}