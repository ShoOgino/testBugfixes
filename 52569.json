{"path":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","commits":[{"id":"a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41","date":1334628185,"type":1,"author":"Christopher John Male","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#findClass(String,String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public Class findClass(String cname, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class clazz = null;\n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7bb7d4caf24bc521fa8ac35f463f50724b4a91d8","date":1343155480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class<?>,AnalysisSPILoader<?>> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class<?>,AnalysisSPILoader<?>>();\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      AnalysisSPILoader<? extends AbstractAnalysisFactory> loader = spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          @SuppressWarnings(\"unchecked\")\n          final Class<? extends T> cl = (Class<? extends T>) loader.lookupClass(m.group(4));\n          return clazz = cl;\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ed18a3e476bf57b0356f349f51b337132d18a1","date":1343155831,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class<?>,AnalysisSPILoader<?>> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class<?>,AnalysisSPILoader<?>>();\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      @SuppressWarnings(\"unchecked\") final AnalysisSPILoader<? extends T> loader =\n        (AnalysisSPILoader<? extends T>) spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          return clazz = loader.lookupClass(m.group(4));\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class<?>,AnalysisSPILoader<?>> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class<?>,AnalysisSPILoader<?>>();\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      AnalysisSPILoader<? extends AbstractAnalysisFactory> loader = spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          @SuppressWarnings(\"unchecked\")\n          final Class<? extends T> cl = (Class<? extends T>) loader.lookupClass(m.group(4));\n          return clazz = cl;\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"718655a894a765091a6c32c07c934cec9d30a6e8","date":1343172487,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class<?>,AnalysisSPILoader<?>> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class<?>,AnalysisSPILoader<?>>(3);\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      @SuppressWarnings(\"unchecked\") final AnalysisSPILoader<? extends T> loader =\n        (AnalysisSPILoader<? extends T>) spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          return clazz = loader.lookupClass(m.group(4));\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class<?>,AnalysisSPILoader<?>> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class<?>,AnalysisSPILoader<?>>();\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      @SuppressWarnings(\"unchecked\") final AnalysisSPILoader<? extends T> loader =\n        (AnalysisSPILoader<? extends T>) spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          return clazz = loader.lookupClass(m.group(4));\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a1a22b1ad88b436661458df567f3fdb446392a4","date":1343224444,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class<?>,AnalysisSPILoader<?>> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class<?>,AnalysisSPILoader<?>>(3);\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      @SuppressWarnings(\"unchecked\") final AnalysisSPILoader<? extends T> loader =\n        (AnalysisSPILoader<? extends T>) spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          return clazz = loader.lookupClass(m.group(4));\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a27fdb7e04c34eaf52148516eac5363d92dd461d","date":1343226902,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class,AnalysisSPILoader> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class,AnalysisSPILoader>(3);\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      final AnalysisSPILoader loader = spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          return clazz = loader.lookupClass(m.group(4));\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class<?>,AnalysisSPILoader<?>> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class<?>,AnalysisSPILoader<?>>(3);\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      @SuppressWarnings(\"unchecked\") final AnalysisSPILoader<? extends T> loader =\n        (AnalysisSPILoader<? extends T>) spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          return clazz = loader.lookupClass(m.group(4));\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06586e39a702fbad3b90347238898fac602afebc","date":1343228148,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class<?>,AnalysisSPILoader<?>> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class<?>,AnalysisSPILoader<?>>(3);\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      final AnalysisSPILoader<?> loader = spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          return clazz = loader.lookupClass(m.group(4)).asSubclass(expectedType);\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class,AnalysisSPILoader> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class,AnalysisSPILoader>(3);\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      final AnalysisSPILoader loader = spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          return clazz = loader.lookupClass(m.group(4));\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9499b09dd7d06d975f31e59a9b00653a86f9cad2","date":1343325589,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      final String name = m.group(4);\n      log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n      try {\n        if (CharFilterFactory.class == expectedType) {\n          return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenizerFactory.class == expectedType) {\n          return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenFilterFactory.class == expectedType) {\n          return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else {\n          log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n        }\n      } catch (IllegalArgumentException ex) { \n        // ok, we fall back to legacy loading\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      log.trace(\"Trying to load class from analysis SPI\");\n      // retrieve the map of classLoader -> expectedType -> SPI from cache / regenerate cache\n      Map<Class<?>,AnalysisSPILoader<?>> spiLoaders = expectedTypesSPILoaders.get(classLoader);\n      if (spiLoaders == null) {\n        spiLoaders = new IdentityHashMap<Class<?>,AnalysisSPILoader<?>>(3);\n        spiLoaders.put(CharFilterFactory.class, CharFilterFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenizerFactory.class, TokenizerFactory.getSPILoader(classLoader));\n        spiLoaders.put(TokenFilterFactory.class, TokenFilterFactory.getSPILoader(classLoader));\n        expectedTypesSPILoaders.put(classLoader, spiLoaders);\n      }\n      final AnalysisSPILoader<?> loader = spiLoaders.get(expectedType);\n      if (loader != null) {\n        // it's a correct expected type for analysis! Let's go on!\n        try {\n          return clazz = loader.lookupClass(m.group(4)).asSubclass(expectedType);\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15fcf24b725fe0901ab0bc6ba99c4b6702bdbe6b","date":1343349084,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      final String name = m.group(4);\n      log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n      try {\n        if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else {\n          log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n        }\n      } catch (IllegalArgumentException ex) { \n        // ok, we fall back to legacy loading\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      final String name = m.group(4);\n      log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n      try {\n        if (CharFilterFactory.class == expectedType) {\n          return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenizerFactory.class == expectedType) {\n          return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenFilterFactory.class == expectedType) {\n          return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else {\n          log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n        }\n      } catch (IllegalArgumentException ex) { \n        // ok, we fall back to legacy loading\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      final String name = m.group(4);\n      log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n      try {\n        if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else {\n          log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n        }\n      } catch (IllegalArgumentException ex) { \n        // ok, we fall back to legacy loading\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      final String name = m.group(4);\n      log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n      try {\n        if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else {\n          log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n        }\n      } catch (IllegalArgumentException ex) { \n        // ok, we fall back to legacy loading\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ece367783f1064f12ed72eabac9cc1afeb402b3c","date":1364362226,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      final String name = m.group(4);\n      log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n      try {\n        if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else {\n          log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n        }\n      } catch (IllegalArgumentException ex) { \n        // ok, we fall back to legacy loading\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cnams starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      final String name = m.group(4);\n      log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n      try {\n        if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else {\n          log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n        }\n      } catch (IllegalArgumentException ex) { \n        // ok, we fall back to legacy loading\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"021228638678a783a6504210bf8c774e3826a517","date":1383144999,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    \n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n      \n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName=cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length()+1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n    \n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n      }\n      \n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n        \n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    Class<? extends T> clazz = null;\n    \n    // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n    final Matcher m = legacyAnalysisPattern.matcher(cname);\n    if (m.matches()) {\n      final String name = m.group(4);\n      log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n      try {\n        if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n        } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n          return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n        } else {\n          log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n        }\n      } catch (IllegalArgumentException ex) { \n        // ok, we fall back to legacy loading\n      }\n    }\n    \n    // first try cname == full name\n    try {\n      return Class.forName(cname, true, classLoader).asSubclass(expectedType);\n    } catch (ClassNotFoundException e) {\n      String newName=cname;\n      if (newName.startsWith(project)) {\n        newName = cname.substring(project.length()+1);\n      }\n      for (String subpackage : subpackages) {\n        try {\n          String name = base + '.' + subpackage + newName;\n          log.trace(\"Trying class name \" + name);\n          return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          // ignore... assume first exception is best.\n        }\n      }\n  \n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n    }finally{\n      //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n      // using a shortname\n      if ( clazz != null &&\n              clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n        //store in the cache\n        classNameCache.put(cname, clazz.getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    \n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n      \n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName=cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length()+1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n    \n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n      }\n      \n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n        \n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with it's FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    \n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n      \n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName=cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length()+1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n    \n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n      }\n      \n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n        \n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4786eec79a4a669f3272f3a918bc98d63ff01490","date":1570052154,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n    \n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n      \n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName=cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length()+1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n    \n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n      }\n      \n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n        \n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    \n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n      \n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName=cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length()+1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n    \n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n      }\n      \n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n        \n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","bugFix":["ce9b5906e1d22b2ce403e830541170072f2ef60c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n    \n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n      \n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName=cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length()+1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n    \n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n      }\n      \n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n        \n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException e) {\n          //this is unlikely\n          log.error(\"Unable to load cached class-name :  \"+ c +\" for shortname : \"+cname + e);\n        }\n\n      }\n    }\n    \n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n      \n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName=cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length()+1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n    \n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n      }\n      \n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n        \n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"954ae83b7dfacaa33d48ea056448ae11f7745a93","date":1571867711,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn( name + \" Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n\n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String  c = classNameCache.get(cname);\n      if(c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n    \n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) { \n          // ok, we fall back to legacy loading\n        }\n      }\n      \n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName=cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length()+1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name,true,classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n    \n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error loading class '\" + cname + \"'\", e);\n      }\n      \n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n              !cname.equals(clazz.getName()) &&\n              (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n        \n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3","date":1583932828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn( name + \" Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n\n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(\"solr\")) {\n          newName = cname.substring(\"solr\".length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn( name + \" Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n\n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(project)) {\n          newName = cname.substring(project.length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"{} Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", name , c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n\n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            if (log.isWarnEnabled()) {\n              log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n            }\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(\"solr\")) {\n          newName = cname.substring(\"solr\".length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name {}\", name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn( name + \" Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n\n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(\"solr\")) {\n          newName = cname.substring(\"solr\".length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name \" + name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"{} Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", name , c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n\n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(\"solr\")) {\n          newName = cname.substring(\"solr\".length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name {}\", name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"{} Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", name , c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n\n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            if (log.isWarnEnabled()) {\n              log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n            }\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(\"solr\")) {\n          newName = cname.substring(\"solr\".length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name {}\", name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f53fd7227ce17ccc6445b3433d004cb6ac33e08a","date":1600333804,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"{} Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", name , c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n    Class<? extends T> clazz = null;\n    clazz = getPackageClass(cname, expectedType);\n    if(clazz != null) return clazz;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(\"solr\")) {\n          newName = cname.substring(\"solr\".length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name {}\", name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"{} Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", name , c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n\n    Class<? extends T> clazz = null;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(\"solr\")) {\n          newName = cname.substring(\"solr\".length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name {}\", name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"405ba2c408c37cdb9d56bda3197a43b96e4e49ea","date":1601555499,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrResourceLoader#[T]_findClass(String,Class[T],String...).mjava","sourceNew":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"{} Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", name , c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n    Class<? extends T> clazz = null;\n    clazz = getPackageClass(cname, expectedType);\n    if(clazz != null) return clazz;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(\"solr\")) {\n          newName = cname.substring(\"solr\".length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name {}\", name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          DeprecationLog.log(cname,\n            \"Solr loaded a deprecated plugin/analysis class [\" + cname + \"]. Please consult documentation how to replace it accordingly.\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This method loads a class either with its FQN or a short-name (solr.class-simplename or class-simplename).\n   * It tries to load the class with the name that is given first and if it fails, it tries all the known\n   * solr packages. This method caches the FQN of a short-name in a static map in-order to make subsequent lookups\n   * for the same class faster. The caching is done only if the class is loaded by the webapp classloader and it\n   * is loaded using a shortname.\n   *\n   * @param cname       The name or the short name of the class.\n   * @param subpackages the packages to be tried if the cname starts with solr.\n   * @return the loaded class. An exception is thrown if it fails\n   */\n  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {\n    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {\n      subpackages = packages;\n      String c = classNameCache.get(cname);\n      if (c != null) {\n        try {\n          return Class.forName(c, true, classLoader).asSubclass(expectedType);\n        } catch (ClassNotFoundException | ClassCastException e) {\n          // this can happen if the legacyAnalysisPattern below caches the wrong thing\n          log.warn(\"{} Unable to load cached class, attempting lookup. name={} shortname={} reason={}\", name , c, cname, e);\n          classNameCache.remove(cname);\n        }\n      }\n    }\n    Class<? extends T> clazz = null;\n    clazz = getPackageClass(cname, expectedType);\n    if(clazz != null) return clazz;\n    try {\n      // first try legacy analysis patterns, now replaced by Lucene's Analysis package:\n      final Matcher m = legacyAnalysisPattern.matcher(cname);\n      if (m.matches()) {\n        final String name = m.group(4);\n        log.trace(\"Trying to load class from analysis SPI using name='{}'\", name);\n        try {\n          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);\n          } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);\n          } else {\n            log.warn(\"'{}' looks like an analysis factory, but caller requested different class type: {}\", cname, expectedType.getName());\n          }\n        } catch (IllegalArgumentException ex) {\n          // ok, we fall back to legacy loading\n        }\n      }\n\n      // first try cname == full name\n      try {\n        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        String newName = cname;\n        if (newName.startsWith(\"solr\")) {\n          newName = cname.substring(\"solr\".length() + 1);\n        }\n        for (String subpackage : subpackages) {\n          try {\n            String name = base + '.' + subpackage + newName;\n            log.trace(\"Trying class name {}\", name);\n            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);\n          } catch (ClassNotFoundException e1) {\n            // ignore... assume first exception is best.\n          }\n        }\n\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +\" Error loading class '\" + cname + \"'\", e);\n      }\n\n    } finally {\n      if (clazz != null) {\n        //cache the shortname vs FQN if it is loaded by the webapp classloader  and it is loaded\n        // using a shortname\n        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() &&\n            !cname.equals(clazz.getName()) &&\n            (subpackages.length == 0 || subpackages == packages)) {\n          //store in the cache\n          classNameCache.put(cname, clazz.getName());\n        }\n\n        // print warning if class is deprecated\n        if (clazz.isAnnotationPresent(Deprecated.class)) {\n          log.warn(\"Solr loaded a deprecated plugin/analysis class [{}]. Please consult documentation how to replace it accordingly.\",\n              cname);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f53fd7227ce17ccc6445b3433d004cb6ac33e08a":["575e66bd4b2349209027f6801184da7fc3cba13f"],"718655a894a765091a6c32c07c934cec9d30a6e8":["29ed18a3e476bf57b0356f349f51b337132d18a1"],"7bb7d4caf24bc521fa8ac35f463f50724b4a91d8":["a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41"],"575e66bd4b2349209027f6801184da7fc3cba13f":["140be51d03394488536f4aacedace29f9b318347"],"4786eec79a4a669f3272f3a918bc98d63ff01490":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"021228638678a783a6504210bf8c774e3826a517":["ece367783f1064f12ed72eabac9cc1afeb402b3c"],"ece367783f1064f12ed72eabac9cc1afeb402b3c":["15fcf24b725fe0901ab0bc6ba99c4b6702bdbe6b"],"5a1a22b1ad88b436661458df567f3fdb446392a4":["a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41","718655a894a765091a6c32c07c934cec9d30a6e8"],"29ed18a3e476bf57b0356f349f51b337132d18a1":["7bb7d4caf24bc521fa8ac35f463f50724b4a91d8"],"405ba2c408c37cdb9d56bda3197a43b96e4e49ea":["f53fd7227ce17ccc6445b3433d004cb6ac33e08a"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["021228638678a783a6504210bf8c774e3826a517"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["4786eec79a4a669f3272f3a918bc98d63ff01490"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41","15fcf24b725fe0901ab0bc6ba99c4b6702bdbe6b"],"15fcf24b725fe0901ab0bc6ba99c4b6702bdbe6b":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["06586e39a702fbad3b90347238898fac602afebc"],"140be51d03394488536f4aacedace29f9b318347":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41","15fcf24b725fe0901ab0bc6ba99c4b6702bdbe6b"],"06586e39a702fbad3b90347238898fac602afebc":["a27fdb7e04c34eaf52148516eac5363d92dd461d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["405ba2c408c37cdb9d56bda3197a43b96e4e49ea"],"a27fdb7e04c34eaf52148516eac5363d92dd461d":["5a1a22b1ad88b436661458df567f3fdb446392a4"],"b0b597c65628ca9e73913a07e81691f8229bae35":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","4786eec79a4a669f3272f3a918bc98d63ff01490"]},"commit2Childs":{"f53fd7227ce17ccc6445b3433d004cb6ac33e08a":["405ba2c408c37cdb9d56bda3197a43b96e4e49ea"],"718655a894a765091a6c32c07c934cec9d30a6e8":["5a1a22b1ad88b436661458df567f3fdb446392a4"],"7bb7d4caf24bc521fa8ac35f463f50724b4a91d8":["29ed18a3e476bf57b0356f349f51b337132d18a1"],"575e66bd4b2349209027f6801184da7fc3cba13f":["f53fd7227ce17ccc6445b3433d004cb6ac33e08a"],"4786eec79a4a669f3272f3a918bc98d63ff01490":["954ae83b7dfacaa33d48ea056448ae11f7745a93","b0b597c65628ca9e73913a07e81691f8229bae35"],"021228638678a783a6504210bf8c774e3826a517":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"ece367783f1064f12ed72eabac9cc1afeb402b3c":["021228638678a783a6504210bf8c774e3826a517"],"5a1a22b1ad88b436661458df567f3fdb446392a4":["a27fdb7e04c34eaf52148516eac5363d92dd461d"],"29ed18a3e476bf57b0356f349f51b337132d18a1":["718655a894a765091a6c32c07c934cec9d30a6e8"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["4786eec79a4a669f3272f3a918bc98d63ff01490","b0b597c65628ca9e73913a07e81691f8229bae35"],"405ba2c408c37cdb9d56bda3197a43b96e4e49ea":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["140be51d03394488536f4aacedace29f9b318347"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"15fcf24b725fe0901ab0bc6ba99c4b6702bdbe6b":["ece367783f1064f12ed72eabac9cc1afeb402b3c","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["15fcf24b725fe0901ab0bc6ba99c4b6702bdbe6b"],"a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41":["7bb7d4caf24bc521fa8ac35f463f50724b4a91d8","5a1a22b1ad88b436661458df567f3fdb446392a4","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"140be51d03394488536f4aacedace29f9b318347":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"06586e39a702fbad3b90347238898fac602afebc":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"a27fdb7e04c34eaf52148516eac5363d92dd461d":["06586e39a702fbad3b90347238898fac602afebc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}