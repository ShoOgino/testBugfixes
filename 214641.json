{"path":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","commits":[{"id":"73d216e8a31fcc28595d9f9518b2f081d9379789","date":1333813682,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    List<Class> tokenizersList = new ArrayList<Class>();\n    List<Class> tokenfiltersList = new ArrayList<Class>();\n    for (Class c : analysisClasses) {\n      // don't waste time with abstract classes or deprecated known-buggy ones\n      if (Modifier.isAbstract(c.getModifiers()) || c.getAnnotation(Deprecated.class) != null\n          // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n          || c.equals(EmptyTokenizer.class)\n          // doesn't actual reset itself!\n          || c.equals(CachingTokenFilter.class)\n          // broken!\n          || c.equals(NGramTokenizer.class)\n          // broken!\n          || c.equals(NGramTokenFilter.class)\n          // broken!\n          || c.equals(EdgeNGramTokenizer.class)\n          // broken!\n          || c.equals(EdgeNGramTokenFilter.class)) {\n        continue;\n      }\n      if (Tokenizer.class.isAssignableFrom(c)) {\n        tokenizersList.add(c);\n      } else if (TokenFilter.class.isAssignableFrom(c)) {\n        tokenfiltersList.add(c);\n      }\n    }\n    tokenizers = tokenizersList.toArray(new Class[0]);\n    Arrays.sort(tokenizers, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    tokenfilters = tokenfiltersList.toArray(new Class[0]);\n    Arrays.sort(tokenfilters, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + Arrays.toString(tokenizers));\n      System.out.println(\"tokenfilters = \" + Arrays.toString(tokenfilters));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b9812246deee2216de0db0ea556e1ff163f5793","date":1333820236,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    List<Class> tokenizersList = new ArrayList<Class>();\n    List<Class> tokenfiltersList = new ArrayList<Class>();\n    List<Class> charfiltersList = new ArrayList<Class>();\n    for (Class c : analysisClasses) {\n      // don't waste time with abstract classes or deprecated known-buggy ones\n      if (Modifier.isAbstract(c.getModifiers()) || c.getAnnotation(Deprecated.class) != null\n          // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n          || c.equals(EmptyTokenizer.class)\n          // doesn't actual reset itself!\n          || c.equals(CachingTokenFilter.class)\n          // broken!\n          || c.equals(NGramTokenizer.class)\n          // broken!\n          || c.equals(NGramTokenFilter.class)\n          // broken!\n          || c.equals(EdgeNGramTokenizer.class)\n          // broken!\n          || c.equals(EdgeNGramTokenFilter.class)) {\n        continue;\n      }\n      if (Tokenizer.class.isAssignableFrom(c)) {\n        tokenizersList.add(c);\n      } else if (TokenFilter.class.isAssignableFrom(c)) {\n        tokenfiltersList.add(c);\n      } else if (CharStream.class.isAssignableFrom(c)) {\n        charfiltersList.add(c);\n      }\n    }\n    tokenizers = tokenizersList.toArray(new Class[0]);\n    Arrays.sort(tokenizers, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    tokenfilters = tokenfiltersList.toArray(new Class[0]);\n    Arrays.sort(tokenfilters, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    charfilters = charfiltersList.toArray(new Class[0]);\n    Arrays.sort(charfilters, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + Arrays.toString(tokenizers));\n      System.out.println(\"tokenfilters = \" + Arrays.toString(tokenfilters));\n      System.out.println(\"charfilters = \" + Arrays.toString(charfilters));\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    List<Class> tokenizersList = new ArrayList<Class>();\n    List<Class> tokenfiltersList = new ArrayList<Class>();\n    for (Class c : analysisClasses) {\n      // don't waste time with abstract classes or deprecated known-buggy ones\n      if (Modifier.isAbstract(c.getModifiers()) || c.getAnnotation(Deprecated.class) != null\n          // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n          || c.equals(EmptyTokenizer.class)\n          // doesn't actual reset itself!\n          || c.equals(CachingTokenFilter.class)\n          // broken!\n          || c.equals(NGramTokenizer.class)\n          // broken!\n          || c.equals(NGramTokenFilter.class)\n          // broken!\n          || c.equals(EdgeNGramTokenizer.class)\n          // broken!\n          || c.equals(EdgeNGramTokenFilter.class)) {\n        continue;\n      }\n      if (Tokenizer.class.isAssignableFrom(c)) {\n        tokenizersList.add(c);\n      } else if (TokenFilter.class.isAssignableFrom(c)) {\n        tokenfiltersList.add(c);\n      }\n    }\n    tokenizers = tokenizersList.toArray(new Class[0]);\n    Arrays.sort(tokenizers, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    tokenfilters = tokenfiltersList.toArray(new Class[0]);\n    Arrays.sort(tokenfilters, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + Arrays.toString(tokenizers));\n      System.out.println(\"tokenfilters = \" + Arrays.toString(tokenfilters));\n    }\n  }\n\n","bugFix":null,"bugIntro":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a75004531a9cdf4ad1c7a295d1c822057af45b87","date":1333836028,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Class<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Class<? extends TokenFilter>>();\n    charfilters = new ArrayList<Class<? extends CharStream>>();\n    for (Class<?> c : analysisClasses) {\n      // don't waste time with abstract classes or deprecated known-buggy ones\n      final int modifiers = c.getModifiers();\n      if (Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n          || c.getAnnotation(Deprecated.class) != null\n          || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n          // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n          || c.equals(EmptyTokenizer.class)\n          // doesn't actual reset itself!\n          || c.equals(CachingTokenFilter.class)\n          // broken!\n          || c.equals(NGramTokenizer.class)\n          // broken!\n          || c.equals(NGramTokenFilter.class)\n          // broken!\n          || c.equals(EdgeNGramTokenizer.class)\n          // broken!\n          || c.equals(EdgeNGramTokenFilter.class)) {\n        continue;\n      }\n      if (Tokenizer.class.isAssignableFrom(c)) {\n        tokenizers.add(c.asSubclass(Tokenizer.class));\n      } else if (TokenFilter.class.isAssignableFrom(c)) {\n        tokenfilters.add(c.asSubclass(TokenFilter.class));\n      } else if (CharStream.class.isAssignableFrom(c)) {\n        charfilters.add(c.asSubclass(CharStream.class));\n      }\n    }\n    final Comparator<Class<?>> classComp = new Comparator<Class<?>>() {\n      @Override\n      public int compare(Class<?> arg0, Class<?> arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    };\n    Collections.sort(tokenizers, classComp);\n    Collections.sort(tokenfilters, classComp);\n    Collections.sort(charfilters, classComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    List<Class> tokenizersList = new ArrayList<Class>();\n    List<Class> tokenfiltersList = new ArrayList<Class>();\n    List<Class> charfiltersList = new ArrayList<Class>();\n    for (Class c : analysisClasses) {\n      // don't waste time with abstract classes or deprecated known-buggy ones\n      if (Modifier.isAbstract(c.getModifiers()) || c.getAnnotation(Deprecated.class) != null\n          // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n          || c.equals(EmptyTokenizer.class)\n          // doesn't actual reset itself!\n          || c.equals(CachingTokenFilter.class)\n          // broken!\n          || c.equals(NGramTokenizer.class)\n          // broken!\n          || c.equals(NGramTokenFilter.class)\n          // broken!\n          || c.equals(EdgeNGramTokenizer.class)\n          // broken!\n          || c.equals(EdgeNGramTokenFilter.class)) {\n        continue;\n      }\n      if (Tokenizer.class.isAssignableFrom(c)) {\n        tokenizersList.add(c);\n      } else if (TokenFilter.class.isAssignableFrom(c)) {\n        tokenfiltersList.add(c);\n      } else if (CharStream.class.isAssignableFrom(c)) {\n        charfiltersList.add(c);\n      }\n    }\n    tokenizers = tokenizersList.toArray(new Class[0]);\n    Arrays.sort(tokenizers, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    tokenfilters = tokenfiltersList.toArray(new Class[0]);\n    Arrays.sort(tokenfilters, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    charfilters = charfiltersList.toArray(new Class[0]);\n    Arrays.sort(charfilters, new Comparator<Class>() {\n      @Override\n      public int compare(Class arg0, Class arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    });\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + Arrays.toString(tokenizers));\n      System.out.println(\"tokenfilters = \" + Arrays.toString(tokenfilters));\n      System.out.println(\"charfilters = \" + Arrays.toString(charfilters));\n    }\n  }\n\n","bugFix":null,"bugIntro":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83fce48948948c503c3bd6d3f18e48ad21a9239c","date":1333837677,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Class<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Class<? extends TokenFilter>>();\n    charfilters = new ArrayList<Class<? extends CharStream>>();\n    for (Class<?> c : analysisClasses) {\n      // don't waste time with abstract classes or deprecated known-buggy ones\n      final int modifiers = c.getModifiers();\n      if (Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n          || c.getAnnotation(Deprecated.class) != null\n          || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n          // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n          || c.equals(EmptyTokenizer.class)\n          // doesn't actual reset itself!\n          || c.equals(CachingTokenFilter.class)\n          // broken!\n          || c.equals(NGramTokenizer.class)\n          // broken!\n          || c.equals(NGramTokenFilter.class)\n          // broken!\n          || c.equals(EdgeNGramTokenizer.class)\n          // broken!\n          || c.equals(EdgeNGramTokenFilter.class)) {\n        continue;\n      }\n      if (Tokenizer.class.isAssignableFrom(c)) {\n        tokenizers.add(c.asSubclass(Tokenizer.class));\n      } else if (TokenFilter.class.isAssignableFrom(c)) {\n        tokenfilters.add(c.asSubclass(TokenFilter.class));\n      } else if (CharStream.class.isAssignableFrom(c)) {\n        charfilters.add(c.asSubclass(CharStream.class));\n      }\n    }\n    final Comparator<Class<?>> classComp = new Comparator<Class<?>>() {\n      @Override\n      public int compare(Class<?> arg0, Class<?> arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    };\n    Collections.sort(tokenizers, classComp);\n    Collections.sort(tokenfilters, classComp);\n    Collections.sort(charfilters, classComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Class<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Class<? extends TokenFilter>>();\n    charfilters = new ArrayList<Class<? extends CharStream>>();\n    for (Class<?> c : analysisClasses) {\n      // don't waste time with abstract classes or deprecated known-buggy ones\n      final int modifiers = c.getModifiers();\n      if (Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n          || c.getAnnotation(Deprecated.class) != null\n          || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n          // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n          || c.equals(EmptyTokenizer.class)\n          // doesn't actual reset itself!\n          || c.equals(CachingTokenFilter.class)\n          // broken!\n          || c.equals(NGramTokenizer.class)\n          // broken!\n          || c.equals(NGramTokenFilter.class)\n          // broken!\n          || c.equals(EdgeNGramTokenizer.class)\n          // broken!\n          || c.equals(EdgeNGramTokenFilter.class)) {\n        continue;\n      }\n      if (Tokenizer.class.isAssignableFrom(c)) {\n        tokenizers.add(c.asSubclass(Tokenizer.class));\n      } else if (TokenFilter.class.isAssignableFrom(c)) {\n        tokenfilters.add(c.asSubclass(TokenFilter.class));\n      } else if (CharStream.class.isAssignableFrom(c)) {\n        charfilters.add(c.asSubclass(CharStream.class));\n      }\n    }\n    final Comparator<Class<?>> classComp = new Comparator<Class<?>>() {\n      @Override\n      public int compare(Class<?> arg0, Class<?> arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    };\n    Collections.sort(tokenizers, classComp);\n    Collections.sort(tokenfilters, classComp);\n    Collections.sort(charfilters, classComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a92b21feea3b1b4d7ad5a06439333c4f757318f","date":1333977928,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n        || c == EmptyTokenizer.class\n        // doesn't actual reset itself!\n        || c == CachingTokenFilter.class\n        // doesn't consume whole stream!\n        || c == LimitTokenCountFilter.class\n        // broken!\n        || c == NGramTokenizer.class\n        // broken!\n        || c == NGramTokenFilter.class\n        // broken!\n        || c == EdgeNGramTokenizer.class\n        // broken!\n        || c == EdgeNGramTokenFilter.class\n      ) {\n        continue;\n      }\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Class<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Class<? extends TokenFilter>>();\n    charfilters = new ArrayList<Class<? extends CharStream>>();\n    for (Class<?> c : analysisClasses) {\n      // don't waste time with abstract classes or deprecated known-buggy ones\n      final int modifiers = c.getModifiers();\n      if (Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n          || c.getAnnotation(Deprecated.class) != null\n          || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n          // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n          || c.equals(EmptyTokenizer.class)\n          // doesn't actual reset itself!\n          || c.equals(CachingTokenFilter.class)\n          // broken!\n          || c.equals(NGramTokenizer.class)\n          // broken!\n          || c.equals(NGramTokenFilter.class)\n          // broken!\n          || c.equals(EdgeNGramTokenizer.class)\n          // broken!\n          || c.equals(EdgeNGramTokenFilter.class)) {\n        continue;\n      }\n      if (Tokenizer.class.isAssignableFrom(c)) {\n        tokenizers.add(c.asSubclass(Tokenizer.class));\n      } else if (TokenFilter.class.isAssignableFrom(c)) {\n        tokenfilters.add(c.asSubclass(TokenFilter.class));\n      } else if (CharStream.class.isAssignableFrom(c)) {\n        charfilters.add(c.asSubclass(CharStream.class));\n      }\n    }\n    final Comparator<Class<?>> classComp = new Comparator<Class<?>>() {\n      @Override\n      public int compare(Class<?> arg0, Class<?> arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    };\n    Collections.sort(tokenizers, classComp);\n    Collections.sort(tokenfilters, classComp);\n    Collections.sort(charfilters, classComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f71203835d950a6156d3e59753193d81c27cf4c3","date":1333980995,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n        || c == EmptyTokenizer.class\n        // doesn't actual reset itself!\n        || c == CachingTokenFilter.class\n        // nocommit: corrumpts graphs (offset consistency check)\n        || c == PositionFilter.class\n        // doesn't consume whole stream!\n        || c == LimitTokenCountFilter.class\n        // broken!\n        || c == NGramTokenizer.class\n        // broken!\n        || c == NGramTokenFilter.class\n        // broken!\n        || c == EdgeNGramTokenizer.class\n        // broken!\n        || c == EdgeNGramTokenFilter.class\n      ) {\n        continue;\n      }\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n        || c == EmptyTokenizer.class\n        // doesn't actual reset itself!\n        || c == CachingTokenFilter.class\n        // doesn't consume whole stream!\n        || c == LimitTokenCountFilter.class\n        // broken!\n        || c == NGramTokenizer.class\n        // broken!\n        || c == NGramTokenFilter.class\n        // broken!\n        || c == EdgeNGramTokenizer.class\n        // broken!\n        || c == EdgeNGramTokenFilter.class\n      ) {\n        continue;\n      }\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a960a2c8d8ca325137f7a262b70f270448352eb","date":1333985528,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        || brokenComponents.contains(c)\n      ) {\n        continue;\n      }\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n        || c == EmptyTokenizer.class\n        // doesn't actual reset itself!\n        || c == CachingTokenFilter.class\n        // nocommit: corrumpts graphs (offset consistency check)\n        || c == PositionFilter.class\n        // doesn't consume whole stream!\n        || c == LimitTokenCountFilter.class\n        // broken!\n        || c == NGramTokenizer.class\n        // broken!\n        || c == NGramTokenFilter.class\n        // broken!\n        || c == EdgeNGramTokenizer.class\n        // broken!\n        || c == EdgeNGramTokenFilter.class\n      ) {\n        continue;\n      }\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa380b0ac7fa6c578259afbb8eaa19927570010d","date":1333998347,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        || brokenComponents.contains(c)\n      ) {\n        continue;\n      }\n\n      if (c == ValidatingTokenFilter.class) {\n        // We insert this one ourselves after each stage...\n        continue;\n      }\n\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        || brokenComponents.contains(c)\n      ) {\n        continue;\n      }\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cdc624cad80ac093c2e6b895c4e8ad05172b8c4c","date":1334001650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        || brokenComponents.contains(c)\n      ) {\n        continue;\n      }\n\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        || brokenComponents.contains(c)\n      ) {\n        continue;\n      }\n\n      if (c == ValidatingTokenFilter.class) {\n        // We insert this one ourselves after each stage...\n        continue;\n      }\n\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3fe387609beb4415c86e551adc1d9c7157f226d1","date":1334065803,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isAnnotationPresent(Deprecated.class)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n        || brokenComponents.contains(c)\n      ) {\n        continue;\n      }\n\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test deprecated ctors, they likely have known bugs:\n        if (ctor.isAnnotationPresent(Deprecated.class) || ctor.isSynthetic()) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"888c2d6bca1edd8d9293631d6e1d188b036e0f05","date":1334076894,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n                     allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n                     allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n                     allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    \n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a77b3f5384d076d37317eee73bfb0acae431df69","date":1334083854,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n                     allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n                     allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n                     allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e","date":1334174049,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Class<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Class<? extends TokenFilter>>();\n    charfilters = new ArrayList<Class<? extends CharStream>>();\n    for (Class<?> c : analysisClasses) {\n      // don't waste time with abstract classes or deprecated known-buggy ones\n      final int modifiers = c.getModifiers();\n      if (Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n          || c.getAnnotation(Deprecated.class) != null\n          || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n          // TODO: fix basetokenstreamtestcase not to trip because this one has no CharTermAtt\n          || c.equals(EmptyTokenizer.class)\n          // doesn't actual reset itself!\n          || c.equals(CachingTokenFilter.class)\n          // broken!\n          || c.equals(NGramTokenizer.class)\n          // broken!\n          || c.equals(NGramTokenFilter.class)\n          // broken!\n          || c.equals(EdgeNGramTokenizer.class)\n          // broken!\n          || c.equals(EdgeNGramTokenFilter.class)) {\n        continue;\n      }\n      if (Tokenizer.class.isAssignableFrom(c)) {\n        tokenizers.add(c.asSubclass(Tokenizer.class));\n      } else if (TokenFilter.class.isAssignableFrom(c)) {\n        tokenfilters.add(c.asSubclass(TokenFilter.class));\n      } else if (CharStream.class.isAssignableFrom(c)) {\n        charfilters.add(c.asSubclass(CharStream.class));\n      }\n    }\n    final Comparator<Class<?>> classComp = new Comparator<Class<?>>() {\n      @Override\n      public int compare(Class<?> arg0, Class<?> arg1) {\n        return arg0.getName().compareTo(arg1.getName());\n      }\n    };\n    Collections.sort(tokenizers, classComp);\n    Collections.sort(tokenfilters, classComp);\n    Collections.sort(charfilters, classComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":["a75004531a9cdf4ad1c7a295d1c822057af45b87","73d216e8a31fcc28595d9f9518b2f081d9379789","2b9812246deee2216de0db0ea556e1ff163f5793"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a77b3f5384d076d37317eee73bfb0acae431df69":["888c2d6bca1edd8d9293631d6e1d188b036e0f05"],"2b9812246deee2216de0db0ea556e1ff163f5793":["73d216e8a31fcc28595d9f9518b2f081d9379789"],"3fe387609beb4415c86e551adc1d9c7157f226d1":["cdc624cad80ac093c2e6b895c4e8ad05172b8c4c"],"f71203835d950a6156d3e59753193d81c27cf4c3":["5a92b21feea3b1b4d7ad5a06439333c4f757318f"],"1a960a2c8d8ca325137f7a262b70f270448352eb":["f71203835d950a6156d3e59753193d81c27cf4c3"],"83fce48948948c503c3bd6d3f18e48ad21a9239c":["a75004531a9cdf4ad1c7a295d1c822057af45b87"],"73d216e8a31fcc28595d9f9518b2f081d9379789":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"888c2d6bca1edd8d9293631d6e1d188b036e0f05":["3fe387609beb4415c86e551adc1d9c7157f226d1"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"a75004531a9cdf4ad1c7a295d1c822057af45b87":["2b9812246deee2216de0db0ea556e1ff163f5793"],"ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e":["83fce48948948c503c3bd6d3f18e48ad21a9239c","a77b3f5384d076d37317eee73bfb0acae431df69"],"cdc624cad80ac093c2e6b895c4e8ad05172b8c4c":["aa380b0ac7fa6c578259afbb8eaa19927570010d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5a92b21feea3b1b4d7ad5a06439333c4f757318f":["83fce48948948c503c3bd6d3f18e48ad21a9239c"],"aa380b0ac7fa6c578259afbb8eaa19927570010d":["1a960a2c8d8ca325137f7a262b70f270448352eb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"a77b3f5384d076d37317eee73bfb0acae431df69":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"2b9812246deee2216de0db0ea556e1ff163f5793":["a75004531a9cdf4ad1c7a295d1c822057af45b87"],"3fe387609beb4415c86e551adc1d9c7157f226d1":["888c2d6bca1edd8d9293631d6e1d188b036e0f05"],"f71203835d950a6156d3e59753193d81c27cf4c3":["1a960a2c8d8ca325137f7a262b70f270448352eb"],"1a960a2c8d8ca325137f7a262b70f270448352eb":["aa380b0ac7fa6c578259afbb8eaa19927570010d"],"83fce48948948c503c3bd6d3f18e48ad21a9239c":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e","5a92b21feea3b1b4d7ad5a06439333c4f757318f"],"73d216e8a31fcc28595d9f9518b2f081d9379789":["2b9812246deee2216de0db0ea556e1ff163f5793"],"888c2d6bca1edd8d9293631d6e1d188b036e0f05":["a77b3f5384d076d37317eee73bfb0acae431df69"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a75004531a9cdf4ad1c7a295d1c822057af45b87":["83fce48948948c503c3bd6d3f18e48ad21a9239c"],"ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cdc624cad80ac093c2e6b895c4e8ad05172b8c4c":["3fe387609beb4415c86e551adc1d9c7157f226d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["73d216e8a31fcc28595d9f9518b2f081d9379789"],"5a92b21feea3b1b4d7ad5a06439333c4f757318f":["f71203835d950a6156d3e59753193d81c27cf4c3"],"aa380b0ac7fa6c578259afbb8eaa19927570010d":["cdc624cad80ac093c2e6b895c4e8ad05172b8c4c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}