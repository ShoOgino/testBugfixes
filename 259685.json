{"path":"lucene/core/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort#doRandomTest(int,int).mjava","commits":[{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort#doRandomTest(int,int).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort#doRandomTest(int,int).mjava","sourceNew":"  private void doRandomTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();    \n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // else seeds may not to reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      doc.add(new StoredField(\"id\", i));\n      doc.add(new NumericDocValuesField(\"id\", i));\n      if (random().nextInt(10) > 7) {\n        double latRaw = GeoTestUtil.nextLatitude();\n        double lonRaw = GeoTestUtil.nextLongitude();\n        // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n        double lat = decodeLatitude(encodeLatitude(latRaw));\n        double lon = decodeLongitude(encodeLongitude(lonRaw));\n\n        doc.add(new LatLonDocValuesField(\"field\", lat, lon));\n        doc.add(new StoredField(\"lat\", lat));\n        doc.add(new StoredField(\"lon\", lon));\n      } // otherwise \"missing\"\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n\n    for (int i = 0; i < numQueries; i++) {\n      double lat = GeoTestUtil.nextLatitude();\n      double lon = GeoTestUtil.nextLongitude();\n      double missingValue = Double.POSITIVE_INFINITY;\n\n      Result expected[] = new Result[reader.maxDoc()];\n      \n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        Document targetDoc = reader.document(doc);\n        final double distance;\n        if (targetDoc.getField(\"lat\") == null) {\n          distance = missingValue; // missing\n        } else {\n          double docLatitude = targetDoc.getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = targetDoc.getField(\"lon\").numericValue().doubleValue();\n          distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        }\n        int id = targetDoc.getField(\"id\").numericValue().intValue();\n        expected[doc] = new Result(id, distance);\n      }\n      \n      Arrays.sort(expected);\n      \n      // randomize the topN a bit\n      int topN = TestUtil.nextInt(random(), 1, reader.maxDoc());\n      // sort by distance, then ID\n      SortField distanceSort = LatLonDocValuesField.newDistanceSort(\"field\", lat, lon);\n      distanceSort.setMissingValue(missingValue);\n      Sort sort = new Sort(distanceSort, \n                           new SortField(\"id\", SortField.Type.INT));\n\n      TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), topN, sort);\n      for (int resultNumber = 0; resultNumber < topN; resultNumber++) {\n        FieldDoc fieldDoc = (FieldDoc) topDocs.scoreDocs[resultNumber];\n        Result actual = new Result((Integer) fieldDoc.fields[1], (Double) fieldDoc.fields[0]);\n        assertEquals(expected[resultNumber], actual);\n      }\n\n      // get page2 with searchAfter()\n      if (topN < reader.maxDoc()) {\n        int page2 = TestUtil.nextInt(random(), 1, reader.maxDoc() - topN);\n        TopDocs topDocs2 = searcher.searchAfter(topDocs.scoreDocs[topN - 1], new MatchAllDocsQuery(), page2, sort);\n        for (int resultNumber = 0; resultNumber < page2; resultNumber++) {\n          FieldDoc fieldDoc = (FieldDoc) topDocs2.scoreDocs[resultNumber];\n          Result actual = new Result((Integer) fieldDoc.fields[1], (Double) fieldDoc.fields[0]);\n          assertEquals(expected[topN + resultNumber], actual);\n        }\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();    \n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // else seeds may not to reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      doc.add(new StoredField(\"id\", i));\n      doc.add(new NumericDocValuesField(\"id\", i));\n      if (random().nextInt(10) > 7) {\n        double latRaw = GeoTestUtil.nextLatitude();\n        double lonRaw = GeoTestUtil.nextLongitude();\n        // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n        double lat = decodeLatitude(encodeLatitude(latRaw));\n        double lon = decodeLongitude(encodeLongitude(lonRaw));\n\n        doc.add(new LatLonDocValuesField(\"field\", lat, lon));\n        doc.add(new StoredField(\"lat\", lat));\n        doc.add(new StoredField(\"lon\", lon));\n      } // otherwise \"missing\"\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n\n    for (int i = 0; i < numQueries; i++) {\n      double lat = GeoTestUtil.nextLatitude();\n      double lon = GeoTestUtil.nextLongitude();\n      double missingValue = Double.POSITIVE_INFINITY;\n\n      Result expected[] = new Result[reader.maxDoc()];\n      \n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        Document targetDoc = reader.document(doc);\n        final double distance;\n        if (targetDoc.getField(\"lat\") == null) {\n          distance = missingValue; // missing\n        } else {\n          double docLatitude = targetDoc.getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = targetDoc.getField(\"lon\").numericValue().doubleValue();\n          distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        }\n        int id = targetDoc.getField(\"id\").numericValue().intValue();\n        expected[doc] = new Result(id, distance);\n      }\n      \n      Arrays.sort(expected);\n      \n      // randomize the topN a bit\n      int topN = TestUtil.nextInt(random(), 1, reader.maxDoc());\n      // sort by distance, then ID\n      SortField distanceSort = LatLonDocValuesField.newDistanceSort(\"field\", lat, lon);\n      distanceSort.setMissingValue(missingValue);\n      Sort sort = new Sort(distanceSort, \n                           new SortField(\"id\", SortField.Type.INT));\n\n      TopDocs topDocs = searcher.search(new MatchAllDocsQuery(), topN, sort);\n      for (int resultNumber = 0; resultNumber < topN; resultNumber++) {\n        FieldDoc fieldDoc = (FieldDoc) topDocs.scoreDocs[resultNumber];\n        Result actual = new Result((Integer) fieldDoc.fields[1], (Double) fieldDoc.fields[0]);\n        assertEquals(expected[resultNumber], actual);\n      }\n\n      // get page2 with searchAfter()\n      if (topN < reader.maxDoc()) {\n        int page2 = TestUtil.nextInt(random(), 1, reader.maxDoc() - topN);\n        TopDocs topDocs2 = searcher.searchAfter(topDocs.scoreDocs[topN - 1], new MatchAllDocsQuery(), page2, sort);\n        for (int resultNumber = 0; resultNumber < page2; resultNumber++) {\n          FieldDoc fieldDoc = (FieldDoc) topDocs2.scoreDocs[resultNumber];\n          Result actual = new Result((Integer) fieldDoc.fields[1], (Double) fieldDoc.fields[0]);\n          assertEquals(expected[topN + resultNumber], actual);\n        }\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"88b0212386fe531136816706dc37dc49b9dbf7dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["88b0212386fe531136816706dc37dc49b9dbf7dc"]},"commit2Childs":{"88b0212386fe531136816706dc37dc49b9dbf7dc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}