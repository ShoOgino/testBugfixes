{"path":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","commits":[{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","pathOld":"/dev/null","sourceNew":"  public DocValues docValues(String field) throws IOException {\n    DocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      Type type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        DocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n                new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n              new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39d51e9acac1e629cffe47855e85dc6dedc4754d","date":1305711497,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","sourceNew":"  public DocValues docValues(String field) throws IOException {\n    DocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        DocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n                new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n              new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","sourceOld":"  public DocValues docValues(String field) throws IOException {\n    DocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      Type type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        DocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n                new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n              new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41e5bbad683f7546e96f08ffe8bc50cf447f2586","date":1307113213,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","sourceNew":"  public IndexDocValues docValues(String field) throws IOException {\n    IndexDocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        IndexDocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n                new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n              new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","sourceOld":"  public DocValues docValues(String field) throws IOException {\n    DocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        DocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n                new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n              new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"605b061fadf71aa6458c0005eaae83a98350c403","date":1307117658,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","sourceNew":"  public IndexDocValues docValues(String field) throws IOException {\n    IndexDocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiIndexDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiIndexDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        IndexDocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n                new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n              new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiIndexDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","sourceOld":"  public IndexDocValues docValues(String field) throws IOException {\n    IndexDocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        IndexDocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n                new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n              new MultiDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","pathOld":"/dev/null","sourceNew":"  public IndexDocValues docValues(String field) throws IOException {\n    IndexDocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiIndexDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiIndexDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        IndexDocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n                new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n              new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiIndexDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","pathOld":"/dev/null","sourceNew":"  public IndexDocValues docValues(String field) throws IOException {\n    IndexDocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiIndexDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiIndexDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        IndexDocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n                new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n              new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiIndexDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32aca6bb0a6aa0a1813e7d035ac0e039f54269f4","date":1318260487,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","sourceNew":"  public IndexDocValues docValues(String field) throws IOException {\n    IndexDocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiIndexDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiIndexDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        IndexDocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n                new MultiIndexDocValues.EmptyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n              new MultiIndexDocValues.EmptyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiIndexDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","sourceOld":"  public IndexDocValues docValues(String field) throws IOException {\n    IndexDocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiIndexDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiIndexDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        IndexDocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n                new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n              new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiIndexDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","sourceNew":"  public DocValues docValues(String field) throws IOException {\n    DocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      DocValues.Type type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        DocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n                new MultiDocValues.EmptyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n              new MultiDocValues.EmptyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","sourceOld":"  public IndexDocValues docValues(String field) throws IOException {\n    IndexDocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiIndexDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiIndexDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        IndexDocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n                new MultiIndexDocValues.EmptyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n              new MultiIndexDocValues.EmptyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiIndexDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cac4d5fa6c305b94f6232a70bda07f096ad0348c","date":1323538980,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","sourceNew":null,"sourceOld":"  public DocValues docValues(String field) throws IOException {\n    DocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      DocValues.Type type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        DocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n                new MultiDocValues.EmptyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiDocValues.DocValuesIndex(\n              new MultiDocValues.EmptyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/MultiPerDocValues#docValues(String).mjava","sourceNew":null,"sourceOld":"  public IndexDocValues docValues(String field) throws IOException {\n    IndexDocValues result = docValues.get(field);\n    if (result == null) {\n      // Lazy init: first time this field is requested, we\n      // create & add to docValues:\n      final List<MultiIndexDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiIndexDocValues.DocValuesIndex>();\n      int docsUpto = 0;\n      ValueType type = null;\n      // Gather all sub-readers that share this field\n      for (int i = 0; i < subs.length; i++) {\n        IndexDocValues values = subs[i].docValues(field);\n        final int start = subSlices[i].start;\n        final int length = subSlices[i].length;\n        if (values != null) {\n          if (docsUpto != start) {\n            type = values.type();\n            docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n                new MultiIndexDocValues.EmptyDocValues(start, type), docsUpto, start\n                    - docsUpto));\n          }\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(values, start,\n              length));\n          docsUpto = start + length;\n\n        } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {\n          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(\n              new MultiIndexDocValues.EmptyDocValues(start, type), docsUpto, start\n                  - docsUpto));\n        }\n      }\n      if (docValuesIndex.isEmpty()) {\n        return null;\n      }\n      result = new MultiIndexDocValues(\n          docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));\n      docValues.put(field, result);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2e8d7ba2175f47e280231533f7d3016249cea88b"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","605b061fadf71aa6458c0005eaae83a98350c403"],"605b061fadf71aa6458c0005eaae83a98350c403":["41e5bbad683f7546e96f08ffe8bc50cf447f2586"],"39d51e9acac1e629cffe47855e85dc6dedc4754d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"cac4d5fa6c305b94f6232a70bda07f096ad0348c":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["32aca6bb0a6aa0a1813e7d035ac0e039f54269f4"],"41e5bbad683f7546e96f08ffe8bc50cf447f2586":["39d51e9acac1e629cffe47855e85dc6dedc4754d"],"32aca6bb0a6aa0a1813e7d035ac0e039f54269f4":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["32aca6bb0a6aa0a1813e7d035ac0e039f54269f4","cac4d5fa6c305b94f6232a70bda07f096ad0348c"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","32aca6bb0a6aa0a1813e7d035ac0e039f54269f4"],"605b061fadf71aa6458c0005eaae83a98350c403":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"39d51e9acac1e629cffe47855e85dc6dedc4754d":["41e5bbad683f7546e96f08ffe8bc50cf447f2586"],"cac4d5fa6c305b94f6232a70bda07f096ad0348c":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","2e8d7ba2175f47e280231533f7d3016249cea88b","135621f3a0670a9394eb563224a3b76cc4dddc0f"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["39d51e9acac1e629cffe47855e85dc6dedc4754d"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["cac4d5fa6c305b94f6232a70bda07f096ad0348c"],"41e5bbad683f7546e96f08ffe8bc50cf447f2586":["605b061fadf71aa6458c0005eaae83a98350c403"],"32aca6bb0a6aa0a1813e7d035ac0e039f54269f4":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","d638301ad1cfcae567b681b893bc8781f0ee48a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}