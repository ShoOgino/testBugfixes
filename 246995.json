{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","commits":[{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: bad name conflict with another method\n  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size() -1, numNodes - 1));\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f7985b168f6fddf7c63c36bed85c47c16011c3cc","f7985b168f6fddf7c63c36bed85c47c16011c3cc","aa16b24e8441c80ef7c503119e979670698c7233","aa16b24e8441c80ef7c503119e979670698c7233","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8512200aed2724abd80dbeb686d3412d537b7d8a","date":1342139754,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  // TODO: bad name conflict with another method\n  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size() -1, numNodes - 1));\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  // TODO: bad name conflict with another method\n  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size() -1, numNodes - 1));\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","sourceNew":null,"sourceOld":"  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f767f8c99eaedb984df754fe61f21c5de260f94":["8512200aed2724abd80dbeb686d3412d537b7d8a"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aba371508186796cc6151d8223a5b4e16d02e26e":["33d0ed80b7b47e34ad3ff033a77544563aba3085","8512200aed2724abd80dbeb686d3412d537b7d8a"],"8512200aed2724abd80dbeb686d3412d537b7d8a":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8512200aed2724abd80dbeb686d3412d537b7d8a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","3f767f8c99eaedb984df754fe61f21c5de260f94"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["fe33227f6805edab2036cbb80645cc4e2d1fa424","3f767f8c99eaedb984df754fe61f21c5de260f94"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f767f8c99eaedb984df754fe61f21c5de260f94"]},"commit2Childs":{"3f767f8c99eaedb984df754fe61f21c5de260f94":["d6f074e73200c07d54f242d3880a8da5a35ff97b","8fd5be977c105554c6a7b68afcdbc511439723ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["aba371508186796cc6151d8223a5b4e16d02e26e","8512200aed2724abd80dbeb686d3412d537b7d8a"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"8512200aed2724abd80dbeb686d3412d537b7d8a":["3f767f8c99eaedb984df754fe61f21c5de260f94","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d6f074e73200c07d54f242d3880a8da5a35ff97b","8fd5be977c105554c6a7b68afcdbc511439723ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}