{"path":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","commits":[{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.doc(), b.doc());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc;\n\n      private boolean first = true;\n      \n      @Override\n      public int nextDoc() {\n        // TODO: can we do away with this first boolean?\n        if (first == false) {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().doc();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        } else {\n          doc = queue.top().doc();\n          first = false;\n        }\n        return doc;\n      }\n        \n      @Override\n      public int doc() {\n        return doc;\n      }\n\n      @Override\n      public Object value() {\n        return queue.top().value();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.doc(), b.doc());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc;\n\n      private boolean first = true;\n      \n      @Override\n      public int nextDoc() {\n        // TODO: can we do away with this first boolean?\n        if (first == false) {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().doc();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        } else {\n          doc = queue.top().doc();\n          first = false;\n        }\n        return doc;\n      }\n        \n      @Override\n      public int doc() {\n        return doc;\n      }\n\n      @Override\n      public Object value() {\n        return queue.top().value();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.doc(), b.doc());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc;\n\n      private boolean first = true;\n      \n      @Override\n      public int nextDoc() {\n        // TODO: can we do away with this first boolean?\n        if (first == false) {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().doc();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        } else {\n          doc = queue.top().doc();\n          first = false;\n        }\n        return doc;\n      }\n        \n      @Override\n      public int doc() {\n        return doc;\n      }\n\n      @Override\n      public Object value() {\n        return queue.top().value();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c088100f7646827db17ea080925f7a0a916b1cd","date":1524662254,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","sourceNew":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.docID(), b.docID());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc;\n\n      private boolean first = true;\n      \n      @Override\n      public int nextDoc() {\n        // TODO: can we do away with this first boolean?\n        if (first == false) {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().docID();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        } else {\n          doc = queue.top().docID();\n          first = false;\n        }\n        return doc;\n      }\n        \n      @Override\n      public int docID() {\n        return doc;\n      }\n\n      @Override\n      public Object value() {\n        return queue.top().value();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","sourceOld":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.doc(), b.doc());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc;\n\n      private boolean first = true;\n      \n      @Override\n      public int nextDoc() {\n        // TODO: can we do away with this first boolean?\n        if (first == false) {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().doc();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        } else {\n          doc = queue.top().doc();\n          first = false;\n        }\n        return doc;\n      }\n        \n      @Override\n      public int doc() {\n        return doc;\n      }\n\n      @Override\n      public Object value() {\n        return queue.top().value();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e129bd6cb34a236558a49edf108a49d5c15e0e1","date":1525081316,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","sourceNew":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.docID(), b.docID());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc = -1;\n      @Override\n      public int nextDoc() {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().docID();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return doc;\n      }\n\n      @Override\n      long longValue() {\n        return queue.top().longValue();\n      }\n\n      @Override\n      BytesRef binaryValue() {\n        return queue.top().binaryValue();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","sourceOld":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.docID(), b.docID());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc;\n\n      private boolean first = true;\n      \n      @Override\n      public int nextDoc() {\n        // TODO: can we do away with this first boolean?\n        if (first == false) {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().docID();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        } else {\n          doc = queue.top().docID();\n          first = false;\n        }\n        return doc;\n      }\n        \n      @Override\n      public int docID() {\n        return doc;\n      }\n\n      @Override\n      public Object value() {\n        return queue.top().value();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f42883db49d143abc1a0f176ba47e3388dafb608","date":1525083166,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","sourceNew":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.docID(), b.docID());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc = -1;\n      @Override\n      public int nextDoc() {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().docID();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return doc;\n      }\n\n      @Override\n      long longValue() {\n        return queue.top().longValue();\n      }\n\n      @Override\n      BytesRef binaryValue() {\n        return queue.top().binaryValue();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","sourceOld":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.docID(), b.docID());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc;\n\n      private boolean first = true;\n      \n      @Override\n      public int nextDoc() {\n        // TODO: can we do away with this first boolean?\n        if (first == false) {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().docID();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        } else {\n          doc = queue.top().docID();\n          first = false;\n        }\n        return doc;\n      }\n        \n      @Override\n      public int docID() {\n        return doc;\n      }\n\n      @Override\n      public Object value() {\n        return queue.top().value();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33adea025f43af3243278587a46b8d9fd2e8ccf9","date":1525885077,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates#mergedIterator(Iterator[]).mjava","sourceNew":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.docID(), b.docID());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc = -1;\n      @Override\n      public int nextDoc() {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().docID();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return doc;\n      }\n\n      @Override\n      long longValue() {\n        return queue.top().longValue();\n      }\n\n      @Override\n      BytesRef binaryValue() {\n        return queue.top().binaryValue();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      boolean hasValue() {\n        return queue.top().hasValue();\n      }\n    };\n  }\n\n","sourceOld":"  /** Merge-sorts multiple iterators, one per delGen, favoring the largest delGen that has updates for a given docID. */\n  public static Iterator mergedIterator(Iterator[] subs) {\n\n    if (subs.length == 1) {\n      return subs[0];\n    }\n\n    PriorityQueue<Iterator> queue = new PriorityQueue<Iterator>(subs.length) {\n        @Override\n        protected boolean lessThan(Iterator a, Iterator b) {\n          // sort by smaller docID\n          int cmp = Integer.compare(a.docID(), b.docID());\n          if (cmp == 0) {\n            // then by larger delGen\n            cmp = Long.compare(b.delGen(), a.delGen());\n\n            // delGens are unique across our subs:\n            assert cmp != 0;\n          }\n\n          return cmp < 0;\n        }\n      };\n\n    for (Iterator sub : subs) {\n      if (sub.nextDoc() != NO_MORE_DOCS) {\n        queue.add(sub);\n      }\n    }\n\n    if (queue.size() == 0) {\n      return null;\n    }\n\n    return new Iterator() {\n      private int doc = -1;\n      @Override\n      public int nextDoc() {\n          // Advance all sub iterators past current doc\n          while (true) {\n            if (queue.size() == 0) {\n              doc = NO_MORE_DOCS;\n              break;\n            }\n            int newDoc = queue.top().docID();\n            if (newDoc != doc) {\n              assert newDoc > doc: \"doc=\" + doc + \" newDoc=\" + newDoc;\n              doc = newDoc;\n              break;\n            }\n            if (queue.top().nextDoc() == NO_MORE_DOCS) {\n              queue.pop();\n            } else {\n              queue.updateTop();\n            }\n          }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return doc;\n      }\n\n      @Override\n      long longValue() {\n        return queue.top().longValue();\n      }\n\n      @Override\n      BytesRef binaryValue() {\n        return queue.top().binaryValue();\n      }\n\n      @Override\n      public long delGen() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c088100f7646827db17ea080925f7a0a916b1cd":["28288370235ed02234a64753cdbf0c6ec096304a"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7e129bd6cb34a236558a49edf108a49d5c15e0e1":["4c088100f7646827db17ea080925f7a0a916b1cd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["f42883db49d143abc1a0f176ba47e3388dafb608"],"f42883db49d143abc1a0f176ba47e3388dafb608":["4c088100f7646827db17ea080925f7a0a916b1cd","7e129bd6cb34a236558a49edf108a49d5c15e0e1"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["33adea025f43af3243278587a46b8d9fd2e8ccf9"]},"commit2Childs":{"4c088100f7646827db17ea080925f7a0a916b1cd":["7e129bd6cb34a236558a49edf108a49d5c15e0e1","f42883db49d143abc1a0f176ba47e3388dafb608"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"7e129bd6cb34a236558a49edf108a49d5c15e0e1":["f42883db49d143abc1a0f176ba47e3388dafb608"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f42883db49d143abc1a0f176ba47e3388dafb608":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["4c088100f7646827db17ea080925f7a0a916b1cd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}