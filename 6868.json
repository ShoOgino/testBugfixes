{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#finishDocuments(DocumentsWriterDeleteQueue.Node[#],int).mjava","commits":[{"id":"142f99d1da3d720b5094f5b47b0e57f8ef6ab03c","date":1584127995,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#finishDocuments(DocumentsWriterDeleteQueue.Node[#],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#finishDocument(DocumentsWriterDeleteQueue.Node[#]).mjava","sourceNew":"  private long finishDocuments(DocumentsWriterDeleteQueue.Node<?> deleteNode, int docCount) {\n    /*\n     * here we actually finish the document in two steps 1. push the delete into\n     * the queue and update our slice. 2. increment the DWPT private document\n     * id.\n     * \n     * the updated slice we get from 1. holds all the deletes that have occurred\n     * since we updated the slice the last time.\n     */\n    // Apply delTerm only after all indexing has\n    // succeeded, but apply it only to docs prior to when\n    // this batch started:\n    long seqNo;\n    if (deleteNode != null) {\n      seqNo = deleteQueue.add(deleteNode, deleteSlice);\n      assert deleteSlice.isTail(deleteNode) : \"expected the delete term as the tail item\";\n      deleteSlice.apply(pendingUpdates, numDocsInRAM - docCount);\n      return seqNo;\n    } else {\n      seqNo = deleteQueue.updateSlice(deleteSlice);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        deleteSlice.apply(pendingUpdates, numDocsInRAM - docCount);\n      } else {\n        deleteSlice.reset();\n      }\n    }\n\n    return seqNo;\n  }\n\n","sourceOld":"  private long finishDocument(DocumentsWriterDeleteQueue.Node<?> deleteNode) {\n    /*\n     * here we actually finish the document in two steps 1. push the delete into\n     * the queue and update our slice. 2. increment the DWPT private document\n     * id.\n     * \n     * the updated slice we get from 1. holds all the deletes that have occurred\n     * since we updated the slice the last time.\n     */\n    boolean applySlice = numDocsInRAM != 0;\n    long seqNo;\n    if (deleteNode != null) {\n      seqNo = deleteQueue.add(deleteNode, deleteSlice);\n      assert deleteSlice.isTail(deleteNode) : \"expected the delete node as the tail\";\n    } else  {\n      seqNo = deleteQueue.updateSlice(deleteSlice);\n      \n      if (seqNo < 0) {\n        seqNo = -seqNo;\n      } else {\n        applySlice = false;\n      }\n    }\n    \n    if (applySlice) {\n      deleteSlice.apply(pendingUpdates, numDocsInRAM);\n    } else { // if we don't need to apply we must reset!\n      deleteSlice.reset();\n    }\n    ++numDocsInRAM;\n\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc1841e9449be30dd7bcb15d6247b4eb5c83a07b","date":1584454718,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#finishDocuments(DocumentsWriterDeleteQueue.Node[#],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#finishDocuments(DocumentsWriterDeleteQueue.Node[#],int).mjava","sourceNew":"  private long finishDocuments(DocumentsWriterDeleteQueue.Node<?> deleteNode, int docIdUpTo) {\n    /*\n     * here we actually finish the document in two steps 1. push the delete into\n     * the queue and update our slice. 2. increment the DWPT private document\n     * id.\n     * \n     * the updated slice we get from 1. holds all the deletes that have occurred\n     * since we updated the slice the last time.\n     */\n    // Apply delTerm only after all indexing has\n    // succeeded, but apply it only to docs prior to when\n    // this batch started:\n    long seqNo;\n    if (deleteNode != null) {\n      seqNo = deleteQueue.add(deleteNode, deleteSlice);\n      assert deleteSlice.isTail(deleteNode) : \"expected the delete term as the tail item\";\n      deleteSlice.apply(pendingUpdates, docIdUpTo);\n      return seqNo;\n    } else {\n      seqNo = deleteQueue.updateSlice(deleteSlice);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        deleteSlice.apply(pendingUpdates, docIdUpTo);\n      } else {\n        deleteSlice.reset();\n      }\n    }\n\n    return seqNo;\n  }\n\n","sourceOld":"  private long finishDocuments(DocumentsWriterDeleteQueue.Node<?> deleteNode, int docCount) {\n    /*\n     * here we actually finish the document in two steps 1. push the delete into\n     * the queue and update our slice. 2. increment the DWPT private document\n     * id.\n     * \n     * the updated slice we get from 1. holds all the deletes that have occurred\n     * since we updated the slice the last time.\n     */\n    // Apply delTerm only after all indexing has\n    // succeeded, but apply it only to docs prior to when\n    // this batch started:\n    long seqNo;\n    if (deleteNode != null) {\n      seqNo = deleteQueue.add(deleteNode, deleteSlice);\n      assert deleteSlice.isTail(deleteNode) : \"expected the delete term as the tail item\";\n      deleteSlice.apply(pendingUpdates, numDocsInRAM - docCount);\n      return seqNo;\n    } else {\n      seqNo = deleteQueue.updateSlice(deleteSlice);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        deleteSlice.apply(pendingUpdates, numDocsInRAM - docCount);\n      } else {\n        deleteSlice.reset();\n      }\n    }\n\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"142f99d1da3d720b5094f5b47b0e57f8ef6ab03c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bc1841e9449be30dd7bcb15d6247b4eb5c83a07b":["142f99d1da3d720b5094f5b47b0e57f8ef6ab03c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bc1841e9449be30dd7bcb15d6247b4eb5c83a07b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["142f99d1da3d720b5094f5b47b0e57f8ef6ab03c"],"142f99d1da3d720b5094f5b47b0e57f8ef6ab03c":["bc1841e9449be30dd7bcb15d6247b4eb5c83a07b"],"bc1841e9449be30dd7bcb15d6247b4eb5c83a07b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}