{"path":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","commits":[{"id":"d4aa50b979cd392e00e5bc0f23f78cbd106cb968","date":1308150768,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"/dev/null","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.SCORE, true));\n    sortFields.add(new SortField(null, SortField.SCORE, false));\n    sortFields.add(new SortField(null, SortField.DOC, true));\n    sortFields.add(new SortField(null, SortField.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = query.weight(searcher);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs.TopDocsAndShards mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       mergedHits.shardIndex[hitIDX]);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5d731d304e051cf7ed37410c1431e942f41c09b","date":1308235976,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.SCORE, true));\n    sortFields.add(new SortField(null, SortField.SCORE, false));\n    sortFields.add(new SortField(null, SortField.DOC, true));\n    sortFields.add(new SortField(null, SortField.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = query.weight(searcher);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.SCORE, true));\n    sortFields.add(new SortField(null, SortField.SCORE, false));\n    sortFields.add(new SortField(null, SortField.DOC, true));\n    sortFields.add(new SortField(null, SortField.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = query.weight(searcher);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs.TopDocsAndShards mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       mergedHits.shardIndex[hitIDX]);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f7fee42303a18cc146043c96f66491311b345d9","date":1308246904,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.SCORE, true));\n    sortFields.add(new SortField(null, SortField.SCORE, false));\n    sortFields.add(new SortField(null, SortField.DOC, true));\n    sortFields.add(new SortField(null, SortField.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.SCORE, true));\n    sortFields.add(new SortField(null, SortField.SCORE, false));\n    sortFields.add(new SortField(null, SortField.DOC, true));\n    sortFields.add(new SortField(null, SortField.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = query.weight(searcher);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"/dev/null","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.SCORE, true));\n    sortFields.add(new SortField(null, SortField.SCORE, false));\n    sortFields.add(new SortField(null, SortField.DOC, true));\n    sortFields.add(new SortField(null, SortField.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"090a0320e4de4a3674376aef96b9701f47564f86","date":1308707325,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.SCORE, true));\n    sortFields.add(new SortField(null, SortField.SCORE, false));\n    sortFields.add(new SortField(null, SortField.DOC, true));\n    sortFields.add(new SortField(null, SortField.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.SCORE, true));\n    sortFields.add(new SortField(null, SortField.SCORE, false));\n    sortFields.add(new SortField(null, SortField.DOC, true));\n    sortFields.add(new SortField(null, SortField.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.SCORE, true));\n    sortFields.add(new SortField(null, SortField.SCORE, false));\n    sortFields.add(new SortField(null, SortField.DOC, true));\n    sortFields.add(new SortField(null, SortField.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], Field.Index.ANALYZED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d14e8d18c0e3970c20354dbeeb49da11bd587fbd","date":1321041051,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomOptimize(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    searcher.close();\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa0f44f887719e97183771e977cfc4bfb485b766","date":1326668713,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\").setFloatValue(random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\").setIntValue(intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":["d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19a806c08dc7062fea18c513411ff4eb6643e58e","date":1327864150,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicIndexReader.AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicIndexReader.AtomicReaderContext) ctx, null);\n      docStarts[0] = 0;\n    } else {\n      final CompositeIndexReader.CompositeReaderContext compCTX = (CompositeIndexReader.CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da6d5ac19a80d65b1e864251f155d30960353b7e","date":1327881054,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReader.AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReader.AtomicReaderContext) ctx, null);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReader.CompositeReaderContext compCTX = (CompositeReader.CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicIndexReader.AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicIndexReader.AtomicReaderContext) ctx, null);\n      docStarts[0] = 0;\n    } else {\n      final CompositeIndexReader.CompositeReaderContext compCTX = (CompositeIndexReader.CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8493985e6883b3fa8231d172694d2aa3a85cb182","date":1327920390,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, null);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReader.AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReader.AtomicReaderContext) ctx, null);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReader.CompositeReaderContext compCTX = (CompositeReader.CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, null);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    IndexReader[] subReaders = searcher.getIndexReader().getSequentialSubReaders();\n    if (subReaders == null) {\n      subReaders = new IndexReader[] {searcher.getIndexReader()};\n    }\n    final ShardSearcher[] subSearchers = new ShardSearcher[subReaders.length];\n    final IndexReader.ReaderContext ctx = searcher.getTopReaderContext();\n\n    if (ctx instanceof IndexReader.AtomicReaderContext) {\n      assert subSearchers.length == 1;\n      subSearchers[0] = new ShardSearcher((IndexReader.AtomicReaderContext) ctx, ctx);\n    } else {\n      final IndexReader.CompositeReaderContext compCTX = (IndexReader.CompositeReaderContext) ctx;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves[searcherIDX], compCTX);\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    final int[] docStarts = new int[subSearchers.length];\n    int docBase = 0;\n    for(int subIDX=0;subIDX<docStarts.length;subIDX++) {\n      docStarts[subIDX] = docBase;\n      docBase += subReaders[subIDX].maxDoc();\n      //System.out.println(\"docStarts[\" + subIDX + \"]=\" + docStarts[subIDX]);\n    }\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2fec2d6358af5b05f39117e3773c59d549de3df9","date":1328049282,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, null);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"8493985e6883b3fa8231d172694d2aa3a85cb182":["da6d5ac19a80d65b1e864251f155d30960353b7e"],"19a806c08dc7062fea18c513411ff4eb6643e58e":["fa0f44f887719e97183771e977cfc4bfb485b766"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["2fec2d6358af5b05f39117e3773c59d549de3df9"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2553b00f699380c64959ccb27991289aae87be2e":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","090a0320e4de4a3674376aef96b9701f47564f86"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["6f7fee42303a18cc146043c96f66491311b345d9","090a0320e4de4a3674376aef96b9701f47564f86"],"090a0320e4de4a3674376aef96b9701f47564f86":["6f7fee42303a18cc146043c96f66491311b345d9"],"e5d731d304e051cf7ed37410c1431e942f41c09b":["d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["fa0f44f887719e97183771e977cfc4bfb485b766","8493985e6883b3fa8231d172694d2aa3a85cb182"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6f7fee42303a18cc146043c96f66491311b345d9"],"6f7fee42303a18cc146043c96f66491311b345d9":["e5d731d304e051cf7ed37410c1431e942f41c09b"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["19a806c08dc7062fea18c513411ff4eb6643e58e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fa0f44f887719e97183771e977cfc4bfb485b766":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["090a0320e4de4a3674376aef96b9701f47564f86"],"2fec2d6358af5b05f39117e3773c59d549de3df9":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"8493985e6883b3fa8231d172694d2aa3a85cb182":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"19a806c08dc7062fea18c513411ff4eb6643e58e":["da6d5ac19a80d65b1e864251f155d30960353b7e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["e5d731d304e051cf7ed37410c1431e942f41c09b"],"2553b00f699380c64959ccb27991289aae87be2e":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"090a0320e4de4a3674376aef96b9701f47564f86":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","1509f151d7692d84fae414b2b799ac06ba60fcb4"],"e5d731d304e051cf7ed37410c1431e942f41c09b":["6f7fee42303a18cc146043c96f66491311b345d9"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["2fec2d6358af5b05f39117e3773c59d549de3df9"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["2553b00f699380c64959ccb27991289aae87be2e"],"6f7fee42303a18cc146043c96f66491311b345d9":["d083e83f225b11e5fdd900e83d26ddb385b6955c","090a0320e4de4a3674376aef96b9701f47564f86","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["8493985e6883b3fa8231d172694d2aa3a85cb182"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","fa0f44f887719e97183771e977cfc4bfb485b766"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d4aa50b979cd392e00e5bc0f23f78cbd106cb968","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b"],"fa0f44f887719e97183771e977cfc4bfb485b766":["19a806c08dc7062fea18c513411ff4eb6643e58e","5cab9a86bd67202d20b6adc463008c8e982b070a"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"2fec2d6358af5b05f39117e3773c59d549de3df9":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}