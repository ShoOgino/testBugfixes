{"path":"lucene/src/java/org/apache/lucene/util/FixedBitSet#and(DocIdSetIterator).mjava","commits":[{"id":"b8ea5d384746c397b7afee5e0b870d31bd488832","date":1316724181,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/FixedBitSet#and(DocIdSetIterator).mjava","pathOld":"/dev/null","sourceNew":"  /** Does in-place AND of the bits provided by the\n   *  iterator. */\n  public void and(DocIdSetIterator iter) throws IOException {\n    if (iter instanceof OpenBitSetIterator && iter.docID() == -1) {\n      final OpenBitSetIterator obs = (OpenBitSetIterator) iter;\n      and(obs.arr, obs.words);\n    } else {\n      if (numBits == 0) return;\n      int disiDoc, bitSetDoc = nextSetBit(0);\n      while (bitSetDoc != -1 && (disiDoc = iter.advance(bitSetDoc)) < numBits) {\n        clear(bitSetDoc, disiDoc);\n        disiDoc++;\n        bitSetDoc = (disiDoc < numBits) ? nextSetBit(disiDoc) : -1;\n      }\n      if (bitSetDoc != -1) {\n        clear(bitSetDoc, numBits);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2db5a1702a3c52221e724bf2b5a69426fed11f4d","date":1321868790,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/FixedBitSet#and(DocIdSetIterator).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/FixedBitSet#and(DocIdSetIterator).mjava","sourceNew":"  /** Does in-place AND of the bits provided by the\n   *  iterator. */\n  public void and(DocIdSetIterator iter) throws IOException {\n    if (iter instanceof OpenBitSetIterator && iter.docID() == -1) {\n      final OpenBitSetIterator obs = (OpenBitSetIterator) iter;\n      and(obs.arr, obs.words);\n      // advance after last doc that would be accepted if standard\n      // iteration is used (to exhaust it):\n      obs.advance(numBits);\n    } else {\n      if (numBits == 0) return;\n      int disiDoc, bitSetDoc = nextSetBit(0);\n      while (bitSetDoc != -1 && (disiDoc = iter.advance(bitSetDoc)) < numBits) {\n        clear(bitSetDoc, disiDoc);\n        disiDoc++;\n        bitSetDoc = (disiDoc < numBits) ? nextSetBit(disiDoc) : -1;\n      }\n      if (bitSetDoc != -1) {\n        clear(bitSetDoc, numBits);\n      }\n    }\n  }\n\n","sourceOld":"  /** Does in-place AND of the bits provided by the\n   *  iterator. */\n  public void and(DocIdSetIterator iter) throws IOException {\n    if (iter instanceof OpenBitSetIterator && iter.docID() == -1) {\n      final OpenBitSetIterator obs = (OpenBitSetIterator) iter;\n      and(obs.arr, obs.words);\n    } else {\n      if (numBits == 0) return;\n      int disiDoc, bitSetDoc = nextSetBit(0);\n      while (bitSetDoc != -1 && (disiDoc = iter.advance(bitSetDoc)) < numBits) {\n        clear(bitSetDoc, disiDoc);\n        disiDoc++;\n        bitSetDoc = (disiDoc < numBits) ? nextSetBit(disiDoc) : -1;\n      }\n      if (bitSetDoc != -1) {\n        clear(bitSetDoc, numBits);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FixedBitSet#and(DocIdSetIterator).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/FixedBitSet#and(DocIdSetIterator).mjava","sourceNew":"  /** Does in-place AND of the bits provided by the\n   *  iterator. */\n  public void and(DocIdSetIterator iter) throws IOException {\n    if (iter instanceof OpenBitSetIterator && iter.docID() == -1) {\n      final OpenBitSetIterator obs = (OpenBitSetIterator) iter;\n      and(obs.arr, obs.words);\n      // advance after last doc that would be accepted if standard\n      // iteration is used (to exhaust it):\n      obs.advance(numBits);\n    } else {\n      if (numBits == 0) return;\n      int disiDoc, bitSetDoc = nextSetBit(0);\n      while (bitSetDoc != -1 && (disiDoc = iter.advance(bitSetDoc)) < numBits) {\n        clear(bitSetDoc, disiDoc);\n        disiDoc++;\n        bitSetDoc = (disiDoc < numBits) ? nextSetBit(disiDoc) : -1;\n      }\n      if (bitSetDoc != -1) {\n        clear(bitSetDoc, numBits);\n      }\n    }\n  }\n\n","sourceOld":"  /** Does in-place AND of the bits provided by the\n   *  iterator. */\n  public void and(DocIdSetIterator iter) throws IOException {\n    if (iter instanceof OpenBitSetIterator && iter.docID() == -1) {\n      final OpenBitSetIterator obs = (OpenBitSetIterator) iter;\n      and(obs.arr, obs.words);\n      // advance after last doc that would be accepted if standard\n      // iteration is used (to exhaust it):\n      obs.advance(numBits);\n    } else {\n      if (numBits == 0) return;\n      int disiDoc, bitSetDoc = nextSetBit(0);\n      while (bitSetDoc != -1 && (disiDoc = iter.advance(bitSetDoc)) < numBits) {\n        clear(bitSetDoc, disiDoc);\n        disiDoc++;\n        bitSetDoc = (disiDoc < numBits) ? nextSetBit(disiDoc) : -1;\n      }\n      if (bitSetDoc != -1) {\n        clear(bitSetDoc, numBits);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8ea5d384746c397b7afee5e0b870d31bd488832":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2db5a1702a3c52221e724bf2b5a69426fed11f4d":["b8ea5d384746c397b7afee5e0b870d31bd488832"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["2db5a1702a3c52221e724bf2b5a69426fed11f4d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"b8ea5d384746c397b7afee5e0b870d31bd488832":["2db5a1702a3c52221e724bf2b5a69426fed11f4d"],"2db5a1702a3c52221e724bf2b5a69426fed11f4d":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b8ea5d384746c397b7afee5e0b870d31bd488832"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}