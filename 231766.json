{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","commits":[{"id":"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","date":1346692465,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param leaderVoteWait\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    zkClient.getZkClientConnectionStrategy().addDisconnectedListener(new ZkClientConnectionStrategy.DisconnectedListener() {\n      \n      @Override\n      public void disconnected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        // re register all descriptors\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            descriptor.getCloudDescriptor().isLeader = false;\n          }\n        }\n      }\n    });\n    \n    zkClient.getZkClientConnectionStrategy().addConnectedListener(new ZkClientConnectionStrategy.ConnectedListener() {\n      \n      @Override\n      public void connected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n            String leaderUrl;\n            try {\n              leaderUrl = getLeaderProps(cloudDesc.getCollectionName(), cloudDesc.getShardId())\n                  .getCoreUrl();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), descriptor.getName());\n            boolean isLeader = leaderUrl.equals(ourUrl);\n            log.info(\"SolrCore connected to ZooKeeper - we are \" + ourUrl + \" and leader is \" + leaderUrl);\n            cloudDesc.isLeader = isLeader;\n          }\n        }\n      }\n    });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["227c5621583c5b934878e3c051aae9c4649ae700","a6378064655e76cd7b908b1cab4ce425b384b508","88f39c3b3a16aebc5a91335341c7ad5b560e2277","d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","date":1346817835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param leaderVoteWait\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              cc.newCmdDistribExecutor();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param leaderVoteWait\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    zkClient.getZkClientConnectionStrategy().addDisconnectedListener(new ZkClientConnectionStrategy.DisconnectedListener() {\n      \n      @Override\n      public void disconnected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        // re register all descriptors\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            descriptor.getCloudDescriptor().isLeader = false;\n          }\n        }\n      }\n    });\n    \n    zkClient.getZkClientConnectionStrategy().addConnectedListener(new ZkClientConnectionStrategy.ConnectedListener() {\n      \n      @Override\n      public void connected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n            String leaderUrl;\n            try {\n              leaderUrl = getLeaderProps(cloudDesc.getCollectionName(), cloudDesc.getShardId())\n                  .getCoreUrl();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), descriptor.getName());\n            boolean isLeader = leaderUrl.equals(ourUrl);\n            log.info(\"SolrCore connected to ZooKeeper - we are \" + ourUrl + \" and leader is \" + leaderUrl);\n            cloudDesc.isLeader = isLeader;\n          }\n        }\n      }\n    });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param leaderVoteWait\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param leaderVoteWait\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              cc.newCmdDistribExecutor();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param leaderVoteWait\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"88f39c3b3a16aebc5a91335341c7ad5b560e2277","date":1350066344,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d82832af39f94dbb58a3130fd216ff1d49435589","date":1350147242,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db4fdbf3d262768eabc027cd8321edca0cd11fa8","date":1350574784,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n            //  cc.newCmdDistribExecutor();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042891089d57d0e6af18ea6cec15f9e9a7da7d25","date":1355271969,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.startsWith(\"/\")) {\n      // be forgiving and strip this off\n      // this allows us to support users specifying hostContext=\"/\" in \n      // solr.xml to indicate the root context, instead of hostContext=\"\" \n      // which means the default of \"solr\"\n      localHostContext = localHostContext.substring(1);\n    }\n    if (localHostContext.endsWith(\"/\")) {\n      // be extra nice\n      localHostContext = localHostContext.substring(0,localHostContext.length()-1);\n    }\n    \n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":["227c5621583c5b934878e3c051aae9c4649ae700"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d044a068e0d16ff314fb7f93fa75194d5360a6ff","date":1355610187,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.startsWith(\"/\")) {\n      // be forgiving and strip this off\n      // this allows us to support users specifying hostContext=\"/\" in \n      // solr.xml to indicate the root context, instead of hostContext=\"\" \n      // which means the default of \"solr\"\n      localHostContext = localHostContext.substring(1);\n    }\n    if (localHostContext.endsWith(\"/\")) {\n      // be extra nice\n      localHostContext = localHostContext.substring(0,localHostContext.length()-1);\n    }\n    \n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.startsWith(\"/\")) {\n      // be forgiving and strip this off\n      // this allows us to support users specifying hostContext=\"/\" in \n      // solr.xml to indicate the root context, instead of hostContext=\"\" \n      // which means the default of \"solr\"\n      localHostContext = localHostContext.substring(1);\n    }\n    if (localHostContext.endsWith(\"/\")) {\n      // be extra nice\n      localHostContext = localHostContext.substring(0,localHostContext.length()-1);\n    }\n    \n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a69439d0df009e0bb0038d1e427159f449dd670d","date":1355704683,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,int,int,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, int distribUpdateConnTimeout, int distribUpdateSoTimeout, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.startsWith(\"/\")) {\n      // be forgiving and strip this off\n      // this allows us to support users specifying hostContext=\"/\" in \n      // solr.xml to indicate the root context, instead of hostContext=\"\" \n      // which means the default of \"solr\"\n      localHostContext = localHostContext.substring(1);\n    }\n    if (localHostContext.endsWith(\"/\")) {\n      // be extra nice\n      localHostContext = localHostContext.substring(0,localHostContext.length()-1);\n    }\n    \n    updateShardHandler = new UpdateShardHandler(distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.startsWith(\"/\")) {\n      // be forgiving and strip this off\n      // this allows us to support users specifying hostContext=\"/\" in \n      // solr.xml to indicate the root context, instead of hostContext=\"\" \n      // which means the default of \"solr\"\n      localHostContext = localHostContext.substring(1);\n    }\n    if (localHostContext.endsWith(\"/\")) {\n      // be extra nice\n      localHostContext = localHostContext.substring(0,localHostContext.length()-1);\n    }\n    \n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":null,"sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, String leaderVoteWait, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old leader accepted\n              // though I guess sync will likely get those updates back? But only if\n              // he is involved in the sync, and he certainly may not be\n            //  ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n\n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["a6378064655e76cd7b908b1cab4ce425b384b508"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d9405f486872f1e416304dfe389741f4ee2f8a4d","a69439d0df009e0bb0038d1e427159f449dd670d"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a69439d0df009e0bb0038d1e427159f449dd670d":["d044a068e0d16ff314fb7f93fa75194d5360a6ff"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","88f39c3b3a16aebc5a91335341c7ad5b560e2277"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["88f39c3b3a16aebc5a91335341c7ad5b560e2277"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"042891089d57d0e6af18ea6cec15f9e9a7da7d25":["7530de27b87b961b51f01bd1299b7004d46e8823"],"a6378064655e76cd7b908b1cab4ce425b384b508":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"d82832af39f94dbb58a3130fd216ff1d49435589":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","88f39c3b3a16aebc5a91335341c7ad5b560e2277"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d044a068e0d16ff314fb7f93fa75194d5360a6ff":["042891089d57d0e6af18ea6cec15f9e9a7da7d25"],"88f39c3b3a16aebc5a91335341c7ad5b560e2277":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"f2126b84bd093fa3d921582a109a0ee578c28126":["db4fdbf3d262768eabc027cd8321edca0cd11fa8","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a69439d0df009e0bb0038d1e427159f449dd670d"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["db4fdbf3d262768eabc027cd8321edca0cd11fa8","d82832af39f94dbb58a3130fd216ff1d49435589","88f39c3b3a16aebc5a91335341c7ad5b560e2277"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"a69439d0df009e0bb0038d1e427159f449dd670d":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":["f2126b84bd093fa3d921582a109a0ee578c28126"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f2126b84bd093fa3d921582a109a0ee578c28126","7530de27b87b961b51f01bd1299b7004d46e8823"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["a6378064655e76cd7b908b1cab4ce425b384b508"],"042891089d57d0e6af18ea6cec15f9e9a7da7d25":["d044a068e0d16ff314fb7f93fa75194d5360a6ff"],"a6378064655e76cd7b908b1cab4ce425b384b508":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"d82832af39f94dbb58a3130fd216ff1d49435589":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"d044a068e0d16ff314fb7f93fa75194d5360a6ff":["a69439d0df009e0bb0038d1e427159f449dd670d"],"88f39c3b3a16aebc5a91335341c7ad5b560e2277":["db4fdbf3d262768eabc027cd8321edca0cd11fa8","d9405f486872f1e416304dfe389741f4ee2f8a4d","d82832af39f94dbb58a3130fd216ff1d49435589"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["042891089d57d0e6af18ea6cec15f9e9a7da7d25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d82832af39f94dbb58a3130fd216ff1d49435589","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}