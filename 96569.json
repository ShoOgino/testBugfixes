{"path":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"/dev/null","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < 5 && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCore.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"/dev/null","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < 5 && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCore.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"/dev/null","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < 5 && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCore.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"485232f1ea519c43967bde67882bbb459a014c4a","date":1338988233,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < 5 && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCore.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \", sreq.exception);\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCore.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < 5 && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCore.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6995e11c4255e48833ad99a0ff00a3a3f85052ff","date":1338991492,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < MAX_RETRIES_ON_FORWARD && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCore.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \", sreq.exception);\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCore.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < 5 && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCore.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \", sreq.exception);\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCore.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c4c2f621cc08e950d8f7297eec816e894dc32ac","date":1338992719,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < MAX_RETRIES_ON_FORWARD && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < MAX_RETRIES_ON_FORWARD && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCore.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \", sreq.exception);\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCore.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaca6707c7788ce1c7b82bf708a43570732482e3","date":1338995714,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry && (rspCode == 404 || rspCode == 403 || rspCode == 503 || rspCode == 500)) {\n              doRetry = true;\n            }\n            \n            // if its an ioexception, lets try again\n            if (isRetry && sreq.exception instanceof IOException) {\n              doRetry = true;\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \", null);\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            // TODO: but we really should only retry on connection errors...\n            if (sreq.retries < MAX_RETRIES_ON_FORWARD && sreq.node.checkRetry()) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdeb103cf038677a26e2bd11e29f5875782e3d64","date":1339000543,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry) {\n              if (rspCode == 404 || rspCode == 403 || rspCode == 503\n                  || rspCode == 500) {\n                doRetry = true;\n              }\n              \n              // if its an ioexception, lets try again\n              if (sreq.exception instanceof IOException) {\n                doRetry = true;\n              } else if (sreq.exception instanceof SolrServerException) {\n                if (((SolrServerException) sreq.exception).getRootCause() instanceof IOException) {\n                  doRetry = true;\n                }\n              }\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry && (rspCode == 404 || rspCode == 403 || rspCode == 503 || rspCode == 500)) {\n              doRetry = true;\n            }\n            \n            // if its an ioexception, lets try again\n            if (isRetry && sreq.exception instanceof IOException) {\n              doRetry = true;\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \", null);\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a80493bb7797a8543824e504521c52eedf449cd4","date":1357082541,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry) {\n              if (rspCode == 404 || rspCode == 403 || rspCode == 503\n                  || rspCode == 500) {\n                doRetry = true;\n              }\n              \n              // if its an ioexception, lets try again\n              if (sreq.exception instanceof IOException) {\n                doRetry = true;\n              } else if (sreq.exception instanceof SolrServerException) {\n                if (((SolrServerException) sreq.exception).getRootCause() instanceof IOException) {\n                  doRetry = true;\n                }\n              }\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry) {\n              if (rspCode == 404 || rspCode == 403 || rspCode == 503\n                  || rspCode == 500) {\n                doRetry = true;\n              }\n              \n              // if its an ioexception, lets try again\n              if (sreq.exception instanceof IOException) {\n                doRetry = true;\n              } else if (sreq.exception instanceof SolrServerException) {\n                if (((SolrServerException) sreq.exception).getRootCause() instanceof IOException) {\n                  doRetry = true;\n                }\n              }\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b61f7bfea082224c17562d045792406aacdee7f","date":1357184882,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n\n            if (testing_errorHook != null) Diagnostics.call(testing_errorHook, this, sreq);\n\n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry) {\n              if (rspCode == 404 || rspCode == 403 || rspCode == 503\n                  || rspCode == 500) {\n                doRetry = true;\n              }\n              \n              // if its an ioexception, lets try again\n              if (sreq.exception instanceof IOException) {\n                doRetry = true;\n              } else if (sreq.exception instanceof SolrServerException) {\n                if (((SolrServerException) sreq.exception).getRootCause() instanceof IOException) {\n                  doRetry = true;\n                }\n              }\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry) {\n              if (rspCode == 404 || rspCode == 403 || rspCode == 503\n                  || rspCode == 500) {\n                doRetry = true;\n              }\n              \n              // if its an ioexception, lets try again\n              if (sreq.exception instanceof IOException) {\n                doRetry = true;\n              } else if (sreq.exception instanceof SolrServerException) {\n                if (((SolrServerException) sreq.exception).getRootCause() instanceof IOException) {\n                  doRetry = true;\n                }\n              }\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","sourceNew":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n\n            if (testing_errorHook != null) Diagnostics.call(testing_errorHook, this, sreq);\n\n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry) {\n              if (rspCode == 404 || rspCode == 403 || rspCode == 503\n                  || rspCode == 500) {\n                doRetry = true;\n              }\n              \n              // if its an ioexception, lets try again\n              if (sreq.exception instanceof IOException) {\n                doRetry = true;\n              } else if (sreq.exception instanceof SolrServerException) {\n                if (((SolrServerException) sreq.exception).getRootCause() instanceof IOException) {\n                  doRetry = true;\n                }\n              }\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","sourceOld":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n            \n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry) {\n              if (rspCode == 404 || rspCode == 403 || rspCode == 503\n                  || rspCode == 500) {\n                doRetry = true;\n              }\n              \n              // if its an ioexception, lets try again\n              if (sreq.exception instanceof IOException) {\n                doRetry = true;\n              } else if (sreq.exception instanceof SolrServerException) {\n                if (((SolrServerException) sreq.exception).getRootCause() instanceof IOException) {\n                  doRetry = true;\n                }\n              }\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n              checkResponses(block);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91e069c492cf4895697ef7b81df0ffb9a8bd4b48","date":1382134253,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor#checkResponses(boolean).mjava","sourceNew":null,"sourceOld":"  void checkResponses(boolean block) {\n\n    while (pending != null && pending.size() > 0) {\n      try {\n        Future<Request> future = block ? completionService.take()\n            : completionService.poll();\n        if (future == null) return;\n        pending.remove(future);\n        \n        try {\n          Request sreq = future.get();\n          if (sreq.rspCode != 0) {\n            // error during request\n\n            if (testing_errorHook != null) Diagnostics.call(testing_errorHook, this, sreq);\n\n            // if there is a retry url, we want to retry...\n            boolean isRetry = sreq.node.checkRetry();\n            boolean doRetry = false;\n            int rspCode = sreq.rspCode;\n            \n            // this can happen in certain situations such as shutdown\n            if (isRetry) {\n              if (rspCode == 404 || rspCode == 403 || rspCode == 503\n                  || rspCode == 500) {\n                doRetry = true;\n              }\n              \n              // if its an ioexception, lets try again\n              if (sreq.exception instanceof IOException) {\n                doRetry = true;\n              } else if (sreq.exception instanceof SolrServerException) {\n                if (((SolrServerException) sreq.exception).getRootCause() instanceof IOException) {\n                  doRetry = true;\n                }\n              }\n            }\n            \n            if (isRetry && sreq.retries < MAX_RETRIES_ON_FORWARD && doRetry) {\n              sreq.retries++;\n              sreq.rspCode = 0;\n              sreq.exception = null;\n              SolrException.log(SolrCmdDistributor.log, \"forwarding update to \" + sreq.node.getUrl() + \" failed - retrying ... \");\n              Thread.sleep(500);\n              submit(sreq);\n            } else {\n              Exception e = sreq.exception;\n              Error error = new Error();\n              error.e = e;\n              error.node = sreq.node;\n              response.errors.add(error);\n              response.sreq = sreq;\n              SolrException.log(SolrCmdDistributor.log, \"shard update error \"\n                  + sreq.node, sreq.exception);\n            }\n          }\n          \n        } catch (ExecutionException e) {\n          // shouldn't happen since we catch exceptions ourselves\n          SolrException.log(SolrCore.log,\n              \"error sending update request to shard\", e);\n        }\n        \n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"interrupted waiting for shard update response\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["cdeb103cf038677a26e2bd11e29f5875782e3d64","5b61f7bfea082224c17562d045792406aacdee7f"],"cdeb103cf038677a26e2bd11e29f5875782e3d64":["aaca6707c7788ce1c7b82bf708a43570732482e3"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["5b61f7bfea082224c17562d045792406aacdee7f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"6c4c2f621cc08e950d8f7297eec816e894dc32ac":["6995e11c4255e48833ad99a0ff00a3a3f85052ff"],"485232f1ea519c43967bde67882bbb459a014c4a":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"aaca6707c7788ce1c7b82bf708a43570732482e3":["6c4c2f621cc08e950d8f7297eec816e894dc32ac"],"6995e11c4255e48833ad99a0ff00a3a3f85052ff":["485232f1ea519c43967bde67882bbb459a014c4a"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5b61f7bfea082224c17562d045792406aacdee7f":["a80493bb7797a8543824e504521c52eedf449cd4"],"a80493bb7797a8543824e504521c52eedf449cd4":["cdeb103cf038677a26e2bd11e29f5875782e3d64"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"cdeb103cf038677a26e2bd11e29f5875782e3d64":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","a80493bb7797a8543824e504521c52eedf449cd4"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"6c4c2f621cc08e950d8f7297eec816e894dc32ac":["aaca6707c7788ce1c7b82bf708a43570732482e3"],"485232f1ea519c43967bde67882bbb459a014c4a":["6995e11c4255e48833ad99a0ff00a3a3f85052ff"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"aaca6707c7788ce1c7b82bf708a43570732482e3":["cdeb103cf038677a26e2bd11e29f5875782e3d64"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","485232f1ea519c43967bde67882bbb459a014c4a","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"6995e11c4255e48833ad99a0ff00a3a3f85052ff":["6c4c2f621cc08e950d8f7297eec816e894dc32ac"],"5b61f7bfea082224c17562d045792406aacdee7f":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"a80493bb7797a8543824e504521c52eedf449cd4":["5b61f7bfea082224c17562d045792406aacdee7f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}