{"path":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","commits":[{"id":"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5","date":1552136881,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  private SimpleOrderedMap<Object> getFieldInfo(SegmentReader reader, FieldInfo fi, IndexSchema schema) {\n    SimpleOrderedMap<Object> fieldFlags = new SimpleOrderedMap<>();\n    StringBuilder flags = new StringBuilder();\n    IndexOptions opts = fi.getIndexOptions();\n    flags.append( (opts != IndexOptions.NONE) ? FieldFlag.INDEXED.getAbbreviation() : '-' );\n    DocValuesType dvt = fi.getDocValuesType();\n    if (dvt != DocValuesType.NONE) {\n      flags.append(FieldFlag.DOC_VALUES.getAbbreviation());\n      switch (dvt) {\n        case NUMERIC:\n          flags.append(\"num\");\n          break;\n        case BINARY:\n          flags.append(\"bin\");\n          break;\n        case SORTED:\n          flags.append(\"srt\");\n          break;\n        case SORTED_NUMERIC:\n          flags.append(\"srn\");\n          break;\n        case SORTED_SET:\n          flags.append(\"srs\");\n          break;\n        default:\n          flags.append(\"???\"); // should not happen\n      }\n    } else {\n      flags.append(\"----\");\n    }\n    flags.append( (fi.hasVectors()) ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );\n    flags.append( (fi.omitsNorms()) ? FieldFlag.OMIT_NORMS.getAbbreviation() : '-' );\n\n    flags.append( (DOCS == opts ) ?\n        FieldFlag.OMIT_TF.getAbbreviation() : '-' );\n\n    flags.append((DOCS_AND_FREQS == opts) ?\n        FieldFlag.OMIT_POSITIONS.getAbbreviation() : '-');\n\n    flags.append((DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS == opts) ?\n        FieldFlag.STORE_OFFSETS_WITH_POSITIONS.getAbbreviation() : '-');\n\n    flags.append( (fi.hasPayloads() ? \"p\" : \"-\"));\n    flags.append( (fi.isSoftDeletesField() ? \"s\" : \"-\"));\n    if (fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0) {\n      flags.append(\":\");\n      flags.append(fi.getPointDataDimensionCount() + \":\");\n      flags.append(fi.getPointIndexDimensionCount() + \":\");\n      flags.append(fi.getPointNumBytes());\n    }\n\n    fieldFlags.add(\"flags\", flags.toString());\n    try {\n      Terms terms = reader.terms(fi.name);\n      if (terms != null) {\n        fieldFlags.add(\"docCount\", terms.getDocCount());\n        fieldFlags.add(\"sumDocFreq\", terms.getSumDocFreq());\n        fieldFlags.add(\"sumTotalTermFreq\", terms.getSumTotalTermFreq());\n      }\n    } catch (Exception e) {\n      log.debug(\"Exception retrieving term stats for field \" + fi.name, e);\n    }\n\n    // probably too much detail?\n//    Map<String, String> attributes = fi.attributes();\n//    if (!attributes.isEmpty()) {\n//      fieldFlags.add(\"attributes\", attributes);\n//    }\n\n    // check compliance of the index with the current schema\n    SchemaField sf = schema.getFieldOrNull(fi.name);\n    boolean hasPoints = fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0;\n\n    if (sf != null) {\n      fieldFlags.add(\"schemaType\", sf.getType().getTypeName());\n      SimpleOrderedMap<Object> nonCompliant = new SimpleOrderedMap<>();\n      if (sf.hasDocValues() &&\n          fi.getDocValuesType() == DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=\" + sf.getType().getUninversionType(sf) + \", segment=false\");\n      }\n      if (!sf.hasDocValues() &&\n          fi.getDocValuesType() != DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=false, segment=\" + fi.getDocValuesType().toString());\n      }\n      if (!sf.isPolyField()) { // difficult to find all sub-fields in a general way\n        if (sf.indexed() != ((fi.getIndexOptions() != IndexOptions.NONE) || hasPoints)) {\n          nonCompliant.add(\"indexed\", \"schema=\" + sf.indexed() + \", segment=\" + fi.getIndexOptions());\n        }\n      }\n      if (sf.omitNorms() != (fi.omitsNorms() || hasPoints)) {\n        nonCompliant.add(\"omitNorms\", \"schema=\" + sf.omitNorms() + \", segment=\" + fi.omitsNorms());\n      }\n      if (sf.storeTermVector() != fi.hasVectors()) {\n        nonCompliant.add(\"termVectors\", \"schema=\" + sf.storeTermVector() + \", segment=\" + fi.hasVectors());\n      }\n      if (sf.storeOffsetsWithPositions() != (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {\n        nonCompliant.add(\"storeOffsetsWithPositions\", \"schema=\" + sf.storeOffsetsWithPositions() + \", segment=\" + fi.getIndexOptions());\n      }\n\n      if (nonCompliant.size() > 0) {\n        nonCompliant.add(\"schemaField\", sf.toString());\n        fieldFlags.add(\"nonCompliant\", nonCompliant);\n      }\n    } else {\n      fieldFlags.add(\"schemaType\", \"(UNKNOWN)\");\n    }\n    return fieldFlags;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3ad6e19bcb4308271044d303a0308ab4788dc13a","date":1552647157,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","sourceNew":"  private SimpleOrderedMap<Object> getFieldInfo(SegmentReader reader, FieldInfo fi, IndexSchema schema) {\n    SimpleOrderedMap<Object> fieldFlags = new SimpleOrderedMap<>();\n    StringBuilder flags = new StringBuilder();\n    IndexOptions opts = fi.getIndexOptions();\n    flags.append( (opts != IndexOptions.NONE) ? FieldFlag.INDEXED.getAbbreviation() : '-' );\n    DocValuesType dvt = fi.getDocValuesType();\n    if (dvt != DocValuesType.NONE) {\n      flags.append(FieldFlag.DOC_VALUES.getAbbreviation());\n      switch (dvt) {\n        case NUMERIC:\n          flags.append(\"num\");\n          break;\n        case BINARY:\n          flags.append(\"bin\");\n          break;\n        case SORTED:\n          flags.append(\"srt\");\n          break;\n        case SORTED_NUMERIC:\n          flags.append(\"srn\");\n          break;\n        case SORTED_SET:\n          flags.append(\"srs\");\n          break;\n        default:\n          flags.append(\"???\"); // should not happen\n      }\n    } else {\n      flags.append(\"----\");\n    }\n    flags.append( (fi.hasVectors()) ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );\n    flags.append( (fi.omitsNorms()) ? FieldFlag.OMIT_NORMS.getAbbreviation() : '-' );\n\n    flags.append( (DOCS == opts ) ?\n        FieldFlag.OMIT_TF.getAbbreviation() : '-' );\n\n    flags.append((DOCS_AND_FREQS == opts) ?\n        FieldFlag.OMIT_POSITIONS.getAbbreviation() : '-');\n\n    flags.append((DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS == opts) ?\n        FieldFlag.STORE_OFFSETS_WITH_POSITIONS.getAbbreviation() : '-');\n\n    flags.append( (fi.hasPayloads() ? \"p\" : \"-\"));\n    flags.append( (fi.isSoftDeletesField() ? \"s\" : \"-\"));\n    if (fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0) {\n      flags.append(\":\");\n      flags.append(fi.getPointDataDimensionCount() + \":\");\n      flags.append(fi.getPointIndexDimensionCount() + \":\");\n      flags.append(fi.getPointNumBytes());\n    }\n\n    fieldFlags.add(\"flags\", flags.toString());\n    try {\n      Terms terms = reader.terms(fi.name);\n      if (terms != null) {\n        fieldFlags.add(\"docCount\", terms.getDocCount());\n        fieldFlags.add(\"sumDocFreq\", terms.getSumDocFreq());\n        fieldFlags.add(\"sumTotalTermFreq\", terms.getSumTotalTermFreq());\n      }\n    } catch (Exception e) {\n      log.debug(\"Exception retrieving term stats for field \" + fi.name, e);\n    }\n\n    // probably too much detail?\n//    Map<String, String> attributes = fi.attributes();\n//    if (!attributes.isEmpty()) {\n//      fieldFlags.add(\"attributes\", attributes);\n//    }\n\n    // check compliance of the index with the current schema\n    SchemaField sf = schema.getFieldOrNull(fi.name);\n    boolean hasPoints = fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0;\n\n    if (sf != null) {\n      fieldFlags.add(\"schemaType\", sf.getType().getTypeName());\n      SimpleOrderedMap<Object> nonCompliant = new SimpleOrderedMap<>();\n      if (sf.hasDocValues() &&\n          fi.getDocValuesType() == DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=\" + sf.getType().getUninversionType(sf) + \", segment=false\");\n      }\n      if (!sf.hasDocValues() &&\n          fi.getDocValuesType() != DocValuesType.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=false, segment=\" + fi.getDocValuesType().toString());\n      }\n      if (!sf.isPolyField()) { // difficult to find all sub-fields in a general way\n        if (sf.indexed() != ((fi.getIndexOptions() != IndexOptions.NONE) || hasPoints)) {\n          nonCompliant.add(\"indexed\", \"schema=\" + sf.indexed() + \", segment=\" + fi.getIndexOptions());\n        }\n      }\n      if (!hasPoints && (sf.omitNorms() != fi.omitsNorms())) {\n        nonCompliant.add(\"omitNorms\", \"schema=\" + sf.omitNorms() + \", segment=\" + fi.omitsNorms());\n      }\n      if (sf.storeTermVector() != fi.hasVectors()) {\n        nonCompliant.add(\"termVectors\", \"schema=\" + sf.storeTermVector() + \", segment=\" + fi.hasVectors());\n      }\n      if (sf.storeOffsetsWithPositions() != (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {\n        nonCompliant.add(\"storeOffsetsWithPositions\", \"schema=\" + sf.storeOffsetsWithPositions() + \", segment=\" + fi.getIndexOptions());\n      }\n\n      if (nonCompliant.size() > 0) {\n        nonCompliant.add(\"schemaField\", sf.toString());\n        fieldFlags.add(\"nonCompliant\", nonCompliant);\n      }\n    } else {\n      fieldFlags.add(\"schemaType\", \"(UNKNOWN)\");\n    }\n    return fieldFlags;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getFieldInfo(SegmentReader reader, FieldInfo fi, IndexSchema schema) {\n    SimpleOrderedMap<Object> fieldFlags = new SimpleOrderedMap<>();\n    StringBuilder flags = new StringBuilder();\n    IndexOptions opts = fi.getIndexOptions();\n    flags.append( (opts != IndexOptions.NONE) ? FieldFlag.INDEXED.getAbbreviation() : '-' );\n    DocValuesType dvt = fi.getDocValuesType();\n    if (dvt != DocValuesType.NONE) {\n      flags.append(FieldFlag.DOC_VALUES.getAbbreviation());\n      switch (dvt) {\n        case NUMERIC:\n          flags.append(\"num\");\n          break;\n        case BINARY:\n          flags.append(\"bin\");\n          break;\n        case SORTED:\n          flags.append(\"srt\");\n          break;\n        case SORTED_NUMERIC:\n          flags.append(\"srn\");\n          break;\n        case SORTED_SET:\n          flags.append(\"srs\");\n          break;\n        default:\n          flags.append(\"???\"); // should not happen\n      }\n    } else {\n      flags.append(\"----\");\n    }\n    flags.append( (fi.hasVectors()) ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );\n    flags.append( (fi.omitsNorms()) ? FieldFlag.OMIT_NORMS.getAbbreviation() : '-' );\n\n    flags.append( (DOCS == opts ) ?\n        FieldFlag.OMIT_TF.getAbbreviation() : '-' );\n\n    flags.append((DOCS_AND_FREQS == opts) ?\n        FieldFlag.OMIT_POSITIONS.getAbbreviation() : '-');\n\n    flags.append((DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS == opts) ?\n        FieldFlag.STORE_OFFSETS_WITH_POSITIONS.getAbbreviation() : '-');\n\n    flags.append( (fi.hasPayloads() ? \"p\" : \"-\"));\n    flags.append( (fi.isSoftDeletesField() ? \"s\" : \"-\"));\n    if (fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0) {\n      flags.append(\":\");\n      flags.append(fi.getPointDataDimensionCount() + \":\");\n      flags.append(fi.getPointIndexDimensionCount() + \":\");\n      flags.append(fi.getPointNumBytes());\n    }\n\n    fieldFlags.add(\"flags\", flags.toString());\n    try {\n      Terms terms = reader.terms(fi.name);\n      if (terms != null) {\n        fieldFlags.add(\"docCount\", terms.getDocCount());\n        fieldFlags.add(\"sumDocFreq\", terms.getSumDocFreq());\n        fieldFlags.add(\"sumTotalTermFreq\", terms.getSumTotalTermFreq());\n      }\n    } catch (Exception e) {\n      log.debug(\"Exception retrieving term stats for field \" + fi.name, e);\n    }\n\n    // probably too much detail?\n//    Map<String, String> attributes = fi.attributes();\n//    if (!attributes.isEmpty()) {\n//      fieldFlags.add(\"attributes\", attributes);\n//    }\n\n    // check compliance of the index with the current schema\n    SchemaField sf = schema.getFieldOrNull(fi.name);\n    boolean hasPoints = fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0;\n\n    if (sf != null) {\n      fieldFlags.add(\"schemaType\", sf.getType().getTypeName());\n      SimpleOrderedMap<Object> nonCompliant = new SimpleOrderedMap<>();\n      if (sf.hasDocValues() &&\n          fi.getDocValuesType() == DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=\" + sf.getType().getUninversionType(sf) + \", segment=false\");\n      }\n      if (!sf.hasDocValues() &&\n          fi.getDocValuesType() != DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=false, segment=\" + fi.getDocValuesType().toString());\n      }\n      if (!sf.isPolyField()) { // difficult to find all sub-fields in a general way\n        if (sf.indexed() != ((fi.getIndexOptions() != IndexOptions.NONE) || hasPoints)) {\n          nonCompliant.add(\"indexed\", \"schema=\" + sf.indexed() + \", segment=\" + fi.getIndexOptions());\n        }\n      }\n      if (sf.omitNorms() != (fi.omitsNorms() || hasPoints)) {\n        nonCompliant.add(\"omitNorms\", \"schema=\" + sf.omitNorms() + \", segment=\" + fi.omitsNorms());\n      }\n      if (sf.storeTermVector() != fi.hasVectors()) {\n        nonCompliant.add(\"termVectors\", \"schema=\" + sf.storeTermVector() + \", segment=\" + fi.hasVectors());\n      }\n      if (sf.storeOffsetsWithPositions() != (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {\n        nonCompliant.add(\"storeOffsetsWithPositions\", \"schema=\" + sf.storeOffsetsWithPositions() + \", segment=\" + fi.getIndexOptions());\n      }\n\n      if (nonCompliant.size() > 0) {\n        nonCompliant.add(\"schemaField\", sf.toString());\n        fieldFlags.add(\"nonCompliant\", nonCompliant);\n      }\n    } else {\n      fieldFlags.add(\"schemaType\", \"(UNKNOWN)\");\n    }\n    return fieldFlags;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ffe681f212e5073c69955b4ad22946794c84940","date":1560182863,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","sourceNew":"  private SimpleOrderedMap<Object> getFieldInfo(SegmentReader reader, FieldInfo fi, IndexSchema schema) {\n    SimpleOrderedMap<Object> fieldFlags = new SimpleOrderedMap<>();\n    StringBuilder flags = new StringBuilder();\n    IndexOptions opts = fi.getIndexOptions();\n    flags.append( (opts != IndexOptions.NONE) ? FieldFlag.INDEXED.getAbbreviation() : '-' );\n    DocValuesType dvt = fi.getDocValuesType();\n    if (dvt != DocValuesType.NONE) {\n      flags.append(FieldFlag.DOC_VALUES.getAbbreviation());\n      switch (dvt) {\n        case NUMERIC:\n          flags.append(\"num\");\n          break;\n        case BINARY:\n          flags.append(\"bin\");\n          break;\n        case SORTED:\n          flags.append(\"srt\");\n          break;\n        case SORTED_NUMERIC:\n          flags.append(\"srn\");\n          break;\n        case SORTED_SET:\n          flags.append(\"srs\");\n          break;\n        default:\n          flags.append(\"???\"); // should not happen\n      }\n    } else {\n      flags.append(\"----\");\n    }\n    flags.append( (fi.hasVectors()) ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );\n    flags.append( (fi.omitsNorms()) ? FieldFlag.OMIT_NORMS.getAbbreviation() : '-' );\n\n    flags.append( (DOCS == opts ) ?\n        FieldFlag.OMIT_TF.getAbbreviation() : '-' );\n\n    flags.append((DOCS_AND_FREQS == opts) ?\n        FieldFlag.OMIT_POSITIONS.getAbbreviation() : '-');\n\n    flags.append((DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS == opts) ?\n        FieldFlag.STORE_OFFSETS_WITH_POSITIONS.getAbbreviation() : '-');\n\n    flags.append( (fi.hasPayloads() ? \"p\" : \"-\"));\n    flags.append( (fi.isSoftDeletesField() ? \"s\" : \"-\"));\n    if (fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0) {\n      flags.append(\":\");\n      flags.append(fi.getPointDataDimensionCount()).append(':');\n      flags.append(fi.getPointIndexDimensionCount()).append(':');\n      flags.append(fi.getPointNumBytes());\n    }\n\n    fieldFlags.add(\"flags\", flags.toString());\n    try {\n      Terms terms = reader.terms(fi.name);\n      if (terms != null) {\n        fieldFlags.add(\"docCount\", terms.getDocCount());\n        fieldFlags.add(\"sumDocFreq\", terms.getSumDocFreq());\n        fieldFlags.add(\"sumTotalTermFreq\", terms.getSumTotalTermFreq());\n      }\n    } catch (Exception e) {\n      log.debug(\"Exception retrieving term stats for field \" + fi.name, e);\n    }\n\n    // probably too much detail?\n//    Map<String, String> attributes = fi.attributes();\n//    if (!attributes.isEmpty()) {\n//      fieldFlags.add(\"attributes\", attributes);\n//    }\n\n    // check compliance of the index with the current schema\n    SchemaField sf = schema.getFieldOrNull(fi.name);\n    boolean hasPoints = fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0;\n\n    if (sf != null) {\n      fieldFlags.add(\"schemaType\", sf.getType().getTypeName());\n      SimpleOrderedMap<Object> nonCompliant = new SimpleOrderedMap<>();\n      if (sf.hasDocValues() &&\n          fi.getDocValuesType() == DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=\" + sf.getType().getUninversionType(sf) + \", segment=false\");\n      }\n      if (!sf.hasDocValues() &&\n          fi.getDocValuesType() != DocValuesType.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=false, segment=\" + fi.getDocValuesType().toString());\n      }\n      if (!sf.isPolyField()) { // difficult to find all sub-fields in a general way\n        if (sf.indexed() != ((fi.getIndexOptions() != IndexOptions.NONE) || hasPoints)) {\n          nonCompliant.add(\"indexed\", \"schema=\" + sf.indexed() + \", segment=\" + fi.getIndexOptions());\n        }\n      }\n      if (!hasPoints && (sf.omitNorms() != fi.omitsNorms())) {\n        nonCompliant.add(\"omitNorms\", \"schema=\" + sf.omitNorms() + \", segment=\" + fi.omitsNorms());\n      }\n      if (sf.storeTermVector() != fi.hasVectors()) {\n        nonCompliant.add(\"termVectors\", \"schema=\" + sf.storeTermVector() + \", segment=\" + fi.hasVectors());\n      }\n      if (sf.storeOffsetsWithPositions() != (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {\n        nonCompliant.add(\"storeOffsetsWithPositions\", \"schema=\" + sf.storeOffsetsWithPositions() + \", segment=\" + fi.getIndexOptions());\n      }\n\n      if (nonCompliant.size() > 0) {\n        nonCompliant.add(\"schemaField\", sf.toString());\n        fieldFlags.add(\"nonCompliant\", nonCompliant);\n      }\n    } else {\n      fieldFlags.add(\"schemaType\", \"(UNKNOWN)\");\n    }\n    return fieldFlags;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getFieldInfo(SegmentReader reader, FieldInfo fi, IndexSchema schema) {\n    SimpleOrderedMap<Object> fieldFlags = new SimpleOrderedMap<>();\n    StringBuilder flags = new StringBuilder();\n    IndexOptions opts = fi.getIndexOptions();\n    flags.append( (opts != IndexOptions.NONE) ? FieldFlag.INDEXED.getAbbreviation() : '-' );\n    DocValuesType dvt = fi.getDocValuesType();\n    if (dvt != DocValuesType.NONE) {\n      flags.append(FieldFlag.DOC_VALUES.getAbbreviation());\n      switch (dvt) {\n        case NUMERIC:\n          flags.append(\"num\");\n          break;\n        case BINARY:\n          flags.append(\"bin\");\n          break;\n        case SORTED:\n          flags.append(\"srt\");\n          break;\n        case SORTED_NUMERIC:\n          flags.append(\"srn\");\n          break;\n        case SORTED_SET:\n          flags.append(\"srs\");\n          break;\n        default:\n          flags.append(\"???\"); // should not happen\n      }\n    } else {\n      flags.append(\"----\");\n    }\n    flags.append( (fi.hasVectors()) ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );\n    flags.append( (fi.omitsNorms()) ? FieldFlag.OMIT_NORMS.getAbbreviation() : '-' );\n\n    flags.append( (DOCS == opts ) ?\n        FieldFlag.OMIT_TF.getAbbreviation() : '-' );\n\n    flags.append((DOCS_AND_FREQS == opts) ?\n        FieldFlag.OMIT_POSITIONS.getAbbreviation() : '-');\n\n    flags.append((DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS == opts) ?\n        FieldFlag.STORE_OFFSETS_WITH_POSITIONS.getAbbreviation() : '-');\n\n    flags.append( (fi.hasPayloads() ? \"p\" : \"-\"));\n    flags.append( (fi.isSoftDeletesField() ? \"s\" : \"-\"));\n    if (fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0) {\n      flags.append(\":\");\n      flags.append(fi.getPointDataDimensionCount() + \":\");\n      flags.append(fi.getPointIndexDimensionCount() + \":\");\n      flags.append(fi.getPointNumBytes());\n    }\n\n    fieldFlags.add(\"flags\", flags.toString());\n    try {\n      Terms terms = reader.terms(fi.name);\n      if (terms != null) {\n        fieldFlags.add(\"docCount\", terms.getDocCount());\n        fieldFlags.add(\"sumDocFreq\", terms.getSumDocFreq());\n        fieldFlags.add(\"sumTotalTermFreq\", terms.getSumTotalTermFreq());\n      }\n    } catch (Exception e) {\n      log.debug(\"Exception retrieving term stats for field \" + fi.name, e);\n    }\n\n    // probably too much detail?\n//    Map<String, String> attributes = fi.attributes();\n//    if (!attributes.isEmpty()) {\n//      fieldFlags.add(\"attributes\", attributes);\n//    }\n\n    // check compliance of the index with the current schema\n    SchemaField sf = schema.getFieldOrNull(fi.name);\n    boolean hasPoints = fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0;\n\n    if (sf != null) {\n      fieldFlags.add(\"schemaType\", sf.getType().getTypeName());\n      SimpleOrderedMap<Object> nonCompliant = new SimpleOrderedMap<>();\n      if (sf.hasDocValues() &&\n          fi.getDocValuesType() == DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=\" + sf.getType().getUninversionType(sf) + \", segment=false\");\n      }\n      if (!sf.hasDocValues() &&\n          fi.getDocValuesType() != DocValuesType.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=false, segment=\" + fi.getDocValuesType().toString());\n      }\n      if (!sf.isPolyField()) { // difficult to find all sub-fields in a general way\n        if (sf.indexed() != ((fi.getIndexOptions() != IndexOptions.NONE) || hasPoints)) {\n          nonCompliant.add(\"indexed\", \"schema=\" + sf.indexed() + \", segment=\" + fi.getIndexOptions());\n        }\n      }\n      if (!hasPoints && (sf.omitNorms() != fi.omitsNorms())) {\n        nonCompliant.add(\"omitNorms\", \"schema=\" + sf.omitNorms() + \", segment=\" + fi.omitsNorms());\n      }\n      if (sf.storeTermVector() != fi.hasVectors()) {\n        nonCompliant.add(\"termVectors\", \"schema=\" + sf.storeTermVector() + \", segment=\" + fi.hasVectors());\n      }\n      if (sf.storeOffsetsWithPositions() != (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {\n        nonCompliant.add(\"storeOffsetsWithPositions\", \"schema=\" + sf.storeOffsetsWithPositions() + \", segment=\" + fi.getIndexOptions());\n      }\n\n      if (nonCompliant.size() > 0) {\n        nonCompliant.add(\"schemaField\", sf.toString());\n        fieldFlags.add(\"nonCompliant\", nonCompliant);\n      }\n    } else {\n      fieldFlags.add(\"schemaType\", \"(UNKNOWN)\");\n    }\n    return fieldFlags;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","sourceNew":"  private SimpleOrderedMap<Object> getFieldInfo(SegmentReader reader, FieldInfo fi, IndexSchema schema) {\n    SimpleOrderedMap<Object> fieldFlags = new SimpleOrderedMap<>();\n    StringBuilder flags = new StringBuilder();\n    IndexOptions opts = fi.getIndexOptions();\n    flags.append( (opts != IndexOptions.NONE) ? FieldFlag.INDEXED.getAbbreviation() : '-' );\n    DocValuesType dvt = fi.getDocValuesType();\n    if (dvt != DocValuesType.NONE) {\n      flags.append(FieldFlag.DOC_VALUES.getAbbreviation());\n      switch (dvt) {\n        case NUMERIC:\n          flags.append(\"num\");\n          break;\n        case BINARY:\n          flags.append(\"bin\");\n          break;\n        case SORTED:\n          flags.append(\"srt\");\n          break;\n        case SORTED_NUMERIC:\n          flags.append(\"srn\");\n          break;\n        case SORTED_SET:\n          flags.append(\"srs\");\n          break;\n        default:\n          flags.append(\"???\"); // should not happen\n      }\n    } else {\n      flags.append(\"----\");\n    }\n    flags.append( (fi.hasVectors()) ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );\n    flags.append( (fi.omitsNorms()) ? FieldFlag.OMIT_NORMS.getAbbreviation() : '-' );\n\n    flags.append( (DOCS == opts ) ?\n        FieldFlag.OMIT_TF.getAbbreviation() : '-' );\n\n    flags.append((DOCS_AND_FREQS == opts) ?\n        FieldFlag.OMIT_POSITIONS.getAbbreviation() : '-');\n\n    flags.append((DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS == opts) ?\n        FieldFlag.STORE_OFFSETS_WITH_POSITIONS.getAbbreviation() : '-');\n\n    flags.append( (fi.hasPayloads() ? \"p\" : \"-\"));\n    flags.append( (fi.isSoftDeletesField() ? \"s\" : \"-\"));\n    if (fi.getPointDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0) {\n      flags.append(\":\");\n      flags.append(fi.getPointDimensionCount()).append(':');\n      flags.append(fi.getPointIndexDimensionCount()).append(':');\n      flags.append(fi.getPointNumBytes());\n    }\n\n    fieldFlags.add(\"flags\", flags.toString());\n    try {\n      Terms terms = reader.terms(fi.name);\n      if (terms != null) {\n        fieldFlags.add(\"docCount\", terms.getDocCount());\n        fieldFlags.add(\"sumDocFreq\", terms.getSumDocFreq());\n        fieldFlags.add(\"sumTotalTermFreq\", terms.getSumTotalTermFreq());\n      }\n    } catch (Exception e) {\n      log.debug(\"Exception retrieving term stats for field \" + fi.name, e);\n    }\n\n    // probably too much detail?\n//    Map<String, String> attributes = fi.attributes();\n//    if (!attributes.isEmpty()) {\n//      fieldFlags.add(\"attributes\", attributes);\n//    }\n\n    // check compliance of the index with the current schema\n    SchemaField sf = schema.getFieldOrNull(fi.name);\n    boolean hasPoints = fi.getPointDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0;\n\n    if (sf != null) {\n      fieldFlags.add(\"schemaType\", sf.getType().getTypeName());\n      SimpleOrderedMap<Object> nonCompliant = new SimpleOrderedMap<>();\n      if (sf.hasDocValues() &&\n          fi.getDocValuesType() == DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=\" + sf.getType().getUninversionType(sf) + \", segment=false\");\n      }\n      if (!sf.hasDocValues() &&\n          fi.getDocValuesType() != DocValuesType.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=false, segment=\" + fi.getDocValuesType().toString());\n      }\n      if (!sf.isPolyField()) { // difficult to find all sub-fields in a general way\n        if (sf.indexed() != ((fi.getIndexOptions() != IndexOptions.NONE) || hasPoints)) {\n          nonCompliant.add(\"indexed\", \"schema=\" + sf.indexed() + \", segment=\" + fi.getIndexOptions());\n        }\n      }\n      if (!hasPoints && (sf.omitNorms() != fi.omitsNorms())) {\n        nonCompliant.add(\"omitNorms\", \"schema=\" + sf.omitNorms() + \", segment=\" + fi.omitsNorms());\n      }\n      if (sf.storeTermVector() != fi.hasVectors()) {\n        nonCompliant.add(\"termVectors\", \"schema=\" + sf.storeTermVector() + \", segment=\" + fi.hasVectors());\n      }\n      if (sf.storeOffsetsWithPositions() != (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {\n        nonCompliant.add(\"storeOffsetsWithPositions\", \"schema=\" + sf.storeOffsetsWithPositions() + \", segment=\" + fi.getIndexOptions());\n      }\n\n      if (nonCompliant.size() > 0) {\n        nonCompliant.add(\"schemaField\", sf.toString());\n        fieldFlags.add(\"nonCompliant\", nonCompliant);\n      }\n    } else {\n      fieldFlags.add(\"schemaType\", \"(UNKNOWN)\");\n    }\n    return fieldFlags;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getFieldInfo(SegmentReader reader, FieldInfo fi, IndexSchema schema) {\n    SimpleOrderedMap<Object> fieldFlags = new SimpleOrderedMap<>();\n    StringBuilder flags = new StringBuilder();\n    IndexOptions opts = fi.getIndexOptions();\n    flags.append( (opts != IndexOptions.NONE) ? FieldFlag.INDEXED.getAbbreviation() : '-' );\n    DocValuesType dvt = fi.getDocValuesType();\n    if (dvt != DocValuesType.NONE) {\n      flags.append(FieldFlag.DOC_VALUES.getAbbreviation());\n      switch (dvt) {\n        case NUMERIC:\n          flags.append(\"num\");\n          break;\n        case BINARY:\n          flags.append(\"bin\");\n          break;\n        case SORTED:\n          flags.append(\"srt\");\n          break;\n        case SORTED_NUMERIC:\n          flags.append(\"srn\");\n          break;\n        case SORTED_SET:\n          flags.append(\"srs\");\n          break;\n        default:\n          flags.append(\"???\"); // should not happen\n      }\n    } else {\n      flags.append(\"----\");\n    }\n    flags.append( (fi.hasVectors()) ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );\n    flags.append( (fi.omitsNorms()) ? FieldFlag.OMIT_NORMS.getAbbreviation() : '-' );\n\n    flags.append( (DOCS == opts ) ?\n        FieldFlag.OMIT_TF.getAbbreviation() : '-' );\n\n    flags.append((DOCS_AND_FREQS == opts) ?\n        FieldFlag.OMIT_POSITIONS.getAbbreviation() : '-');\n\n    flags.append((DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS == opts) ?\n        FieldFlag.STORE_OFFSETS_WITH_POSITIONS.getAbbreviation() : '-');\n\n    flags.append( (fi.hasPayloads() ? \"p\" : \"-\"));\n    flags.append( (fi.isSoftDeletesField() ? \"s\" : \"-\"));\n    if (fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0) {\n      flags.append(\":\");\n      flags.append(fi.getPointDataDimensionCount()).append(':');\n      flags.append(fi.getPointIndexDimensionCount()).append(':');\n      flags.append(fi.getPointNumBytes());\n    }\n\n    fieldFlags.add(\"flags\", flags.toString());\n    try {\n      Terms terms = reader.terms(fi.name);\n      if (terms != null) {\n        fieldFlags.add(\"docCount\", terms.getDocCount());\n        fieldFlags.add(\"sumDocFreq\", terms.getSumDocFreq());\n        fieldFlags.add(\"sumTotalTermFreq\", terms.getSumTotalTermFreq());\n      }\n    } catch (Exception e) {\n      log.debug(\"Exception retrieving term stats for field \" + fi.name, e);\n    }\n\n    // probably too much detail?\n//    Map<String, String> attributes = fi.attributes();\n//    if (!attributes.isEmpty()) {\n//      fieldFlags.add(\"attributes\", attributes);\n//    }\n\n    // check compliance of the index with the current schema\n    SchemaField sf = schema.getFieldOrNull(fi.name);\n    boolean hasPoints = fi.getPointDataDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0;\n\n    if (sf != null) {\n      fieldFlags.add(\"schemaType\", sf.getType().getTypeName());\n      SimpleOrderedMap<Object> nonCompliant = new SimpleOrderedMap<>();\n      if (sf.hasDocValues() &&\n          fi.getDocValuesType() == DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=\" + sf.getType().getUninversionType(sf) + \", segment=false\");\n      }\n      if (!sf.hasDocValues() &&\n          fi.getDocValuesType() != DocValuesType.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=false, segment=\" + fi.getDocValuesType().toString());\n      }\n      if (!sf.isPolyField()) { // difficult to find all sub-fields in a general way\n        if (sf.indexed() != ((fi.getIndexOptions() != IndexOptions.NONE) || hasPoints)) {\n          nonCompliant.add(\"indexed\", \"schema=\" + sf.indexed() + \", segment=\" + fi.getIndexOptions());\n        }\n      }\n      if (!hasPoints && (sf.omitNorms() != fi.omitsNorms())) {\n        nonCompliant.add(\"omitNorms\", \"schema=\" + sf.omitNorms() + \", segment=\" + fi.omitsNorms());\n      }\n      if (sf.storeTermVector() != fi.hasVectors()) {\n        nonCompliant.add(\"termVectors\", \"schema=\" + sf.storeTermVector() + \", segment=\" + fi.hasVectors());\n      }\n      if (sf.storeOffsetsWithPositions() != (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {\n        nonCompliant.add(\"storeOffsetsWithPositions\", \"schema=\" + sf.storeOffsetsWithPositions() + \", segment=\" + fi.getIndexOptions());\n      }\n\n      if (nonCompliant.size() > 0) {\n        nonCompliant.add(\"schemaField\", sf.toString());\n        fieldFlags.add(\"nonCompliant\", nonCompliant);\n      }\n    } else {\n      fieldFlags.add(\"schemaType\", \"(UNKNOWN)\");\n    }\n    return fieldFlags;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getFieldInfo(SegmentReader,FieldInfo,IndexSchema).mjava","sourceNew":"  private SimpleOrderedMap<Object> getFieldInfo(SegmentReader reader, FieldInfo fi, IndexSchema schema) {\n    SimpleOrderedMap<Object> fieldFlags = new SimpleOrderedMap<>();\n    StringBuilder flags = new StringBuilder();\n    IndexOptions opts = fi.getIndexOptions();\n    flags.append( (opts != IndexOptions.NONE) ? FieldFlag.INDEXED.getAbbreviation() : '-' );\n    DocValuesType dvt = fi.getDocValuesType();\n    if (dvt != DocValuesType.NONE) {\n      flags.append(FieldFlag.DOC_VALUES.getAbbreviation());\n      switch (dvt) {\n        case NUMERIC:\n          flags.append(\"num\");\n          break;\n        case BINARY:\n          flags.append(\"bin\");\n          break;\n        case SORTED:\n          flags.append(\"srt\");\n          break;\n        case SORTED_NUMERIC:\n          flags.append(\"srn\");\n          break;\n        case SORTED_SET:\n          flags.append(\"srs\");\n          break;\n        default:\n          flags.append(\"???\"); // should not happen\n      }\n    } else {\n      flags.append(\"----\");\n    }\n    flags.append( (fi.hasVectors()) ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );\n    flags.append( (fi.omitsNorms()) ? FieldFlag.OMIT_NORMS.getAbbreviation() : '-' );\n\n    flags.append( (DOCS == opts ) ?\n        FieldFlag.OMIT_TF.getAbbreviation() : '-' );\n\n    flags.append((DOCS_AND_FREQS == opts) ?\n        FieldFlag.OMIT_POSITIONS.getAbbreviation() : '-');\n\n    flags.append((DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS == opts) ?\n        FieldFlag.STORE_OFFSETS_WITH_POSITIONS.getAbbreviation() : '-');\n\n    flags.append( (fi.hasPayloads() ? \"p\" : \"-\"));\n    flags.append( (fi.isSoftDeletesField() ? \"s\" : \"-\"));\n    if (fi.getPointDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0) {\n      flags.append(\":\");\n      flags.append(fi.getPointDimensionCount()).append(':');\n      flags.append(fi.getPointIndexDimensionCount()).append(':');\n      flags.append(fi.getPointNumBytes());\n    }\n\n    fieldFlags.add(\"flags\", flags.toString());\n    try {\n      Terms terms = reader.terms(fi.name);\n      if (terms != null) {\n        fieldFlags.add(\"docCount\", terms.getDocCount());\n        fieldFlags.add(\"sumDocFreq\", terms.getSumDocFreq());\n        fieldFlags.add(\"sumTotalTermFreq\", terms.getSumTotalTermFreq());\n      }\n    } catch (Exception e) {\n      log.debug(\"Exception retrieving term stats for field {}\", fi.name, e);\n    }\n\n    // probably too much detail?\n//    Map<String, String> attributes = fi.attributes();\n//    if (!attributes.isEmpty()) {\n//      fieldFlags.add(\"attributes\", attributes);\n//    }\n\n    // check compliance of the index with the current schema\n    SchemaField sf = schema.getFieldOrNull(fi.name);\n    boolean hasPoints = fi.getPointDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0;\n\n    if (sf != null) {\n      fieldFlags.add(\"schemaType\", sf.getType().getTypeName());\n      SimpleOrderedMap<Object> nonCompliant = new SimpleOrderedMap<>();\n      if (sf.hasDocValues() &&\n          fi.getDocValuesType() == DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=\" + sf.getType().getUninversionType(sf) + \", segment=false\");\n      }\n      if (!sf.hasDocValues() &&\n          fi.getDocValuesType() != DocValuesType.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=false, segment=\" + fi.getDocValuesType().toString());\n      }\n      if (!sf.isPolyField()) { // difficult to find all sub-fields in a general way\n        if (sf.indexed() != ((fi.getIndexOptions() != IndexOptions.NONE) || hasPoints)) {\n          nonCompliant.add(\"indexed\", \"schema=\" + sf.indexed() + \", segment=\" + fi.getIndexOptions());\n        }\n      }\n      if (!hasPoints && (sf.omitNorms() != fi.omitsNorms())) {\n        nonCompliant.add(\"omitNorms\", \"schema=\" + sf.omitNorms() + \", segment=\" + fi.omitsNorms());\n      }\n      if (sf.storeTermVector() != fi.hasVectors()) {\n        nonCompliant.add(\"termVectors\", \"schema=\" + sf.storeTermVector() + \", segment=\" + fi.hasVectors());\n      }\n      if (sf.storeOffsetsWithPositions() != (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {\n        nonCompliant.add(\"storeOffsetsWithPositions\", \"schema=\" + sf.storeOffsetsWithPositions() + \", segment=\" + fi.getIndexOptions());\n      }\n\n      if (nonCompliant.size() > 0) {\n        nonCompliant.add(\"schemaField\", sf.toString());\n        fieldFlags.add(\"nonCompliant\", nonCompliant);\n      }\n    } else {\n      fieldFlags.add(\"schemaType\", \"(UNKNOWN)\");\n    }\n    return fieldFlags;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getFieldInfo(SegmentReader reader, FieldInfo fi, IndexSchema schema) {\n    SimpleOrderedMap<Object> fieldFlags = new SimpleOrderedMap<>();\n    StringBuilder flags = new StringBuilder();\n    IndexOptions opts = fi.getIndexOptions();\n    flags.append( (opts != IndexOptions.NONE) ? FieldFlag.INDEXED.getAbbreviation() : '-' );\n    DocValuesType dvt = fi.getDocValuesType();\n    if (dvt != DocValuesType.NONE) {\n      flags.append(FieldFlag.DOC_VALUES.getAbbreviation());\n      switch (dvt) {\n        case NUMERIC:\n          flags.append(\"num\");\n          break;\n        case BINARY:\n          flags.append(\"bin\");\n          break;\n        case SORTED:\n          flags.append(\"srt\");\n          break;\n        case SORTED_NUMERIC:\n          flags.append(\"srn\");\n          break;\n        case SORTED_SET:\n          flags.append(\"srs\");\n          break;\n        default:\n          flags.append(\"???\"); // should not happen\n      }\n    } else {\n      flags.append(\"----\");\n    }\n    flags.append( (fi.hasVectors()) ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );\n    flags.append( (fi.omitsNorms()) ? FieldFlag.OMIT_NORMS.getAbbreviation() : '-' );\n\n    flags.append( (DOCS == opts ) ?\n        FieldFlag.OMIT_TF.getAbbreviation() : '-' );\n\n    flags.append((DOCS_AND_FREQS == opts) ?\n        FieldFlag.OMIT_POSITIONS.getAbbreviation() : '-');\n\n    flags.append((DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS == opts) ?\n        FieldFlag.STORE_OFFSETS_WITH_POSITIONS.getAbbreviation() : '-');\n\n    flags.append( (fi.hasPayloads() ? \"p\" : \"-\"));\n    flags.append( (fi.isSoftDeletesField() ? \"s\" : \"-\"));\n    if (fi.getPointDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0) {\n      flags.append(\":\");\n      flags.append(fi.getPointDimensionCount()).append(':');\n      flags.append(fi.getPointIndexDimensionCount()).append(':');\n      flags.append(fi.getPointNumBytes());\n    }\n\n    fieldFlags.add(\"flags\", flags.toString());\n    try {\n      Terms terms = reader.terms(fi.name);\n      if (terms != null) {\n        fieldFlags.add(\"docCount\", terms.getDocCount());\n        fieldFlags.add(\"sumDocFreq\", terms.getSumDocFreq());\n        fieldFlags.add(\"sumTotalTermFreq\", terms.getSumTotalTermFreq());\n      }\n    } catch (Exception e) {\n      log.debug(\"Exception retrieving term stats for field \" + fi.name, e);\n    }\n\n    // probably too much detail?\n//    Map<String, String> attributes = fi.attributes();\n//    if (!attributes.isEmpty()) {\n//      fieldFlags.add(\"attributes\", attributes);\n//    }\n\n    // check compliance of the index with the current schema\n    SchemaField sf = schema.getFieldOrNull(fi.name);\n    boolean hasPoints = fi.getPointDimensionCount() > 0 || fi.getPointIndexDimensionCount() > 0;\n\n    if (sf != null) {\n      fieldFlags.add(\"schemaType\", sf.getType().getTypeName());\n      SimpleOrderedMap<Object> nonCompliant = new SimpleOrderedMap<>();\n      if (sf.hasDocValues() &&\n          fi.getDocValuesType() == DocValuesType.NONE &&\n          fi.getIndexOptions() != IndexOptions.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=\" + sf.getType().getUninversionType(sf) + \", segment=false\");\n      }\n      if (!sf.hasDocValues() &&\n          fi.getDocValuesType() != DocValuesType.NONE) {\n        nonCompliant.add(\"docValues\", \"schema=false, segment=\" + fi.getDocValuesType().toString());\n      }\n      if (!sf.isPolyField()) { // difficult to find all sub-fields in a general way\n        if (sf.indexed() != ((fi.getIndexOptions() != IndexOptions.NONE) || hasPoints)) {\n          nonCompliant.add(\"indexed\", \"schema=\" + sf.indexed() + \", segment=\" + fi.getIndexOptions());\n        }\n      }\n      if (!hasPoints && (sf.omitNorms() != fi.omitsNorms())) {\n        nonCompliant.add(\"omitNorms\", \"schema=\" + sf.omitNorms() + \", segment=\" + fi.omitsNorms());\n      }\n      if (sf.storeTermVector() != fi.hasVectors()) {\n        nonCompliant.add(\"termVectors\", \"schema=\" + sf.storeTermVector() + \", segment=\" + fi.hasVectors());\n      }\n      if (sf.storeOffsetsWithPositions() != (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {\n        nonCompliant.add(\"storeOffsetsWithPositions\", \"schema=\" + sf.storeOffsetsWithPositions() + \", segment=\" + fi.getIndexOptions());\n      }\n\n      if (nonCompliant.size() > 0) {\n        nonCompliant.add(\"schemaField\", sf.toString());\n        fieldFlags.add(\"nonCompliant\", nonCompliant);\n      }\n    } else {\n      fieldFlags.add(\"schemaType\", \"(UNKNOWN)\");\n    }\n    return fieldFlags;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ffe681f212e5073c69955b4ad22946794c84940":["3ad6e19bcb4308271044d303a0308ab4788dc13a"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["2ffe681f212e5073c69955b4ad22946794c84940"],"3ad6e19bcb4308271044d303a0308ab4788dc13a":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"575e66bd4b2349209027f6801184da7fc3cba13f":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"2ffe681f212e5073c69955b4ad22946794c84940":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["575e66bd4b2349209027f6801184da7fc3cba13f"],"3ad6e19bcb4308271044d303a0308ab4788dc13a":["2ffe681f212e5073c69955b4ad22946794c84940"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5"],"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5":["3ad6e19bcb4308271044d303a0308ab4788dc13a"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}