{"path":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getTestDataForAllReplicas().mjava","commits":[{"id":"c92ac83d1c2f8811300bb0df797465cca0aa8e92","date":1579710745,"type":1,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getTestDataForAllReplicas().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","sourceNew":"  /**\n   * returns a map whose key is the coreNodeName and whose value is data about that core needed for the test\n   */\n  private Map<String,ReplicaData> getTestDataForAllReplicas() throws IOException, SolrServerException {\n    Map<String,ReplicaData> results = new HashMap<>();\n\n    DocCollection collectionState = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n\n    for (Replica replica : collectionState.getReplicas()) {\n\n      String coreName = replica.getCoreName();\n      try (HttpSolrClient client = getHttpSolrClient(replica.getCoreUrl())) {\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\", \"indexversion\");\n        params.set(\"_trace\", \"getIndexVersion\");\n        params.set(\"qt\", ReplicationHandler.PATH);\n        QueryRequest req = setAuthIfNeeded(new QueryRequest(params));\n\n        NamedList<Object> res = client.request(req);\n        assertNotNull(\"null response from server: \" + coreName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + coreName, version);\n        assertTrue(\"version isn't a long: \" + coreName, version instanceof Long);\n\n        long numDocs = \n          setAuthIfNeeded(new QueryRequest\n                          (params(\"q\", \"*:*\",\n                                  \"distrib\", \"false\",\n                                  \"rows\", \"0\",\n                                  \"_trace\", \"counting_docs\"))).process(client).getResults().getNumFound();\n\n        final ReplicaData data = new ReplicaData(replica.getSlice(),coreName,(Long)version,numDocs);\n        log.info(\"{}\", data);\n        results.put(coreName, data);\n\n      }\n    }\n\n    return results;\n  }\n\n","sourceOld":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    DocCollection collectionState = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n\n    for (Replica replica : collectionState.getReplicas()) {\n\n      String coreName = replica.getCoreName();\n      try (HttpSolrClient client = getHttpSolrClient(replica.getCoreUrl())) {\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\", \"indexversion\");\n        params.set(\"_trace\", \"getIndexVersion\");\n        params.set(\"qt\", ReplicationHandler.PATH);\n        QueryRequest req = new QueryRequest(params);\n\n        NamedList<Object> res = client.request(req);\n        assertNotNull(\"null response from server: \" + coreName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + coreName, version);\n        assertTrue(\"version isn't a long: \" + coreName, version instanceof Long);\n        results.put(coreName, (Long) version);\n\n        long numDocs = client.query(params(\"q\", \"*:*\", \"distrib\", \"false\", \"rows\", \"0\", \"_trace\", \"counting_docs\"))\n            .getResults().getNumFound();\n        log.info(\"core=\" + coreName + \"; ver=\" + version +\n            \"; numDocs=\" + numDocs);\n\n      }\n    }\n\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getTestDataForAllReplicas().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getTestDataForAllReplicas().mjava","sourceNew":"  /**\n   * returns a map whose key is the coreNodeName and whose value is data about that core needed for the test\n   */\n  private Map<String,ReplicaData> getTestDataForAllReplicas() throws IOException, SolrServerException {\n    Map<String,ReplicaData> results = new HashMap<>();\n\n    DocCollection collectionState = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n\n    for (Replica replica : collectionState.getReplicas()) {\n\n      String coreName = replica.getCoreName();\n      try (HttpSolrClient client = getHttpSolrClient(replica.getCoreUrl())) {\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\", \"indexversion\");\n        params.set(\"_trace\", \"getIndexVersion\");\n        params.set(\"qt\", ReplicationHandler.PATH);\n        QueryRequest req = setAuthIfNeeded(new QueryRequest(params));\n\n        NamedList<Object> res = client.request(req);\n        assertNotNull(\"null response from server: \" + coreName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + coreName, version);\n        assertTrue(\"version isn't a long: \" + coreName, version instanceof Long);\n\n        long numDocs = \n          setAuthIfNeeded(new QueryRequest\n                          (params(\"q\", \"*:*\",\n                                  \"distrib\", \"false\",\n                                  \"rows\", \"0\",\n                                  \"_trace\", \"counting_docs\"))).process(client).getResults().getNumFound();\n\n        final ReplicaData data = new ReplicaData(replica.getShard(),coreName,(Long)version,numDocs);\n        log.info(\"{}\", data);\n        results.put(coreName, data);\n\n      }\n    }\n\n    return results;\n  }\n\n","sourceOld":"  /**\n   * returns a map whose key is the coreNodeName and whose value is data about that core needed for the test\n   */\n  private Map<String,ReplicaData> getTestDataForAllReplicas() throws IOException, SolrServerException {\n    Map<String,ReplicaData> results = new HashMap<>();\n\n    DocCollection collectionState = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n\n    for (Replica replica : collectionState.getReplicas()) {\n\n      String coreName = replica.getCoreName();\n      try (HttpSolrClient client = getHttpSolrClient(replica.getCoreUrl())) {\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\", \"indexversion\");\n        params.set(\"_trace\", \"getIndexVersion\");\n        params.set(\"qt\", ReplicationHandler.PATH);\n        QueryRequest req = setAuthIfNeeded(new QueryRequest(params));\n\n        NamedList<Object> res = client.request(req);\n        assertNotNull(\"null response from server: \" + coreName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + coreName, version);\n        assertTrue(\"version isn't a long: \" + coreName, version instanceof Long);\n\n        long numDocs = \n          setAuthIfNeeded(new QueryRequest\n                          (params(\"q\", \"*:*\",\n                                  \"distrib\", \"false\",\n                                  \"rows\", \"0\",\n                                  \"_trace\", \"counting_docs\"))).process(client).getResults().getNumFound();\n\n        final ReplicaData data = new ReplicaData(replica.getSlice(),coreName,(Long)version,numDocs);\n        log.info(\"{}\", data);\n        results.put(coreName, data);\n\n      }\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["c92ac83d1c2f8811300bb0df797465cca0aa8e92"],"c92ac83d1c2f8811300bb0df797465cca0aa8e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"]},"commit2Childs":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c92ac83d1c2f8811300bb0df797465cca0aa8e92":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c92ac83d1c2f8811300bb0df797465cca0aa8e92"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}