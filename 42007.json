{"path":"lucene/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","commits":[{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      \n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n\n      final boolean positions;\n\n      OffsetAttribute offsetAtt;\n\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      if (termsEnum.next() != null) {\n        assert numTerms > 0;\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        if (docsAndPositionsEnum != null) {\n          // has positions\n          positions = true;\n          if (docsAndPositionsEnum.attributes().hasAttribute(OffsetAttribute.class)) {\n            offsetAtt = docsAndPositionsEnum.attributes().getAttribute(OffsetAttribute.class);\n          } else {\n            offsetAtt = null;\n          }\n        } else {\n          positions = false;\n          offsetAtt = null;\n        }\n      } else {\n        // no terms in this field (hmm why is field present\n        // then...?)\n        assert numTerms == 0;\n        positions = false;\n        offsetAtt = null;\n      }\n      \n      startField(fieldInfo, numTerms, positions, offsetAtt != null);\n\n      int termCount = 1;\n\n      // NOTE: we already .next()'d the TermsEnum above, to\n      // peek @ first term to see if positions/offsets are\n      // present\n      while(true) {\n        final int freq = (int) termsEnum.totalTermFreq();\n        startTerm(termsEnum.term(), freq);\n\n        if (positions || offsetAtt != null) {\n          DocsAndPositionsEnum dp = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          // TODO: add startOffset()/endOffset() to d&pEnum... this is insanity\n          if (dp != docsAndPositionsEnum) {\n            // producer didnt reuse, must re-pull attributes\n            if (offsetAtt != null) {\n              assert dp.attributes().hasAttribute(OffsetAttribute.class);\n              offsetAtt = dp.attributes().getAttribute(OffsetAttribute.class);\n            }\n          }\n          docsAndPositionsEnum = dp;\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = offsetAtt == null ? -1 : offsetAtt.startOffset();\n            final int endOffset = offsetAtt == null ? -1 : offsetAtt.endOffset();\n            \n            addPosition(pos, startOffset, endOffset);\n          }\n        }\n        \n        if (termsEnum.next() == null) {\n          assert termCount == numTerms;\n          break;\n        }\n        termCount++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      \n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n\n      final boolean positions;\n\n      OffsetAttribute offsetAtt;\n\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      if (termsEnum.next() != null) {\n        assert numTerms > 0;\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        if (docsAndPositionsEnum != null) {\n          // has positions\n          positions = true;\n          if (docsAndPositionsEnum.attributes().hasAttribute(OffsetAttribute.class)) {\n            offsetAtt = docsAndPositionsEnum.attributes().getAttribute(OffsetAttribute.class);\n          } else {\n            offsetAtt = null;\n          }\n        } else {\n          positions = false;\n          offsetAtt = null;\n        }\n      } else {\n        // no terms in this field (hmm why is field present\n        // then...?)\n        assert numTerms == 0;\n        positions = false;\n        offsetAtt = null;\n      }\n      \n      startField(fieldInfo, numTerms, positions, offsetAtt != null);\n\n      int termCount = 1;\n\n      // NOTE: we already .next()'d the TermsEnum above, to\n      // peek @ first term to see if positions/offsets are\n      // present\n      while(true) {\n        final int freq = (int) termsEnum.totalTermFreq();\n        startTerm(termsEnum.term(), freq);\n\n        if (positions || offsetAtt != null) {\n          DocsAndPositionsEnum dp = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          // TODO: add startOffset()/endOffset() to d&pEnum... this is insanity\n          if (dp != docsAndPositionsEnum) {\n            // producer didnt reuse, must re-pull attributes\n            if (offsetAtt != null) {\n              assert dp.attributes().hasAttribute(OffsetAttribute.class);\n              offsetAtt = dp.attributes().getAttribute(OffsetAttribute.class);\n            }\n          }\n          docsAndPositionsEnum = dp;\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = offsetAtt == null ? -1 : offsetAtt.startOffset();\n            final int endOffset = offsetAtt == null ? -1 : offsetAtt.endOffset();\n            \n            addPosition(pos, startOffset, endOffset);\n          }\n        }\n        \n        if (termsEnum.next() == null) {\n          assert termCount == numTerms;\n          break;\n        }\n        termCount++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31f025ae60076ae95274433f3fe8e6ace2857a87","date":1326669465,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      \n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n\n      final boolean positions;\n\n      OffsetAttribute offsetAtt;\n\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      if (termsEnum.next() != null) {\n        assert numTerms > 0;\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        if (docsAndPositionsEnum != null) {\n          // has positions\n          positions = true;\n          if (docsAndPositionsEnum.attributes().hasAttribute(OffsetAttribute.class)) {\n            offsetAtt = docsAndPositionsEnum.attributes().getAttribute(OffsetAttribute.class);\n          } else {\n            offsetAtt = null;\n          }\n        } else {\n          positions = false;\n          offsetAtt = null;\n        }\n      } else {\n        // no terms in this field (hmm why is field present\n        // then...?)\n        assert numTerms == 0;\n        positions = false;\n        offsetAtt = null;\n      }\n      \n      startField(fieldInfo, numTerms, positions, offsetAtt != null);\n\n      int termCount = 1;\n\n      // NOTE: we already .next()'d the TermsEnum above, to\n      // peek @ first term to see if positions/offsets are\n      // present\n      while(true) {\n        final int freq = (int) termsEnum.totalTermFreq();\n        startTerm(termsEnum.term(), freq);\n\n        if (positions || offsetAtt != null) {\n          DocsAndPositionsEnum dp = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          // TODO: add startOffset()/endOffset() to d&pEnum... this is insanity\n          if (dp != docsAndPositionsEnum) {\n            // producer didnt reuse, must re-pull attributes\n            if (offsetAtt != null) {\n              assert dp.attributes().hasAttribute(OffsetAttribute.class);\n              offsetAtt = dp.attributes().getAttribute(OffsetAttribute.class);\n            }\n          }\n          docsAndPositionsEnum = dp;\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = offsetAtt == null ? -1 : offsetAtt.startOffset();\n            final int endOffset = offsetAtt == null ? -1 : offsetAtt.endOffset();\n            \n            addPosition(pos, startOffset, endOffset);\n          }\n        }\n        \n        if (termsEnum.next() == null) {\n          assert termCount == numTerms;\n          break;\n        }\n        termCount++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc","5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["31f025ae60076ae95274433f3fe8e6ace2857a87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"31f025ae60076ae95274433f3fe8e6ace2857a87":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["31f025ae60076ae95274433f3fe8e6ace2857a87"],"31f025ae60076ae95274433f3fe8e6ace2857a87":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}