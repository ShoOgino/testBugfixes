{"path":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","commits":[{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":1,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readSchema(SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( SolrCore core, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)Config.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      final XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)Config.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7","date":1189312484,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","sourceNew":"  private void readSchema(final SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( Config config, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)solrConfig.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readSchema(SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( SolrCore core, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)Config.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"66ab3886c1d845c59c9e5b23b2fb247b927db498","date":1193060587,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","sourceNew":"  private void readSchema(final SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( Config config, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)solrConfig.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readSchema(final SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( Config config, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)solrConfig.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fcf52a7da226d8d3756cc8bf9f3ae1f39952b014","date":1195912306,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","sourceNew":"  private void readSchema(final SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readSchema(final SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( Config config, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)solrConfig.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d76cc03e194de1d38d6103ec919c69c6afb4a368","date":1197110551,"type":5,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","sourceNew":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readSchema(final SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( solrConfig.getResourceLoader(), nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.getResourceLoader().newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d76cc03e194de1d38d6103ec919c69c6afb4a368":["fcf52a7da226d8d3756cc8bf9f3ae1f39952b014"],"6d6338c87060be5f66757a94945975f3bbd377a9":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"fcf52a7da226d8d3756cc8bf9f3ae1f39952b014":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7":["6d6338c87060be5f66757a94945975f3bbd377a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"d76cc03e194de1d38d6103ec919c69c6afb4a368":[],"6d6338c87060be5f66757a94945975f3bbd377a9":["94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["fcf52a7da226d8d3756cc8bf9f3ae1f39952b014"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["6d6338c87060be5f66757a94945975f3bbd377a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fcf52a7da226d8d3756cc8bf9f3ae1f39952b014":["d76cc03e194de1d38d6103ec919c69c6afb4a368"],"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d76cc03e194de1d38d6103ec919c69c6afb4a368","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}