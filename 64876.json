{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","commits":[{"id":"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76","date":1406617066,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happens during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            // suppress exceptions, it's just a best effort\n            IOUtils.deleteFilesIgnoringExceptions(dir, file);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            // suppress exceptions, it's just a best effort\n            IOUtils.deleteFilesIgnoringExceptions(dir, file);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            // suppress exceptions, it's just a best effort\n            IOUtils.deleteFilesIgnoringExceptions(dir, file);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","date":1571071547,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>(commit.getFileNames());\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            // suppress exceptions, it's just a best effort\n            IOUtils.deleteFilesIgnoringExceptions(dir, file);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            // suppress exceptions, it's just a best effort\n            IOUtils.deleteFilesIgnoringExceptions(dir, file);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>(commit.getFileNames());\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            // suppress exceptions, it's just a best effort\n            IOUtils.deleteFilesIgnoringExceptions(dir, file);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            // suppress exceptions, it's just a best effort\n            IOUtils.deleteFilesIgnoringExceptions(dir, file);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"],"b0b597c65628ca9e73913a07e81691f8229bae35":["46e4a8bdfbafda795ef9c39a2bc2d47095770299","23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"]},"commit2Childs":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","b0b597c65628ca9e73913a07e81691f8229bae35"],"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}