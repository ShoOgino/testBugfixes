{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","commits":[{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#read(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      // 4.0+\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_40, VERSION_50);\n      // 5.0+\n      byte id[] = null;\n      if (format >= VERSION_50) {\n        id = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(id, 0, id.length);\n        CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      }\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        if (format >= VERSION_50) {\n          byte hasID = input.readByte();\n          if (hasID == 1) {\n            segmentID = new byte[StringHelper.ID_LENGTH];\n            input.readBytes(segmentID, 0, segmentID.length);\n          } else if (hasID == 0) {\n            segmentID = null; // 4.x segment, doesn't have an ID\n          } else {\n            throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n          }\n        } else {\n          segmentID = null;\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = -1;\n        if (format >= VERSION_46) {\n          fieldInfosGen = input.readLong();\n        }\n        long dvGen = -1;\n        if (format >= VERSION_49) {\n          dvGen = input.readLong();\n        } else {\n          dvGen = fieldInfosGen;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_46) {\n          if (format < VERSION_49) {\n            // Recorded per-generation files, which were buggy (see\n            // LUCENE-5636). We need to read and keep them so we continue to\n            // reference those files. Unfortunately it means that the files will\n            // be referenced even if the fields are updated again, until the\n            // segment is merged.\n            final int numGensUpdatesFiles = input.readInt();\n            final Map<Long,Set<String>> genUpdatesFiles;\n            if (numGensUpdatesFiles == 0) {\n              genUpdatesFiles = Collections.emptyMap();\n            } else {\n              genUpdatesFiles = new HashMap<>(numGensUpdatesFiles);\n              for (int i = 0; i < numGensUpdatesFiles; i++) {\n                genUpdatesFiles.put(input.readLong(), input.readStringSet());\n              }\n            }\n            siPerCommit.setGenUpdatesFiles(genUpdatesFiles);\n          } else {\n            siPerCommit.setFieldInfosFiles(input.readStringSet());\n            final Map<Integer,Set<String>> dvUpdateFiles;\n            final int numDVFields = input.readInt();\n            if (numDVFields == 0) {\n              dvUpdateFiles = Collections.emptyMap();\n            } else {\n              dvUpdateFiles = new HashMap<>(numDVFields);\n              for (int i = 0; i < numDVFields; i++) {\n                dvUpdateFiles.put(input.readInt(), input.readStringSet());\n              }\n            }\n            siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n          }\n        }\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      if (format >= VERSION_48) {\n        CodecUtil.checkFooter(input);\n      } else {\n        final long checksumNow = input.getChecksum();\n        final long checksumThen = input.readLong();\n        if (checksumNow != checksumThen) {\n          throw new CorruptIndexException(\"checksum failed (hardware problem?) : expected=\" + Long.toHexString(checksumThen) +  \n                                          \" actual=\" + Long.toHexString(checksumNow), input);\n        }\n        CodecUtil.checkEOF(input);\n      }\n\n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public final void read(Directory directory, String segmentFileName) throws IOException {\n    boolean success = false;\n\n    // Clear any previous segments:\n    this.clear();\n\n    generation = generationFromSegmentsFileName(segmentFileName);\n\n    lastGeneration = generation;\n\n    ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ);\n    try {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      // 4.0+\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_40, VERSION_50);\n      version = input.readLong();\n      counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        Codec codec = Codec.forName(input.readString());\n        //System.out.println(\"SIS.read seg=\" + seg + \" codec=\" + codec);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, IOContext.READ);\n        info.setCodec(codec);\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = -1;\n        if (format >= VERSION_46) {\n          fieldInfosGen = input.readLong();\n        }\n        long dvGen = -1;\n        if (format >= VERSION_49) {\n          dvGen = input.readLong();\n        } else {\n          dvGen = fieldInfosGen;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_46) {\n          if (format < VERSION_49) {\n            // Recorded per-generation files, which were buggy (see\n            // LUCENE-5636). We need to read and keep them so we continue to\n            // reference those files. Unfortunately it means that the files will\n            // be referenced even if the fields are updated again, until the\n            // segment is merged.\n            final int numGensUpdatesFiles = input.readInt();\n            final Map<Long,Set<String>> genUpdatesFiles;\n            if (numGensUpdatesFiles == 0) {\n              genUpdatesFiles = Collections.emptyMap();\n            } else {\n              genUpdatesFiles = new HashMap<>(numGensUpdatesFiles);\n              for (int i = 0; i < numGensUpdatesFiles; i++) {\n                genUpdatesFiles.put(input.readLong(), input.readStringSet());\n              }\n            }\n            siPerCommit.setGenUpdatesFiles(genUpdatesFiles);\n          } else {\n            siPerCommit.setFieldInfosFiles(input.readStringSet());\n            final Map<Integer,Set<String>> dvUpdateFiles;\n            final int numDVFields = input.readInt();\n            if (numDVFields == 0) {\n              dvUpdateFiles = Collections.emptyMap();\n            } else {\n              dvUpdateFiles = new HashMap<>(numDVFields);\n              for (int i = 0; i < numDVFields; i++) {\n                dvUpdateFiles.put(input.readInt(), input.readStringSet());\n              }\n            }\n            siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n          }\n        }\n        add(siPerCommit);\n      }\n      userData = input.readStringStringMap();\n      if (format >= VERSION_50) {\n        id = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(id, 0, id.length);\n      }\n\n      if (format >= VERSION_48) {\n        CodecUtil.checkFooter(input);\n      } else {\n        final long checksumNow = input.getChecksum();\n        final long checksumThen = input.readLong();\n        if (checksumNow != checksumThen) {\n          throw new CorruptIndexException(\"checksum failed (hardware problem?) : expected=\" + Long.toHexString(checksumThen) +  \n                                          \" actual=\" + Long.toHexString(checksumNow), input);\n        }\n        CodecUtil.checkEOF(input);\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Clear any segment infos we had loaded so we\n        // have a clean slate on retry:\n        this.clear();\n        IOUtils.closeWhileHandlingException(input);\n      } else {\n        input.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#read(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      // 4.0+\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_40, VERSION_50);\n      // 5.0+\n      byte id[] = null;\n      if (format >= VERSION_50) {\n        id = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(id, 0, id.length);\n        CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      }\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        if (format >= VERSION_50) {\n          byte hasID = input.readByte();\n          if (hasID == 1) {\n            segmentID = new byte[StringHelper.ID_LENGTH];\n            input.readBytes(segmentID, 0, segmentID.length);\n          } else if (hasID == 0) {\n            segmentID = null; // 4.x segment, doesn't have an ID\n          } else {\n            throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n          }\n        } else {\n          segmentID = null;\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = -1;\n        if (format >= VERSION_46) {\n          fieldInfosGen = input.readLong();\n        }\n        long dvGen = -1;\n        if (format >= VERSION_49) {\n          dvGen = input.readLong();\n        } else {\n          dvGen = fieldInfosGen;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_46) {\n          if (format < VERSION_49) {\n            // Recorded per-generation files, which were buggy (see\n            // LUCENE-5636). We need to read and keep them so we continue to\n            // reference those files. Unfortunately it means that the files will\n            // be referenced even if the fields are updated again, until the\n            // segment is merged.\n            final int numGensUpdatesFiles = input.readInt();\n            final Map<Long,Set<String>> genUpdatesFiles;\n            if (numGensUpdatesFiles == 0) {\n              genUpdatesFiles = Collections.emptyMap();\n            } else {\n              genUpdatesFiles = new HashMap<>(numGensUpdatesFiles);\n              for (int i = 0; i < numGensUpdatesFiles; i++) {\n                genUpdatesFiles.put(input.readLong(), input.readStringSet());\n              }\n            }\n            siPerCommit.setGenUpdatesFiles(genUpdatesFiles);\n          } else {\n            siPerCommit.setFieldInfosFiles(input.readStringSet());\n            final Map<Integer,Set<String>> dvUpdateFiles;\n            final int numDVFields = input.readInt();\n            if (numDVFields == 0) {\n              dvUpdateFiles = Collections.emptyMap();\n            } else {\n              dvUpdateFiles = new HashMap<>(numDVFields);\n              for (int i = 0; i < numDVFields; i++) {\n                dvUpdateFiles.put(input.readInt(), input.readStringSet());\n              }\n            }\n            siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n          }\n        }\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      if (format >= VERSION_48) {\n        CodecUtil.checkFooter(input);\n      } else {\n        final long checksumNow = input.getChecksum();\n        final long checksumThen = input.readLong();\n        if (checksumNow != checksumThen) {\n          throw new CorruptIndexException(\"checksum failed (hardware problem?) : expected=\" + Long.toHexString(checksumThen) +  \n                                          \" actual=\" + Long.toHexString(checksumNow), input);\n        }\n        CodecUtil.checkEOF(input);\n      }\n\n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public final void read(Directory directory, String segmentFileName) throws IOException {\n    boolean success = false;\n\n    // Clear any previous segments:\n    this.clear();\n\n    generation = generationFromSegmentsFileName(segmentFileName);\n\n    lastGeneration = generation;\n\n    ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ);\n    try {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      // 4.0+\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_40, VERSION_50);\n      version = input.readLong();\n      counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        Codec codec = Codec.forName(input.readString());\n        //System.out.println(\"SIS.read seg=\" + seg + \" codec=\" + codec);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, IOContext.READ);\n        info.setCodec(codec);\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = -1;\n        if (format >= VERSION_46) {\n          fieldInfosGen = input.readLong();\n        }\n        long dvGen = -1;\n        if (format >= VERSION_49) {\n          dvGen = input.readLong();\n        } else {\n          dvGen = fieldInfosGen;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_46) {\n          if (format < VERSION_49) {\n            // Recorded per-generation files, which were buggy (see\n            // LUCENE-5636). We need to read and keep them so we continue to\n            // reference those files. Unfortunately it means that the files will\n            // be referenced even if the fields are updated again, until the\n            // segment is merged.\n            final int numGensUpdatesFiles = input.readInt();\n            final Map<Long,Set<String>> genUpdatesFiles;\n            if (numGensUpdatesFiles == 0) {\n              genUpdatesFiles = Collections.emptyMap();\n            } else {\n              genUpdatesFiles = new HashMap<>(numGensUpdatesFiles);\n              for (int i = 0; i < numGensUpdatesFiles; i++) {\n                genUpdatesFiles.put(input.readLong(), input.readStringSet());\n              }\n            }\n            siPerCommit.setGenUpdatesFiles(genUpdatesFiles);\n          } else {\n            siPerCommit.setFieldInfosFiles(input.readStringSet());\n            final Map<Integer,Set<String>> dvUpdateFiles;\n            final int numDVFields = input.readInt();\n            if (numDVFields == 0) {\n              dvUpdateFiles = Collections.emptyMap();\n            } else {\n              dvUpdateFiles = new HashMap<>(numDVFields);\n              for (int i = 0; i < numDVFields; i++) {\n                dvUpdateFiles.put(input.readInt(), input.readStringSet());\n              }\n            }\n            siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n          }\n        }\n        add(siPerCommit);\n      }\n      userData = input.readStringStringMap();\n      if (format >= VERSION_50) {\n        id = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(id, 0, id.length);\n      }\n\n      if (format >= VERSION_48) {\n        CodecUtil.checkFooter(input);\n      } else {\n        final long checksumNow = input.getChecksum();\n        final long checksumThen = input.readLong();\n        if (checksumNow != checksumThen) {\n          throw new CorruptIndexException(\"checksum failed (hardware problem?) : expected=\" + Long.toHexString(checksumThen) +  \n                                          \" actual=\" + Long.toHexString(checksumNow), input);\n        }\n        CodecUtil.checkEOF(input);\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Clear any segment infos we had loaded so we\n        // have a clean slate on retry:\n        this.clear();\n        IOUtils.closeWhileHandlingException(input);\n      } else {\n        input.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71387d8cb6923eb831b17a8b734608ba2e21c653","date":1414126093,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_50);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        siPerCommit.setFieldInfosFiles(input.readStringSet());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          dvUpdateFiles = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            dvUpdateFiles.put(input.readInt(), input.readStringSet());\n          }\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      CodecUtil.checkFooter(input);\n\n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      // 4.0+\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_40, VERSION_50);\n      // 5.0+\n      byte id[] = null;\n      if (format >= VERSION_50) {\n        id = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(id, 0, id.length);\n        CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      }\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        if (format >= VERSION_50) {\n          byte hasID = input.readByte();\n          if (hasID == 1) {\n            segmentID = new byte[StringHelper.ID_LENGTH];\n            input.readBytes(segmentID, 0, segmentID.length);\n          } else if (hasID == 0) {\n            segmentID = null; // 4.x segment, doesn't have an ID\n          } else {\n            throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n          }\n        } else {\n          segmentID = null;\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = -1;\n        if (format >= VERSION_46) {\n          fieldInfosGen = input.readLong();\n        }\n        long dvGen = -1;\n        if (format >= VERSION_49) {\n          dvGen = input.readLong();\n        } else {\n          dvGen = fieldInfosGen;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_46) {\n          if (format < VERSION_49) {\n            // Recorded per-generation files, which were buggy (see\n            // LUCENE-5636). We need to read and keep them so we continue to\n            // reference those files. Unfortunately it means that the files will\n            // be referenced even if the fields are updated again, until the\n            // segment is merged.\n            final int numGensUpdatesFiles = input.readInt();\n            final Map<Long,Set<String>> genUpdatesFiles;\n            if (numGensUpdatesFiles == 0) {\n              genUpdatesFiles = Collections.emptyMap();\n            } else {\n              genUpdatesFiles = new HashMap<>(numGensUpdatesFiles);\n              for (int i = 0; i < numGensUpdatesFiles; i++) {\n                genUpdatesFiles.put(input.readLong(), input.readStringSet());\n              }\n            }\n            siPerCommit.setGenUpdatesFiles(genUpdatesFiles);\n          } else {\n            siPerCommit.setFieldInfosFiles(input.readStringSet());\n            final Map<Integer,Set<String>> dvUpdateFiles;\n            final int numDVFields = input.readInt();\n            if (numDVFields == 0) {\n              dvUpdateFiles = Collections.emptyMap();\n            } else {\n              dvUpdateFiles = new HashMap<>(numDVFields);\n              for (int i = 0; i < numDVFields; i++) {\n                dvUpdateFiles.put(input.readInt(), input.readStringSet());\n              }\n            }\n            siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n          }\n        }\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      if (format >= VERSION_48) {\n        CodecUtil.checkFooter(input);\n      } else {\n        final long checksumNow = input.getChecksum();\n        final long checksumThen = input.readLong();\n        if (checksumNow != checksumThen) {\n          throw new CorruptIndexException(\"checksum failed (hardware problem?) : expected=\" + Long.toHexString(checksumThen) +  \n                                          \" actual=\" + Long.toHexString(checksumNow), input);\n        }\n        CodecUtil.checkEOF(input);\n      }\n\n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98b44240f64a2d6935543ff25faee750b29204eb","date":1424972040,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_50);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.getDocCount();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        siPerCommit.setFieldInfosFiles(input.readStringSet());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          dvUpdateFiles = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            dvUpdateFiles.put(input.readInt(), input.readStringSet());\n          }\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_50);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        siPerCommit.setFieldInfosFiles(input.readStringSet());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          dvUpdateFiles = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            dvUpdateFiles.put(input.readInt(), input.readStringSet());\n          }\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      CodecUtil.checkFooter(input);\n\n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98a04f56464afdffd4c430d6c47a0c868a38354e","date":1424985833,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_50);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.getDocCount();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        siPerCommit.setFieldInfosFiles(input.readStringSet());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          dvUpdateFiles = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            dvUpdateFiles.put(input.readInt(), input.readStringSet());\n          }\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_50);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        siPerCommit.setFieldInfosFiles(input.readStringSet());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          dvUpdateFiles = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            dvUpdateFiles.put(input.readInt(), input.readStringSet());\n          }\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      CodecUtil.checkFooter(input);\n\n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79700663e164dece87bed4adfd3e28bab6cb1385","date":1425241849,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.getDocCount();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_50);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.getDocCount();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        siPerCommit.setFieldInfosFiles(input.readStringSet());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          dvUpdateFiles = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            dvUpdateFiles.put(input.readInt(), input.readStringSet());\n          }\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"299a2348fa24151d150182211b6208a38e5e3450","date":1425304608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.getDocCount();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_50);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.getDocCount();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        siPerCommit.setFieldInfosFiles(input.readStringSet());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          dvUpdateFiles = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            dvUpdateFiles.put(input.readInt(), input.readStringSet());\n          }\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.getDocCount();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.getDocCount();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_50);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.getDocCount()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs docCount=\" + info.getDocCount(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        siPerCommit.setFieldInfosFiles(input.readStringSet());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          dvUpdateFiles = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            dvUpdateFiles.put(input.readInt(), input.readStringSet());\n          }\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      infos.userData = input.readStringStringMap();\n\n      CodecUtil.checkFooter(input);\n\n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"945146c7fd6d18148836dae96cbac42c5c809cdf","date":1430264780,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else if (hasID == 0) {\n          throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = readCodec(input);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n      \n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = Codec.forName(input.readString());\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n      \n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":["8f3189d15ef66702bbb45771403a68793d5cd137"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"66ca3a68615d97a902dbef4b4656b13b63aea249","date":1430267010,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else if (hasID == 0) {\n          throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = readCodec(input);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else if (hasID == 0) {\n          throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = readCodec(input);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f3189d15ef66702bbb45771403a68793d5cd137","date":1433872507,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      if (format >= VERSION_53) {\n        // TODO: in the future (7.0?  sigh) we can use this to throw IndexFormatTooOldException ... or just rely on the\n        // minSegmentLuceneVersion check instead:\n        infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      } else {\n        // else compute the min version down below in the for loop\n      }\n\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n\n      if (format >= VERSION_53) {\n        if (numSegments > 0) {\n          infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n          if (infos.minSegmentLuceneVersion.onOrAfter(Version.LUCENE_5_0_0) == false) {\n            throw new IndexFormatTooOldException(input, \"this index contains a too-old segment (version: \" + infos.minSegmentLuceneVersion + \")\");\n          }\n        } else {\n          // else leave as null: no segments\n        }\n      } else {\n        // else we recompute it below as we visit segments; it can't be used for throwing IndexFormatTooOldExc, but consumers of\n        // SegmentInfos can maybe still use it for other reasons\n      }\n\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else if (hasID == 0) {\n          throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = readCodec(input, format < VERSION_53);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n\n        Version segmentVersion = info.getVersion();\n        if (format < VERSION_53) {\n          if (infos.minSegmentLuceneVersion == null || segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n            infos.minSegmentLuceneVersion = segmentVersion;\n          }\n        } else if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n      }\n\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else if (hasID == 0) {\n          throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = readCodec(input);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n      }\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    }\n  }\n\n","bugFix":["945146c7fd6d18148836dae96cbac42c5c809cdf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    //System.out.println(Thread.currentThread() + \": SegmentInfos.readCommit \" + segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      return readCommit(directory, input, generation);\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      if (format >= VERSION_53) {\n        // TODO: in the future (7.0?  sigh) we can use this to throw IndexFormatTooOldException ... or just rely on the\n        // minSegmentLuceneVersion check instead:\n        infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      } else {\n        // else compute the min version down below in the for loop\n      }\n\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n\n      if (format >= VERSION_53) {\n        if (numSegments > 0) {\n          infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n          if (infos.minSegmentLuceneVersion.onOrAfter(Version.LUCENE_5_0_0) == false) {\n            throw new IndexFormatTooOldException(input, \"this index contains a too-old segment (version: \" + infos.minSegmentLuceneVersion + \")\");\n          }\n        } else {\n          // else leave as null: no segments\n        }\n      } else {\n        // else we recompute it below as we visit segments; it can't be used for throwing IndexFormatTooOldExc, but consumers of\n        // SegmentInfos can maybe still use it for other reasons\n      }\n\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else if (hasID == 0) {\n          throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = readCodec(input, format < VERSION_53);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n\n        Version segmentVersion = info.getVersion();\n        if (format < VERSION_53) {\n          if (infos.minSegmentLuceneVersion == null || segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n            infos.minSegmentLuceneVersion = segmentVersion;\n          }\n        } else if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n      }\n\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":["7f2e59b0a8dc96e3c0b9966b4a7f06ee6cddd2e6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    //System.out.println(Thread.currentThread() + \": SegmentInfos.readCommit \" + segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      return readCommit(directory, input, generation);\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      SegmentInfos infos = new SegmentInfos();\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      if (format >= VERSION_53) {\n        // TODO: in the future (7.0?  sigh) we can use this to throw IndexFormatTooOldException ... or just rely on the\n        // minSegmentLuceneVersion check instead:\n        infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      } else {\n        // else compute the min version down below in the for loop\n      }\n\n      infos.version = input.readLong();\n      infos.counter = input.readInt();\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n\n      if (format >= VERSION_53) {\n        if (numSegments > 0) {\n          infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n          if (infos.minSegmentLuceneVersion.onOrAfter(Version.LUCENE_5_0_0) == false) {\n            throw new IndexFormatTooOldException(input, \"this index contains a too-old segment (version: \" + infos.minSegmentLuceneVersion + \")\");\n          }\n        } else {\n          // else leave as null: no segments\n        }\n      } else {\n        // else we recompute it below as we visit segments; it can't be used for throwing IndexFormatTooOldExc, but consumers of\n        // SegmentInfos can maybe still use it for other reasons\n      }\n\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        final byte segmentID[];\n        byte hasID = input.readByte();\n        if (hasID == 1) {\n          segmentID = new byte[StringHelper.ID_LENGTH];\n          input.readBytes(segmentID, 0, segmentID.length);\n        } else if (hasID == 0) {\n          throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n        } else {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n        Codec codec = readCodec(input, format < VERSION_53);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n        if (format >= VERSION_51) {\n          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        } else {\n          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n        }\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            if (format >= VERSION_51) {\n              map.put(input.readInt(), input.readSetOfStrings());\n            } else {\n              map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n            }\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n\n        Version segmentVersion = info.getVersion();\n        if (format < VERSION_53) {\n          if (infos.minSegmentLuceneVersion == null || segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n            infos.minSegmentLuceneVersion = segmentVersion;\n          }\n        } else if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n      }\n\n      if (format >= VERSION_51) {\n        infos.userData = input.readMapOfStrings();\n      } else {\n        infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n      }\n\n      CodecUtil.checkFooter(input);\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f2e59b0a8dc96e3c0b9966b4a7f06ee6cddd2e6","date":1481756451,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    //System.out.println(Thread.currentThread() + \": SegmentInfos.readCommit \" + segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      try {\n        return readCommit(directory, input, generation);\n      } catch (EOFException e) {\n        throw new CorruptIndexException(\"Unexpected end of file while reading index.\", input, e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    //System.out.println(Thread.currentThread() + \": SegmentInfos.readCommit \" + segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      return readCommit(directory, input, generation);\n    }\n  }\n\n","bugFix":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    //System.out.println(Thread.currentThread() + \": SegmentInfos.readCommit \" + segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      try {\n        return readCommit(directory, input, generation);\n      } catch (EOFException e) {\n        throw new CorruptIndexException(\"Unexpected end of file while reading index.\", input, e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    //System.out.println(Thread.currentThread() + \": SegmentInfos.readCommit \" + segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      return readCommit(directory, input, generation);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"379ac53fe9f85e4560f02f2ff25f97eb7b5694a1","date":1486776053,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,String).mjava","sourceNew":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    //System.out.println(Thread.currentThread() + \": SegmentInfos.readCommit \" + segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      try {\n        return readCommit(directory, input, generation);\n      } catch (EOFException | NoSuchFileException | FileNotFoundException e) {\n        throw new CorruptIndexException(\"Unexpected file read error while reading index.\", input, e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Read a particular segmentFileName.  Note that this may\n   * throw an IOException if a commit is in process.\n   *\n   * @param directory -- directory containing the segments file\n   * @param segmentFileName -- segment file to load\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {\n\n    long generation = generationFromSegmentsFileName(segmentFileName);\n    //System.out.println(Thread.currentThread() + \": SegmentInfos.readCommit \" + segmentFileName);\n    try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {\n      try {\n        return readCommit(directory, input, generation);\n      } catch (EOFException e) {\n        throw new CorruptIndexException(\"Unexpected end of file while reading index.\", input, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"98a04f56464afdffd4c430d6c47a0c868a38354e":["71387d8cb6923eb831b17a8b734608ba2e21c653","98b44240f64a2d6935543ff25faee750b29204eb"],"945146c7fd6d18148836dae96cbac42c5c809cdf":["b0267c69e2456a3477a1ad785723f2135da3117e"],"b0267c69e2456a3477a1ad785723f2135da3117e":["79700663e164dece87bed4adfd3e28bab6cb1385"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7f2e59b0a8dc96e3c0b9966b4a7f06ee6cddd2e6":["68496c2200e559fb7802f7575427b7a482659afb"],"8f3189d15ef66702bbb45771403a68793d5cd137":["66ca3a68615d97a902dbef4b4656b13b63aea249"],"379ac53fe9f85e4560f02f2ff25f97eb7b5694a1":["7f2e59b0a8dc96e3c0b9966b4a7f06ee6cddd2e6"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["71387d8cb6923eb831b17a8b734608ba2e21c653","b0267c69e2456a3477a1ad785723f2135da3117e"],"b06445ae1731e049327712db0454e5643ca9b7fe":["299a2348fa24151d150182211b6208a38e5e3450","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"79700663e164dece87bed4adfd3e28bab6cb1385":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"68496c2200e559fb7802f7575427b7a482659afb":["8f3189d15ef66702bbb45771403a68793d5cd137","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3384e6013a93e4d11b7d75388693f8d0388602bf"],"9856095f7afb5a607bf5e65077615ed91273508c":["68496c2200e559fb7802f7575427b7a482659afb","7f2e59b0a8dc96e3c0b9966b4a7f06ee6cddd2e6"],"66ca3a68615d97a902dbef4b4656b13b63aea249":["945146c7fd6d18148836dae96cbac42c5c809cdf"],"98b44240f64a2d6935543ff25faee750b29204eb":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"299a2348fa24151d150182211b6208a38e5e3450":["98a04f56464afdffd4c430d6c47a0c868a38354e","79700663e164dece87bed4adfd3e28bab6cb1385"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["379ac53fe9f85e4560f02f2ff25f97eb7b5694a1"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["8f3189d15ef66702bbb45771403a68793d5cd137"]},"commit2Childs":{"98a04f56464afdffd4c430d6c47a0c868a38354e":["79700663e164dece87bed4adfd3e28bab6cb1385","299a2348fa24151d150182211b6208a38e5e3450"],"945146c7fd6d18148836dae96cbac42c5c809cdf":["66ca3a68615d97a902dbef4b4656b13b63aea249"],"b0267c69e2456a3477a1ad785723f2135da3117e":["945146c7fd6d18148836dae96cbac42c5c809cdf","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"7f2e59b0a8dc96e3c0b9966b4a7f06ee6cddd2e6":["379ac53fe9f85e4560f02f2ff25f97eb7b5694a1","9856095f7afb5a607bf5e65077615ed91273508c"],"8f3189d15ef66702bbb45771403a68793d5cd137":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["98a04f56464afdffd4c430d6c47a0c868a38354e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","98b44240f64a2d6935543ff25faee750b29204eb"],"379ac53fe9f85e4560f02f2ff25f97eb7b5694a1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3384e6013a93e4d11b7d75388693f8d0388602bf","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"79700663e164dece87bed4adfd3e28bab6cb1385":["b0267c69e2456a3477a1ad785723f2135da3117e","299a2348fa24151d150182211b6208a38e5e3450"],"68496c2200e559fb7802f7575427b7a482659afb":["7f2e59b0a8dc96e3c0b9966b4a7f06ee6cddd2e6","9856095f7afb5a607bf5e65077615ed91273508c"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"66ca3a68615d97a902dbef4b4656b13b63aea249":["8f3189d15ef66702bbb45771403a68793d5cd137"],"98b44240f64a2d6935543ff25faee750b29204eb":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"299a2348fa24151d150182211b6208a38e5e3450":["b06445ae1731e049327712db0454e5643ca9b7fe"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}