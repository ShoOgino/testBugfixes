{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","commits":[{"id":"6e9ca12badc371399673a8a074cb281a72f34049","date":1395419500,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          boolean maybeFail = false;\n          StackTraceElement[] trace = new Exception().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail && random().nextInt(10) == 0) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(TEST_VERSION_CURRENT, null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw, false);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      assertFalse(IndexWriter.isLocked(dir));\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","sourceNew":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          boolean maybeFail = false;\n          StackTraceElement[] trace = new Exception().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail && random().nextInt(10) == 0) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw, false);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      assertFalse(IndexWriter.isLocked(dir));\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          boolean maybeFail = false;\n          StackTraceElement[] trace = new Exception().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail && random().nextInt(10) == 0) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(TEST_VERSION_CURRENT, null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw, false);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      assertFalse(IndexWriter.isLocked(dir));\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ae6725e6ae382af525653dca26303eb0661c71f","date":1417051373,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","sourceNew":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          boolean maybeFail = false;\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw, false);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      assertFalse(IndexWriter.isLocked(dir));\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          boolean maybeFail = false;\n          StackTraceElement[] trace = new Exception().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail && random().nextInt(10) == 0) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw, false);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      assertFalse(IndexWriter.isLocked(dir));\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","sourceNew":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          boolean maybeFail = false;\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw, false);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          boolean maybeFail = false;\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw, false);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      assertFalse(IndexWriter.isLocked(dir));\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a1862266772deb28cdcb7d996b64d2177022687","date":1453077824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","sourceNew":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          boolean maybeFail = false;\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          boolean maybeFail = false;\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw, false);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05fe562aa248790944d43cdd478f512572835ba0","date":1455901667,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","sourceNew":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          boolean maybeFail = false;\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n        // ok, we randomly hit exc here\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          boolean maybeFail = false;\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2916966cc9815e973c01452a0d76c98c5e0d0926","date":1577444040,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","sourceNew":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (callStackContainsAnyOf(\"rollbackInternal\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n        // ok, we randomly hit exc here\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          boolean maybeFail = false;\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n        // ok, we randomly hit exc here\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ec73c5617c177b1d81ddfe04bbff1d08fccecc","date":1577456244,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testRandomExceptionDuringRollback().mjava","sourceNew":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (callStackContainsAnyOf(\"rollbackInternal\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n        // ok, we randomly hit exc here\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomExceptionDuringRollback() throws Exception {\n    // fail in random places on i/o\n    final int numIters = RANDOM_MULTIPLIER * 75;\n    for (int iter = 0; iter < numIters; iter++) {\n      MockDirectoryWrapper dir = newMockDirectory();\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          boolean maybeFail = false;\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"rollbackInternal\".equals(trace[i].getMethodName())) {\n              maybeFail = true;\n              break;\n            }\n          }\n          \n          if (maybeFail) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            throw new FakeIOException();\n          }\n        }\n      });\n      \n      IndexWriterConfig iwc = new IndexWriterConfig(null);\n      IndexWriter iw = new IndexWriter(dir, iwc);\n      Document doc = new Document();\n      for (int i = 0; i < 10; i++) {\n        iw.addDocument(doc);\n      }\n      iw.commit();\n      \n      iw.addDocument(doc);\n      \n      // pool readers\n      DirectoryReader r = DirectoryReader.open(iw);\n      \n      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n      if (random().nextBoolean()) {\n        iw.prepareCommit();\n      }\n      \n      try {\n        iw.rollback();\n      } catch (FakeIOException expected) {\n        // ok, we randomly hit exc here\n      }\n      \n      r.close();\n      \n      // even though we hit exception: we are closed, no locks or files held, index in good state\n      assertTrue(iw.isClosed());\n      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n      \n      r = DirectoryReader.open(dir);\n      assertEquals(10, r.maxDoc());\n      r.close();\n      \n      // no leaks\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"618635065f043788c9e034f96ca5cd5cea1b4592":["9ae6725e6ae382af525653dca26303eb0661c71f"],"2a1862266772deb28cdcb7d996b64d2177022687":["618635065f043788c9e034f96ca5cd5cea1b4592"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"05fe562aa248790944d43cdd478f512572835ba0":["2a1862266772deb28cdcb7d996b64d2177022687"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["6e9ca12badc371399673a8a074cb281a72f34049"],"6e9ca12badc371399673a8a074cb281a72f34049":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9ae6725e6ae382af525653dca26303eb0661c71f":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"2916966cc9815e973c01452a0d76c98c5e0d0926":["05fe562aa248790944d43cdd478f512572835ba0"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":["05fe562aa248790944d43cdd478f512572835ba0","2916966cc9815e973c01452a0d76c98c5e0d0926"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2916966cc9815e973c01452a0d76c98c5e0d0926"]},"commit2Childs":{"618635065f043788c9e034f96ca5cd5cea1b4592":["2a1862266772deb28cdcb7d996b64d2177022687"],"2a1862266772deb28cdcb7d996b64d2177022687":["05fe562aa248790944d43cdd478f512572835ba0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e9ca12badc371399673a8a074cb281a72f34049"],"05fe562aa248790944d43cdd478f512572835ba0":["2916966cc9815e973c01452a0d76c98c5e0d0926","94ec73c5617c177b1d81ddfe04bbff1d08fccecc"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["9ae6725e6ae382af525653dca26303eb0661c71f"],"6e9ca12badc371399673a8a074cb281a72f34049":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"9ae6725e6ae382af525653dca26303eb0661c71f":["618635065f043788c9e034f96ca5cd5cea1b4592"],"2916966cc9815e973c01452a0d76c98c5e0d0926":["94ec73c5617c177b1d81ddfe04bbff1d08fccecc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["94ec73c5617c177b1d81ddfe04bbff1d08fccecc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}