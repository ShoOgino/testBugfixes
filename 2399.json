{"path":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doDrillDownAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","commits":[{"id":"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd","date":1361836936,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doDrillDownAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Used when drill downs are highly constraining vs\n   *  baseQuery. */\n  private void doDrillDownAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    //if (DEBUG) {\n    //  System.out.println(\"  doDrillDownAdvanceScoring\");\n    //}\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n    int nextChunkStart = CHUNK;\n\n    final FixedBitSet seen = new FixedBitSet(CHUNK);\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n\n      // First dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim0\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[0]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        int docID = docsEnum.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            seen.set(slot);\n            // Mark slot as valid:\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 1;\n            counts[slot] = 1;\n          }\n\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      // Second dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim1\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[1]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        int docID = docsEnum.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            // Mark slot as valid:\n            seen.set(slot);\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" missingDim=0 id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 0;\n            counts[slot] = 1;\n          } else {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= 1) {\n              missingDims[slot] = 2;\n              counts[slot] = 2;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=2 id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            } else {\n              counts[slot] = 1;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=\" + missingDims[slot] + \" id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            }\n          }\n\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      // After this we can \"upgrade\" to conjunction, because\n      // any doc not seen by either dim 0 or dim 1 cannot be\n      // a hit or a near miss:\n\n      //if (DEBUG) {\n      //  System.out.println(\"  baseScorer\");\n      //}\n\n      // Fold in baseScorer, using advance:\n      int filledCount = 0;\n      int slot0 = 0;\n      while (slot0 < CHUNK && (slot0 = seen.nextSetBit(slot0)) != -1) {\n        int ddDocID = docIDs[slot0];\n        assert ddDocID != -1;\n\n        int baseDocID = baseScorer.docID();\n        if (baseDocID < ddDocID) {\n          baseDocID = baseScorer.advance(ddDocID);\n        }\n        if (baseDocID == ddDocID) {\n          //if (DEBUG) {\n          //  System.out.println(\"    keep docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          scores[slot0] = baseScorer.score();\n          filledSlots[filledCount++] = slot0;\n          counts[slot0]++;\n        } else {\n          //if (DEBUG) {\n          //  System.out.println(\"    no docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          docIDs[slot0] = -1;\n\n          // TODO: we could jump slot0 forward to the\n          // baseDocID ... but we'd need to set docIDs for\n          // intervening slots to -1\n        }\n        slot0++;\n      }\n      seen.clear(0, CHUNK);\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n      \n      // TODO: factor this out & share w/ union scorer,\n      // except we start from dim=2 instead:\n      for(int dim=2;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          int docID = docsEnum.docID();\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            // TODO: sometimes use advance?\n            docID = docsEnum.nextDoc();\n          }\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for(int i=0;i<filledCount;i++) {\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        if (counts[slot] == 1+numDims) {\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          collectNearMiss(sidewaysCollectors, missingDims[slot]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33e19a97046248623a7591aeaa6547233fd15e2","date":1385424777,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doDrillDownAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":null,"sourceOld":"  /** Used when drill downs are highly constraining vs\n   *  baseQuery. */\n  private void doDrillDownAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    //if (DEBUG) {\n    //  System.out.println(\"  doDrillDownAdvanceScoring\");\n    //}\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n    int nextChunkStart = CHUNK;\n\n    final FixedBitSet seen = new FixedBitSet(CHUNK);\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n\n      // First dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim0\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[0]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        int docID = docsEnum.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            seen.set(slot);\n            // Mark slot as valid:\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 1;\n            counts[slot] = 1;\n          }\n\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      // Second dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim1\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[1]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        int docID = docsEnum.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            // Mark slot as valid:\n            seen.set(slot);\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" missingDim=0 id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 0;\n            counts[slot] = 1;\n          } else {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= 1) {\n              missingDims[slot] = 2;\n              counts[slot] = 2;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=2 id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            } else {\n              counts[slot] = 1;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=\" + missingDims[slot] + \" id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            }\n          }\n\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      // After this we can \"upgrade\" to conjunction, because\n      // any doc not seen by either dim 0 or dim 1 cannot be\n      // a hit or a near miss:\n\n      //if (DEBUG) {\n      //  System.out.println(\"  baseScorer\");\n      //}\n\n      // Fold in baseScorer, using advance:\n      int filledCount = 0;\n      int slot0 = 0;\n      while (slot0 < CHUNK && (slot0 = seen.nextSetBit(slot0)) != -1) {\n        int ddDocID = docIDs[slot0];\n        assert ddDocID != -1;\n\n        int baseDocID = baseScorer.docID();\n        if (baseDocID < ddDocID) {\n          baseDocID = baseScorer.advance(ddDocID);\n        }\n        if (baseDocID == ddDocID) {\n          //if (DEBUG) {\n          //  System.out.println(\"    keep docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          scores[slot0] = baseScorer.score();\n          filledSlots[filledCount++] = slot0;\n          counts[slot0]++;\n        } else {\n          //if (DEBUG) {\n          //  System.out.println(\"    no docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          docIDs[slot0] = -1;\n\n          // TODO: we could jump slot0 forward to the\n          // baseDocID ... but we'd need to set docIDs for\n          // intervening slots to -1\n        }\n        slot0++;\n      }\n      seen.clear(0, CHUNK);\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n      \n      // TODO: factor this out & share w/ union scorer,\n      // except we start from dim=2 instead:\n      for(int dim=2;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          int docID = docsEnum.docID();\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            // TODO: sometimes use advance?\n            docID = docsEnum.nextDoc();\n          }\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for(int i=0;i<filledCount;i++) {\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        if (counts[slot] == 1+numDims) {\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          collectNearMiss(sidewaysCollectors, missingDims[slot]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doDrillDownAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doDrillDownAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":"  /** Used when drill downs are highly constraining vs\n   *  baseQuery. */\n  private void doDrillDownAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    //if (DEBUG) {\n    //  System.out.println(\"  doDrillDownAdvanceScoring\");\n    //}\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n    int nextChunkStart = CHUNK;\n\n    final FixedBitSet seen = new FixedBitSet(CHUNK);\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n\n      // First dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim0\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[0]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        int docID = docsEnum.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            seen.set(slot);\n            // Mark slot as valid:\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 1;\n            counts[slot] = 1;\n          }\n\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      // Second dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim1\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[1]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        int docID = docsEnum.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            // Mark slot as valid:\n            seen.set(slot);\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" missingDim=0 id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 0;\n            counts[slot] = 1;\n          } else {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= 1) {\n              missingDims[slot] = 2;\n              counts[slot] = 2;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=2 id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            } else {\n              counts[slot] = 1;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=\" + missingDims[slot] + \" id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            }\n          }\n\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      // After this we can \"upgrade\" to conjunction, because\n      // any doc not seen by either dim 0 or dim 1 cannot be\n      // a hit or a near miss:\n\n      //if (DEBUG) {\n      //  System.out.println(\"  baseScorer\");\n      //}\n\n      // Fold in baseScorer, using advance:\n      int filledCount = 0;\n      int slot0 = 0;\n      while (slot0 < CHUNK && (slot0 = seen.nextSetBit(slot0)) != -1) {\n        int ddDocID = docIDs[slot0];\n        assert ddDocID != -1;\n\n        int baseDocID = baseScorer.docID();\n        if (baseDocID < ddDocID) {\n          baseDocID = baseScorer.advance(ddDocID);\n        }\n        if (baseDocID == ddDocID) {\n          //if (DEBUG) {\n          //  System.out.println(\"    keep docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          scores[slot0] = baseScorer.score();\n          filledSlots[filledCount++] = slot0;\n          counts[slot0]++;\n        } else {\n          //if (DEBUG) {\n          //  System.out.println(\"    no docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          docIDs[slot0] = -1;\n\n          // TODO: we could jump slot0 forward to the\n          // baseDocID ... but we'd need to set docIDs for\n          // intervening slots to -1\n        }\n        slot0++;\n      }\n      seen.clear(0, CHUNK);\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n      \n      // TODO: factor this out & share w/ union scorer,\n      // except we start from dim=2 instead:\n      for(int dim=2;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          int docID = docsEnum.docID();\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            // TODO: sometimes use advance?\n            docID = docsEnum.nextDoc();\n          }\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for(int i=0;i<filledCount;i++) {\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        if (counts[slot] == 1+numDims) {\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          collectNearMiss(sidewaysCollectors, missingDims[slot]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","sourceOld":"  /** Used when drill downs are highly constraining vs\n   *  baseQuery. */\n  private void doDrillDownAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    //if (DEBUG) {\n    //  System.out.println(\"  doDrillDownAdvanceScoring\");\n    //}\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n    int nextChunkStart = CHUNK;\n\n    final FixedBitSet seen = new FixedBitSet(CHUNK);\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n\n      // First dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim0\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[0]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        int docID = docsEnum.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            seen.set(slot);\n            // Mark slot as valid:\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 1;\n            counts[slot] = 1;\n          }\n\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      // Second dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim1\");\n      //}\n      for(DocsEnum docsEnum : docsEnums[1]) {\n        if (docsEnum == null) {\n          continue;\n        }\n        int docID = docsEnum.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            // Mark slot as valid:\n            seen.set(slot);\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" missingDim=0 id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 0;\n            counts[slot] = 1;\n          } else {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= 1) {\n              missingDims[slot] = 2;\n              counts[slot] = 2;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=2 id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            } else {\n              counts[slot] = 1;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=\" + missingDims[slot] + \" id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            }\n          }\n\n          docID = docsEnum.nextDoc();\n        }\n      }\n\n      // After this we can \"upgrade\" to conjunction, because\n      // any doc not seen by either dim 0 or dim 1 cannot be\n      // a hit or a near miss:\n\n      //if (DEBUG) {\n      //  System.out.println(\"  baseScorer\");\n      //}\n\n      // Fold in baseScorer, using advance:\n      int filledCount = 0;\n      int slot0 = 0;\n      while (slot0 < CHUNK && (slot0 = seen.nextSetBit(slot0)) != -1) {\n        int ddDocID = docIDs[slot0];\n        assert ddDocID != -1;\n\n        int baseDocID = baseScorer.docID();\n        if (baseDocID < ddDocID) {\n          baseDocID = baseScorer.advance(ddDocID);\n        }\n        if (baseDocID == ddDocID) {\n          //if (DEBUG) {\n          //  System.out.println(\"    keep docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          scores[slot0] = baseScorer.score();\n          filledSlots[filledCount++] = slot0;\n          counts[slot0]++;\n        } else {\n          //if (DEBUG) {\n          //  System.out.println(\"    no docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          docIDs[slot0] = -1;\n\n          // TODO: we could jump slot0 forward to the\n          // baseDocID ... but we'd need to set docIDs for\n          // intervening slots to -1\n        }\n        slot0++;\n      }\n      seen.clear(0, CHUNK);\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n      \n      // TODO: factor this out & share w/ union scorer,\n      // except we start from dim=2 instead:\n      for(int dim=2;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          int docID = docsEnum.docID();\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n            // TODO: sometimes use advance?\n            docID = docsEnum.nextDoc();\n          }\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for(int i=0;i<filledCount;i++) {\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        if (counts[slot] == 1+numDims) {\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          collectNearMiss(sidewaysCollectors, missingDims[slot]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d33e19a97046248623a7591aeaa6547233fd15e2":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd","d33e19a97046248623a7591aeaa6547233fd15e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["d33e19a97046248623a7591aeaa6547233fd15e2","3cc728b07df73b197e6d940d27f9b08b63918f13"],"d33e19a97046248623a7591aeaa6547233fd15e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}