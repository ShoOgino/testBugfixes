{"path":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","commits":[{"id":"e22ffe8cc51a892ae103df018822d7873e901c2a","date":1313696790,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        val.directory.close();\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"66c64e8cfded6a585100e6430238faaf416f3fea","date":1344964603,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        val.directory.close();\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["aaab905067d767cfe84d5d589c540723680f236e","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        val.directory.close();\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        val.directory.close();\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe4b1db4d9337f7c143a81f59a6be0032de84ef6","date":1351357459,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 100*10*30) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"213ee45ba043d841201d5b4e24195d9e0220f03c","date":1351361610,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 300) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 100*10*30) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 300) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1baa5f28657a1bb923498110621e50ffa4eb2d06","date":1353298181,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 600) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 300) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560975f45bfdd9b731610be50df91bc4e3458e90","date":1354806624,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 600) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"50f72d0bd893d658b48c8cf0959fc2fbafb7c7cf","date":1355109690,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 12000) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 12000) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 300) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb4a175e8863893e146a53576c406f9fecb9a9cf","date":1355165706,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 12000) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a2db3227fbc9542db033f69166e6608fd8f27be","date":1355326983,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory:\" + val.path);\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["cab31d869ae741ad9e0dcd49b07ef6ce51107a7c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aaab905067d767cfe84d5d589c540723680f236e","date":1355885775,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory:\" + val.path);\n          closeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory:\" + val.path);\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":["66c64e8cfded6a585100e6430238faaf416f3fea"],"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory:\" + val.path);\n          closeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 12000) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          val.directory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cab31d869ae741ad9e0dcd49b07ef6ce51107a7c","date":1362604055,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory: \" + val.path);\n          closeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory:\" + val.path);\n          closeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":["5a2db3227fbc9542db033f69166e6608fd8f27be"],"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29e0a20fbf18112c94a66fcc40987c4ffa80a5a9","date":1363460471,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      Collection<CacheValue> values = new ArrayList<CacheValue>();\n      values.addAll(byDirectoryCache.values());\n      for (CacheValue val : values) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        try {\n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory: \" + val.path);\n          closeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      for (CacheValue val : byDirectoryCache.values()) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          \n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory: \" + val.path);\n          closeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a4780bc0c0c5d86e6998d8e9ae0928ec3016205","date":1363621000,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      Collection<CacheValue> values = new ArrayList<CacheValue>();\n      values.addAll(byDirectoryCache.values());\n      for (CacheValue val : values) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        try {\n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory: \" + val.path);\n          closeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      byDirectoryCache.clear();\n      byPathCache.clear();\n      \n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory: \" + val.path);\n        removeDirectory(val);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      Collection<CacheValue> values = new ArrayList<CacheValue>();\n      values.addAll(byDirectoryCache.values());\n      for (CacheValue val : values) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        try {\n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory: \" + val.path);\n          closeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      byDirectoryCache.clear();\n      byPathCache.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"058801f8673d53a5abac8088204860ec29a40f0d","date":1364178882,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<CacheValue>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error removing directory\", t);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      this.closed = true;\n      Collection<CacheValue> values = new ArrayList<CacheValue>();\n      values.addAll(byDirectoryCache.values());\n      for (CacheValue val : values) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 1200) {\n              log.error(\"Timeout waiting for all directory ref counts to be released\");\n              break;\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        try {\n          assert val.refCnt == 0 : val.refCnt;\n          log.info(\"Closing directory when closing factory: \" + val.path);\n          closeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      byDirectoryCache.clear();\n      byPathCache.clear();\n      \n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory: \" + val.path);\n        removeDirectory(val);\n      }\n    }\n  }\n\n","bugFix":["e22ffe8cc51a892ae103df018822d7873e901c2a","29e0a20fbf18112c94a66fcc40987c4ffa80a5a9","d9405f486872f1e416304dfe389741f4ee2f8a4d","aaab905067d767cfe84d5d589c540723680f236e","cab31d869ae741ad9e0dcd49b07ef6ce51107a7c","3a4780bc0c0c5d86e6998d8e9ae0928ec3016205","eb4a175e8863893e146a53576c406f9fecb9a9cf","fe4b1db4d9337f7c143a81f59a6be0032de84ef6"],"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"25bbd8e76cd29f2d4b262a24d6a42c754706b143","date":1365910543,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<CacheValue>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error removing directory\", t);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<CacheValue>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error removing directory\", t);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<CacheValue>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<CacheValue>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error closing directory\", t);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error removing directory\", t);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":["29e0a20fbf18112c94a66fcc40987c4ffa80a5a9","66c64e8cfded6a585100e6430238faaf416f3fea","058801f8673d53a5abac8088204860ec29a40f0d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<CacheValue>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab20a04a303d3d2a5078076f4633e0482d643cc0","date":1398201811,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5d615d62cd8aff3690943d765e46942551f98b6","date":1474881754,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.debug(\"Closing {} - {} directories currently being tracked\", this.getClass().getSimpleName(), byDirectoryCache.size());\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.debug(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.debug(\"Closing {} - {} directories currently being tracked\", this.getClass().getSimpleName(), byDirectoryCache.size());\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.debug(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.debug(\"Closing {} - {} directories currently being tracked\", this.getClass().getSimpleName(), byDirectoryCache.size());\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.debug(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.info(\"Closing \" + this.getClass().getSimpleName() + \" - \" + byDirectoryCache.size() + \" directories currently being tracked\");\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.info(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.debug(\"Closing {} - {} directories currently being tracked\", this.getClass().getSimpleName(), byDirectoryCache.size());\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\",\n            this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while (val.refCnt != 0) {\n            wait(100);\n\n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.debug(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n\n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.debug(\"Closing {} - {} directories currently being tracked\", this.getClass().getSimpleName(), byDirectoryCache.size());\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\", \n                  this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while(val.refCnt != 0) {\n            wait(100);\n            \n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n      \n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.debug(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n      \n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#close().mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Closing {} - {} directories currently being tracked\", this.getClass().getSimpleName(), byDirectoryCache.size());\n      }\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n\n        if (log.isDebugEnabled()) {\n          log.debug(\"Closing {} - currently tracking: {}\", this.getClass().getSimpleName(), val);\n        }\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while (val.refCnt != 0) {\n            wait(100);\n\n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: {}\", v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.debug(\"Removing directory after core close: {}\", val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n\n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.solr.core.DirectoryFactory#close()\n   */\n  @Override\n  public void close() throws IOException {\n    synchronized (this) {\n      log.debug(\"Closing {} - {} directories currently being tracked\", this.getClass().getSimpleName(), byDirectoryCache.size());\n      this.closed = true;\n      Collection<CacheValue> values = byDirectoryCache.values();\n      for (CacheValue val : values) {\n        log.debug(\"Closing {} - currently tracking: {}\",\n            this.getClass().getSimpleName(), val);\n        try {\n          // if there are still refs out, we have to wait for them\n          assert val.refCnt > -1 : val.refCnt;\n          int cnt = 0;\n          while (val.refCnt != 0) {\n            wait(100);\n\n            if (cnt++ >= 120) {\n              String msg = \"Timeout waiting for all directory ref counts to be released - gave up waiting on \" + val;\n              log.error(msg);\n              // debug\n              // val.originTrace.printStackTrace();\n              throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n            }\n          }\n          assert val.refCnt == 0 : val.refCnt;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      values = byDirectoryCache.values();\n      Set<CacheValue> closedDirs = new HashSet<>();\n      for (CacheValue val : values) {\n        try {\n          for (CacheValue v : val.closeEntries) {\n            assert v.refCnt == 0 : val.refCnt;\n            log.debug(\"Closing directory when closing factory: \" + v.path);\n            boolean cl = closeCacheValue(v);\n            if (cl) {\n              closedDirs.add(v);\n            }\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"Error closing directory\", e);\n        }\n      }\n\n      for (CacheValue val : removeEntries) {\n        log.debug(\"Removing directory after core close: \" + val.path);\n        try {\n          removeDirectory(val);\n        } catch (Exception e) {\n          SolrException.log(log, \"Error removing directory\", e);\n        }\n      }\n\n      for (CacheValue v : closedDirs) {\n        removeFromCache(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","aaab905067d767cfe84d5d589c540723680f236e"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["e22ffe8cc51a892ae103df018822d7873e901c2a","66c64e8cfded6a585100e6430238faaf416f3fea"],"ab20a04a303d3d2a5078076f4633e0482d643cc0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"29e0a20fbf18112c94a66fcc40987c4ffa80a5a9":["cab31d869ae741ad9e0dcd49b07ef6ce51107a7c"],"5a2db3227fbc9542db033f69166e6608fd8f27be":["eb4a175e8863893e146a53576c406f9fecb9a9cf"],"50f72d0bd893d658b48c8cf0959fc2fbafb7c7cf":["560975f45bfdd9b731610be50df91bc4e3458e90"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["66c64e8cfded6a585100e6430238faaf416f3fea"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["e22ffe8cc51a892ae103df018822d7873e901c2a","66c64e8cfded6a585100e6430238faaf416f3fea"],"560975f45bfdd9b731610be50df91bc4e3458e90":["1baa5f28657a1bb923498110621e50ffa4eb2d06"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"140be51d03394488536f4aacedace29f9b318347":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["ab20a04a303d3d2a5078076f4633e0482d643cc0","a5d615d62cd8aff3690943d765e46942551f98b6"],"cab31d869ae741ad9e0dcd49b07ef6ce51107a7c":["aaab905067d767cfe84d5d589c540723680f236e"],"f2126b84bd093fa3d921582a109a0ee578c28126":["66c64e8cfded6a585100e6430238faaf416f3fea","213ee45ba043d841201d5b4e24195d9e0220f03c"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["25bbd8e76cd29f2d4b262a24d6a42c754706b143"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"66c64e8cfded6a585100e6430238faaf416f3fea":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","ab20a04a303d3d2a5078076f4633e0482d643cc0"],"407687e67faf6e1f02a211ca078d8e3eed631027":["213ee45ba043d841201d5b4e24195d9e0220f03c","50f72d0bd893d658b48c8cf0959fc2fbafb7c7cf"],"fe4b1db4d9337f7c143a81f59a6be0032de84ef6":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"213ee45ba043d841201d5b4e24195d9e0220f03c":["fe4b1db4d9337f7c143a81f59a6be0032de84ef6"],"1baa5f28657a1bb923498110621e50ffa4eb2d06":["213ee45ba043d841201d5b4e24195d9e0220f03c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["ab20a04a303d3d2a5078076f4633e0482d643cc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"aaab905067d767cfe84d5d589c540723680f236e":["5a2db3227fbc9542db033f69166e6608fd8f27be"],"a5d615d62cd8aff3690943d765e46942551f98b6":["ab20a04a303d3d2a5078076f4633e0482d643cc0"],"058801f8673d53a5abac8088204860ec29a40f0d":["3a4780bc0c0c5d86e6998d8e9ae0928ec3016205"],"eb4a175e8863893e146a53576c406f9fecb9a9cf":["50f72d0bd893d658b48c8cf0959fc2fbafb7c7cf"],"3a4780bc0c0c5d86e6998d8e9ae0928ec3016205":["29e0a20fbf18112c94a66fcc40987c4ffa80a5a9"],"25bbd8e76cd29f2d4b262a24d6a42c754706b143":["058801f8673d53a5abac8088204860ec29a40f0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["140be51d03394488536f4aacedace29f9b318347"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"ab20a04a303d3d2a5078076f4633e0482d643cc0":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a5d615d62cd8aff3690943d765e46942551f98b6"],"29e0a20fbf18112c94a66fcc40987c4ffa80a5a9":["3a4780bc0c0c5d86e6998d8e9ae0928ec3016205"],"5a2db3227fbc9542db033f69166e6608fd8f27be":["aaab905067d767cfe84d5d589c540723680f236e"],"50f72d0bd893d658b48c8cf0959fc2fbafb7c7cf":["407687e67faf6e1f02a211ca078d8e3eed631027","eb4a175e8863893e146a53576c406f9fecb9a9cf"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["fe4b1db4d9337f7c143a81f59a6be0032de84ef6"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"560975f45bfdd9b731610be50df91bc4e3458e90":["50f72d0bd893d658b48c8cf0959fc2fbafb7c7cf"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["140be51d03394488536f4aacedace29f9b318347"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["2668c99990e4c94a78bac005aa682b7c5986d23a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"140be51d03394488536f4aacedace29f9b318347":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"cab31d869ae741ad9e0dcd49b07ef6ce51107a7c":["29e0a20fbf18112c94a66fcc40987c4ffa80a5a9"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"e22ffe8cc51a892ae103df018822d7873e901c2a":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","66c64e8cfded6a585100e6430238faaf416f3fea"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"66c64e8cfded6a585100e6430238faaf416f3fea":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","d9405f486872f1e416304dfe389741f4ee2f8a4d","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","f2126b84bd093fa3d921582a109a0ee578c28126"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ab20a04a303d3d2a5078076f4633e0482d643cc0","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"fe4b1db4d9337f7c143a81f59a6be0032de84ef6":["213ee45ba043d841201d5b4e24195d9e0220f03c"],"213ee45ba043d841201d5b4e24195d9e0220f03c":["f2126b84bd093fa3d921582a109a0ee578c28126","407687e67faf6e1f02a211ca078d8e3eed631027","1baa5f28657a1bb923498110621e50ffa4eb2d06"],"1baa5f28657a1bb923498110621e50ffa4eb2d06":["560975f45bfdd9b731610be50df91bc4e3458e90"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"aaab905067d767cfe84d5d589c540723680f236e":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cab31d869ae741ad9e0dcd49b07ef6ce51107a7c"],"a5d615d62cd8aff3690943d765e46942551f98b6":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"058801f8673d53a5abac8088204860ec29a40f0d":["25bbd8e76cd29f2d4b262a24d6a42c754706b143"],"eb4a175e8863893e146a53576c406f9fecb9a9cf":["5a2db3227fbc9542db033f69166e6608fd8f27be"],"3a4780bc0c0c5d86e6998d8e9ae0928ec3016205":["058801f8673d53a5abac8088204860ec29a40f0d"],"25bbd8e76cd29f2d4b262a24d6a42c754706b143":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","f2126b84bd093fa3d921582a109a0ee578c28126","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}