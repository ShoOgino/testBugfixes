{"path":"lucene/core/src/test/org/apache/lucene/util/fst/TestBitTableUtil#testNextBitSet().mjava","commits":[{"id":"06086b5bd0f0d57858f0675becc58edf1f6b7c11","date":1586421397,"type":1,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBitTableUtil#testNextBitSet().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestBitUtil#testNextBitSet().mjava","sourceNew":"  public void testNextBitSet() throws IOException {\n    int numIterations = atLeast(1000);\n    for (int i = 0; i < numIterations; i++) {\n      byte[] bits = buildRandomBits();\n      int numBytes = bits.length - 1;\n      int numBits = numBytes * Byte.SIZE;\n\n      // Verify nextBitSet with countBitsUpTo for all bit indexes.\n      for (int bitIndex = -1; bitIndex < numBits; bitIndex++) {\n        int nextIndex = BitTableUtil.nextBitSet(bitIndex, numBytes, reader(bits));\n        if (nextIndex == -1) {\n          assertEquals(\"No next bit set, so expected no bit count diff\"\n                  + \" (i=\" + i + \" bitIndex=\" + bitIndex + \")\",\n              BitTableUtil.countBitsUpTo(bitIndex + 1, reader(bits)),\n              BitTableUtil.countBits(numBytes, reader(bits)));\n        } else {\n          assertTrue(\"Expected next bit set at nextIndex=\" + nextIndex\n                  + \" (i=\" + i + \" bitIndex=\" + bitIndex + \")\",\n              BitTableUtil.isBitSet(nextIndex, reader(bits)));\n          assertEquals(\"Next bit set at nextIndex=\" + nextIndex\n                  + \" so expected bit count diff of 1\"\n                  + \" (i=\" + i + \" bitIndex=\" + bitIndex + \")\",\n              BitTableUtil.countBitsUpTo(bitIndex + 1, reader(bits)) + 1,\n              BitTableUtil.countBitsUpTo(nextIndex + 1, reader(bits)));\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testNextBitSet() {\n    int numIterations = atLeast(1000);\n    for (int i = 0; i < numIterations; i++) {\n      long[] bits = buildRandomBits();\n      int numLong = bits.length - 1;\n\n      // Verify nextBitSet with countBitsUpTo for all bit indexes.\n      for (int bitIndex = -1; bitIndex < 64 * numLong; bitIndex++) {\n        int nextIndex = BitUtil.nextBitSet(bits, numLong, bitIndex);\n        if (nextIndex == -1) {\n          assertEquals(\"No next bit set, so expected no bit count diff\"\n                  + \" (i=\" + i + \" bitIndex=\" + bitIndex + \")\",\n              BitUtil.countBitsUpTo(bits, numLong, bitIndex + 1), BitUtil.countBits(bits, numLong));\n        } else {\n          assertTrue(\"Expected next bit set at nextIndex=\" + nextIndex\n                  + \" (i=\" + i + \" bitIndex=\" + bitIndex + \")\",\n              BitUtil.isBitSet(bits, numLong, nextIndex));\n          assertEquals(\"Next bit set at nextIndex=\" + nextIndex\n                  + \" so expected bit count diff of 1\"\n                  + \" (i=\" + i + \" bitIndex=\" + bitIndex + \")\",\n              BitUtil.countBitsUpTo(bits, numLong, bitIndex + 1) + 1,\n              BitUtil.countBitsUpTo(bits, numLong, nextIndex + 1));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"06086b5bd0f0d57858f0675becc58edf1f6b7c11":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06086b5bd0f0d57858f0675becc58edf1f6b7c11"]},"commit2Childs":{"06086b5bd0f0d57858f0675becc58edf1f6b7c11":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06086b5bd0f0d57858f0675becc58edf1f6b7c11"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}