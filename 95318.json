{"path":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(String,List[String],List[String],List[String],String).mjava","commits":[{"id":"a69e2a486e794ef99347d76fd562d069f922d1ce","date":1461874102,"type":1,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(String,List[String],List[String],List[String],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(CloudSolrClient,List[String],List[String],List[String],String).mjava","sourceNew":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param zk Solr ZooKeeper connection string\n   * @param fields List of fields to project\n   * @param filterQueries A list of filterQueries which should be used in the query\n   * @return Enumerator of results\n   */\n  public Enumerable<Object> query(final String zk, List<String> fields,\n                                  List<String> filterQueries, List<String> order, String limit) {\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.Q, \"*:*\");\n    //solrParams.put(CommonParams.QT, \"/export\");\n\n    if (fields.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fields));\n    }\n\n    if (filterQueries.isEmpty()) {\n      solrParams.put(CommonParams.FQ, \"*:*\");\n    } else {\n      // SolrParams should be a ModifiableParams instead of a map so we could add multiple FQs\n      solrParams.put(CommonParams.FQ, String.join(\" OR \", filterQueries));\n    }\n\n    // Build and issue the query and return an Enumerator over the results\n    if (order.isEmpty()) {\n      solrParams.put(CommonParams.SORT, DEFAULT_SORT_FIELD + \" desc\");\n\n      // Make sure the default sort field is in the field list\n      String fl = solrParams.get(CommonParams.FL);\n      if(!fl.contains(DEFAULT_SORT_FIELD)) {\n        solrParams.put(CommonParams.FL, String.join(\",\", fl, DEFAULT_SORT_FIELD));\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n    return new AbstractEnumerable<Object>() {\n      public Enumerator<Object> enumerator() {\n        TupleStream cloudSolrStream;\n        try {\n          cloudSolrStream = new CloudSolrStream(zk, collection, solrParams);\n          cloudSolrStream.open();\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        return new SolrEnumerator(cloudSolrStream, fields);\n      }\n    };\n  }\n\n","sourceOld":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param cloudSolrClient Solr CloudSolrClient\n   * @param fields List of fields to project\n   * @param filterQueries A list of filterQueries which should be used in the query\n   * @return Enumerator of results\n   */\n  public Enumerable<Object> query(final CloudSolrClient cloudSolrClient, List<String> fields,\n                                  List<String> filterQueries, List<String> order, String limit) {\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.Q, \"*:*\");\n    //solrParams.put(CommonParams.QT, \"/export\");\n\n    if (fields.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fields));\n    }\n\n    if (filterQueries.isEmpty()) {\n      solrParams.put(CommonParams.FQ, \"*:*\");\n    } else {\n      // SolrParams should be a ModifiableParams instead of a map so we could add multiple FQs\n      solrParams.put(CommonParams.FQ, String.join(\" OR \", filterQueries));\n    }\n\n    // Build and issue the query and return an Enumerator over the results\n    if (order.isEmpty()) {\n      solrParams.put(CommonParams.SORT, DEFAULT_SORT_FIELD + \" desc\");\n\n      // Make sure the default sort field is in the field list\n      String fl = solrParams.get(CommonParams.FL);\n      if(!fl.contains(DEFAULT_SORT_FIELD)) {\n        solrParams.put(CommonParams.FL, String.join(\",\", fl, DEFAULT_SORT_FIELD));\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n    return new AbstractEnumerable<Object>() {\n      public Enumerator<Object> enumerator() {\n        TupleStream cloudSolrStream;\n        try {\n          cloudSolrStream = new CloudSolrStream(cloudSolrClient.getZkHost(), collection, solrParams);\n          cloudSolrStream.open();\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        return new SolrEnumerator(cloudSolrStream, fields);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34960db40f081388a12ae7131547fb03236705fd","date":1461892880,"type":5,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(Properties,List[String],List[String],List[String],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(String,List[String],List[String],List[String],String).mjava","sourceNew":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param properties Connections properties\n   * @param fields List of fields to project\n   * @param filterQueries A list of filterQueries which should be used in the query\n   * @return Enumerator of results\n   */\n  public Enumerable<Object> query(final Properties properties, List<String> fields,\n                                  List<String> filterQueries, List<String> order, String limit) {\n    Map<String, String> solrParams = new HashMap<>();\n    //solrParams.put(CommonParams.OMIT_HEADER, \"true\");\n    solrParams.put(CommonParams.Q, \"*:*\");\n    //solrParams.put(CommonParams.QT, \"/export\");\n\n    if (fields.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fields));\n    }\n\n    if (filterQueries.isEmpty()) {\n      solrParams.put(CommonParams.FQ, \"*:*\");\n    } else {\n      // SolrParams should be a ModifiableParams instead of a map so we could add multiple FQs\n      solrParams.put(CommonParams.FQ, String.join(\" OR \", filterQueries));\n    }\n\n    // Build and issue the query and return an Enumerator over the results\n    if (order.isEmpty()) {\n      solrParams.put(CommonParams.SORT, DEFAULT_SORT_FIELD + \" desc\");\n\n      // Make sure the default sort field is in the field list\n      String fl = solrParams.get(CommonParams.FL);\n      if(!fl.contains(DEFAULT_SORT_FIELD)) {\n        solrParams.put(CommonParams.FL, String.join(\",\", fl, DEFAULT_SORT_FIELD));\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n    return new AbstractEnumerable<Object>() {\n      public Enumerator<Object> enumerator() {\n        TupleStream tupleStream;\n        try {\n          String zk = properties.getProperty(\"zk\");\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        return new SolrEnumerator(tupleStream, fields);\n      }\n    };\n  }\n\n","sourceOld":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param zk Solr ZooKeeper connection string\n   * @param fields List of fields to project\n   * @param filterQueries A list of filterQueries which should be used in the query\n   * @return Enumerator of results\n   */\n  public Enumerable<Object> query(final String zk, List<String> fields,\n                                  List<String> filterQueries, List<String> order, String limit) {\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.Q, \"*:*\");\n    //solrParams.put(CommonParams.QT, \"/export\");\n\n    if (fields.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fields));\n    }\n\n    if (filterQueries.isEmpty()) {\n      solrParams.put(CommonParams.FQ, \"*:*\");\n    } else {\n      // SolrParams should be a ModifiableParams instead of a map so we could add multiple FQs\n      solrParams.put(CommonParams.FQ, String.join(\" OR \", filterQueries));\n    }\n\n    // Build and issue the query and return an Enumerator over the results\n    if (order.isEmpty()) {\n      solrParams.put(CommonParams.SORT, DEFAULT_SORT_FIELD + \" desc\");\n\n      // Make sure the default sort field is in the field list\n      String fl = solrParams.get(CommonParams.FL);\n      if(!fl.contains(DEFAULT_SORT_FIELD)) {\n        solrParams.put(CommonParams.FL, String.join(\",\", fl, DEFAULT_SORT_FIELD));\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n    return new AbstractEnumerable<Object>() {\n      public Enumerator<Object> enumerator() {\n        TupleStream cloudSolrStream;\n        try {\n          cloudSolrStream = new CloudSolrStream(zk, collection, solrParams);\n          cloudSolrStream.open();\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        return new SolrEnumerator(cloudSolrStream, fields);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"34960db40f081388a12ae7131547fb03236705fd":["a69e2a486e794ef99347d76fd562d069f922d1ce"],"a69e2a486e794ef99347d76fd562d069f922d1ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"34960db40f081388a12ae7131547fb03236705fd":[],"a69e2a486e794ef99347d76fd562d069f922d1ce":["34960db40f081388a12ae7131547fb03236705fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a69e2a486e794ef99347d76fd562d069f922d1ce","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["34960db40f081388a12ae7131547fb03236705fd","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}