{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#surpriseMePolygon().mjava","commits":[{"id":"ac94c1c73e01278464e2c6be2b6f7ea0df26a571","date":1459112294,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#surpriseMePolygon().mjava","pathOld":"/dev/null","sourceNew":"  /** Returns {polyLats, polyLons} double[] array */\n  private double[][] surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = randomLat(false);\n      double centerLon = randomLon(false);\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = wrapLat(centerLat + len * Math.cos(Math.toRadians(angle)));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(wrapLat(lat));\n        lons.add(wrapLon(lon));\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new double[][] {latsArray, lonsArray};\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c7e72caffc799b265e17158ff9b0aad014849ad8","c7e72caffc799b265e17158ff9b0aad014849ad8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0da288484d638cec72e8fc33363e4c0532d35ff0","date":1459115234,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#surpriseMePolygon().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#surpriseMePolygon().mjava","sourceNew":"  /** Returns {polyLats, polyLons} double[] array */\n  private double[][] surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = randomLat(false);\n      double centerLon = randomLon(false);\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new double[][] {latsArray, lonsArray};\n    }\n  }\n\n","sourceOld":"  /** Returns {polyLats, polyLons} double[] array */\n  private double[][] surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = randomLat(false);\n      double centerLon = randomLon(false);\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = wrapLat(centerLat + len * Math.cos(Math.toRadians(angle)));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(wrapLat(lat));\n        lons.add(wrapLon(lon));\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new double[][] {latsArray, lonsArray};\n    }\n  }\n\n","bugFix":null,"bugIntro":["c7e72caffc799b265e17158ff9b0aad014849ad8","c7e72caffc799b265e17158ff9b0aad014849ad8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1419d3974886c9518c259c786492b4d3660b0b8e","date":1459180094,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/GeoTestUtil#surpriseMePolygon(Double,Double).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#surpriseMePolygon().mjava","sourceNew":"  /** Returns {polyLats, polyLons} double[] array */\n  private static double[][] surpriseMePolygon(Double otherLatitude, Double otherLongitude) {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      final double centerLat;\n      final double centerLon;\n      if (otherLatitude == null) {\n        centerLat = nextLatitude();\n        centerLon = nextLongitude();\n      } else {\n        GeoUtils.checkLatitude(otherLatitude);\n        GeoUtils.checkLongitude(otherLongitude);\n        centerLat = nextLatitudeNear(otherLatitude);\n        centerLon = nextLongitudeNear(otherLongitude);\n      }\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new double[][] {latsArray, lonsArray};\n    }\n  }\n\n","sourceOld":"  /** Returns {polyLats, polyLons} double[] array */\n  private double[][] surpriseMePolygon() {\n    // repeat until we get a poly that doesn't cross dateline:\n    newPoly:\n    while (true) {\n      //System.out.println(\"\\nPOLY ITER\");\n      double centerLat = randomLat(false);\n      double centerLon = randomLon(false);\n\n      double radius = 0.1 + 20 * random().nextDouble();\n      double radiusDelta = random().nextDouble();\n\n      ArrayList<Double> lats = new ArrayList<>();\n      ArrayList<Double> lons = new ArrayList<>();\n      double angle = 0.0;\n      while (true) {\n        angle += random().nextDouble()*40.0;\n        //System.out.println(\"  angle \" + angle);\n        if (angle > 360) {\n          break;\n        }\n        double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());\n        //System.out.println(\"    len=\" + len);\n        double lat = centerLat + len * Math.cos(Math.toRadians(angle));\n        double lon = centerLon + len * Math.sin(Math.toRadians(angle));\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        if (lat > 90) {\n          // cross the north pole\n          lat = 180 - lat;\n          lon = 180 - lon;\n        } else if (lat < -90) {\n          // cross the south pole\n          lat = -180 - lat;\n          lon = 180 - lon;\n        }\n        if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL) {\n          // cannot cross dateline: try again!\n          continue newPoly;\n        }\n        lats.add(lat);\n        lons.add(lon);\n\n        //System.out.println(\"    lat=\" + lats.get(lats.size()-1) + \" lon=\" + lons.get(lons.size()-1));\n      }\n\n      // close it\n      lats.add(lats.get(0));\n      lons.add(lons.get(0));\n\n      double[] latsArray = new double[lats.size()];\n      double[] lonsArray = new double[lons.size()];\n      for(int i=0;i<lats.size();i++) {\n        latsArray[i] = lats.get(i);\n        lonsArray[i] = lons.get(i);\n      }\n      return new double[][] {latsArray, lonsArray};\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0da288484d638cec72e8fc33363e4c0532d35ff0":["ac94c1c73e01278464e2c6be2b6f7ea0df26a571"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1419d3974886c9518c259c786492b4d3660b0b8e":["0da288484d638cec72e8fc33363e4c0532d35ff0"],"ac94c1c73e01278464e2c6be2b6f7ea0df26a571":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1419d3974886c9518c259c786492b4d3660b0b8e"]},"commit2Childs":{"0da288484d638cec72e8fc33363e4c0532d35ff0":["1419d3974886c9518c259c786492b4d3660b0b8e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ac94c1c73e01278464e2c6be2b6f7ea0df26a571"],"1419d3974886c9518c259c786492b4d3660b0b8e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ac94c1c73e01278464e2c6be2b6f7ea0df26a571":["0da288484d638cec72e8fc33363e4c0532d35ff0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}