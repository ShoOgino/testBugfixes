{"path":"lucene/core/src/test/org/apache/lucene/index/TestBinaryDocValuesUpdates#testSortedIndex().mjava","commits":[{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBinaryDocValuesUpdates#testSortedIndex().mjava","pathOld":"/dev/null","sourceNew":"  public void testSortedIndex() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexSort(new Sort(new SortField(\"sort\", SortField.Type.LONG)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int valueRange = TestUtil.nextInt(random(), 1, 1000);\n    int sortValueRange = TestUtil.nextInt(random(), 1, 1000);\n\n    int refreshChance = TestUtil.nextInt(random(), 5, 200);\n    int deleteChance = TestUtil.nextInt(random(), 2, 100);\n\n    int idUpto = 0;\n    int deletedCount = 0;\n    \n    List<OneSortDoc> docs = new ArrayList<>();\n    DirectoryReader r = w.getReader();\n\n    int numIters = atLeast(1000);\n    for(int iter=0;iter<numIters;iter++) {\n      BytesRef value = toBytes((long) random().nextInt(valueRange));\n      if (docs.isEmpty() || random().nextInt(3) == 1) {\n        int id = docs.size();\n        // add new doc\n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(id), Field.Store.YES));\n        doc.add(new BinaryDocValuesField(\"number\", value));\n        int sortValue = random().nextInt(sortValueRange);\n        doc.add(new NumericDocValuesField(\"sort\", sortValue));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add doc id=\" + id + \" sortValue=\" + sortValue + \" value=\" + value);\n        }\n        w.addDocument(doc);\n\n        docs.add(new OneSortDoc(id, value, sortValue));\n      } else {\n        // update existing doc value\n        int idToUpdate = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update doc id=\" + idToUpdate + \" new value=\" + value);\n        }\n        w.updateBinaryDocValue(new Term(\"id\", Integer.toString(idToUpdate)), \"number\", value);\n\n        docs.get(idToUpdate).value = value;\n      }\n\n      if (random().nextInt(deleteChance) == 0) {\n        int idToDelete = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + idToDelete);\n        }\n        w.deleteDocuments(new Term(\"id\", Integer.toString(idToDelete)));\n        if (docs.get(idToDelete).deleted == false) {\n          docs.get(idToDelete).deleted = true;\n          deletedCount++;\n        }\n      }\n\n      if (random().nextInt(refreshChance) == 0) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now get reader; old reader=\" + r);\n        }\n        DirectoryReader r2 = w.getReader();\n        r.close();\n        r = r2;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: got reader=\" + r);\n        }\n\n        int liveCount = 0;\n\n        for (LeafReaderContext ctx : r.leaves()) {\n          LeafReader leafReader = ctx.reader();\n          BinaryDocValues values = leafReader.getBinaryDocValues(\"number\");\n          NumericDocValues sortValues = leafReader.getNumericDocValues(\"sort\");\n          Bits liveDocs = leafReader.getLiveDocs();\n\n          long lastSortValue = Long.MIN_VALUE;\n          for (int i=0;i<leafReader.maxDoc();i++) {\n\n            Document doc = leafReader.document(i);\n            OneSortDoc sortDoc = docs.get(Integer.parseInt(doc.get(\"id\")));\n\n            assertEquals(i, values.nextDoc());\n            assertEquals(i, sortValues.nextDoc());\n\n            if (liveDocs != null && liveDocs.get(i) == false) {\n              assertTrue(sortDoc.deleted);\n              continue;\n            }\n            assertFalse(sortDoc.deleted);\n        \n            assertEquals(sortDoc.value, values.binaryValue());\n\n            long sortValue = sortValues.longValue();\n            assertEquals(sortDoc.sortValue, sortValue);\n            \n            assertTrue(sortValue >= lastSortValue);\n            lastSortValue = sortValue;\n            liveCount++;\n          }\n        }\n\n        assertEquals(docs.size() - deletedCount, liveCount);\n      }\n    }\n\n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBinaryDocValuesUpdates#testSortedIndex().mjava","pathOld":"/dev/null","sourceNew":"  public void testSortedIndex() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexSort(new Sort(new SortField(\"sort\", SortField.Type.LONG)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int valueRange = TestUtil.nextInt(random(), 1, 1000);\n    int sortValueRange = TestUtil.nextInt(random(), 1, 1000);\n\n    int refreshChance = TestUtil.nextInt(random(), 5, 200);\n    int deleteChance = TestUtil.nextInt(random(), 2, 100);\n\n    int idUpto = 0;\n    int deletedCount = 0;\n    \n    List<OneSortDoc> docs = new ArrayList<>();\n    DirectoryReader r = w.getReader();\n\n    int numIters = atLeast(1000);\n    for(int iter=0;iter<numIters;iter++) {\n      BytesRef value = toBytes((long) random().nextInt(valueRange));\n      if (docs.isEmpty() || random().nextInt(3) == 1) {\n        int id = docs.size();\n        // add new doc\n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(id), Field.Store.YES));\n        doc.add(new BinaryDocValuesField(\"number\", value));\n        int sortValue = random().nextInt(sortValueRange);\n        doc.add(new NumericDocValuesField(\"sort\", sortValue));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add doc id=\" + id + \" sortValue=\" + sortValue + \" value=\" + value);\n        }\n        w.addDocument(doc);\n\n        docs.add(new OneSortDoc(id, value, sortValue));\n      } else {\n        // update existing doc value\n        int idToUpdate = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update doc id=\" + idToUpdate + \" new value=\" + value);\n        }\n        w.updateBinaryDocValue(new Term(\"id\", Integer.toString(idToUpdate)), \"number\", value);\n\n        docs.get(idToUpdate).value = value;\n      }\n\n      if (random().nextInt(deleteChance) == 0) {\n        int idToDelete = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + idToDelete);\n        }\n        w.deleteDocuments(new Term(\"id\", Integer.toString(idToDelete)));\n        if (docs.get(idToDelete).deleted == false) {\n          docs.get(idToDelete).deleted = true;\n          deletedCount++;\n        }\n      }\n\n      if (random().nextInt(refreshChance) == 0) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now get reader; old reader=\" + r);\n        }\n        DirectoryReader r2 = w.getReader();\n        r.close();\n        r = r2;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: got reader=\" + r);\n        }\n\n        int liveCount = 0;\n\n        for (LeafReaderContext ctx : r.leaves()) {\n          LeafReader leafReader = ctx.reader();\n          BinaryDocValues values = leafReader.getBinaryDocValues(\"number\");\n          NumericDocValues sortValues = leafReader.getNumericDocValues(\"sort\");\n          Bits liveDocs = leafReader.getLiveDocs();\n\n          long lastSortValue = Long.MIN_VALUE;\n          for (int i=0;i<leafReader.maxDoc();i++) {\n\n            Document doc = leafReader.document(i);\n            OneSortDoc sortDoc = docs.get(Integer.parseInt(doc.get(\"id\")));\n\n            assertEquals(i, values.nextDoc());\n            assertEquals(i, sortValues.nextDoc());\n\n            if (liveDocs != null && liveDocs.get(i) == false) {\n              assertTrue(sortDoc.deleted);\n              continue;\n            }\n            assertFalse(sortDoc.deleted);\n        \n            assertEquals(sortDoc.value, values.binaryValue());\n\n            long sortValue = sortValues.longValue();\n            assertEquals(sortDoc.sortValue, sortValue);\n            \n            assertTrue(sortValue >= lastSortValue);\n            lastSortValue = sortValue;\n            liveCount++;\n          }\n        }\n\n        assertEquals(docs.size() - deletedCount, liveCount);\n      }\n    }\n\n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBinaryDocValuesUpdates#testSortedIndex().mjava","pathOld":"/dev/null","sourceNew":"  public void testSortedIndex() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexSort(new Sort(new SortField(\"sort\", SortField.Type.LONG)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int valueRange = TestUtil.nextInt(random(), 1, 1000);\n    int sortValueRange = TestUtil.nextInt(random(), 1, 1000);\n\n    int refreshChance = TestUtil.nextInt(random(), 5, 200);\n    int deleteChance = TestUtil.nextInt(random(), 2, 100);\n\n    int idUpto = 0;\n    int deletedCount = 0;\n    \n    List<OneSortDoc> docs = new ArrayList<>();\n    DirectoryReader r = w.getReader();\n\n    int numIters = atLeast(1000);\n    for(int iter=0;iter<numIters;iter++) {\n      BytesRef value = toBytes((long) random().nextInt(valueRange));\n      if (docs.isEmpty() || random().nextInt(3) == 1) {\n        int id = docs.size();\n        // add new doc\n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(id), Field.Store.YES));\n        doc.add(new BinaryDocValuesField(\"number\", value));\n        int sortValue = random().nextInt(sortValueRange);\n        doc.add(new NumericDocValuesField(\"sort\", sortValue));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add doc id=\" + id + \" sortValue=\" + sortValue + \" value=\" + value);\n        }\n        w.addDocument(doc);\n\n        docs.add(new OneSortDoc(id, value, sortValue));\n      } else {\n        // update existing doc value\n        int idToUpdate = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update doc id=\" + idToUpdate + \" new value=\" + value);\n        }\n        w.updateBinaryDocValue(new Term(\"id\", Integer.toString(idToUpdate)), \"number\", value);\n\n        docs.get(idToUpdate).value = value;\n      }\n\n      if (random().nextInt(deleteChance) == 0) {\n        int idToDelete = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + idToDelete);\n        }\n        w.deleteDocuments(new Term(\"id\", Integer.toString(idToDelete)));\n        if (docs.get(idToDelete).deleted == false) {\n          docs.get(idToDelete).deleted = true;\n          deletedCount++;\n        }\n      }\n\n      if (random().nextInt(refreshChance) == 0) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now get reader; old reader=\" + r);\n        }\n        DirectoryReader r2 = w.getReader();\n        r.close();\n        r = r2;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: got reader=\" + r);\n        }\n\n        int liveCount = 0;\n\n        for (LeafReaderContext ctx : r.leaves()) {\n          LeafReader leafReader = ctx.reader();\n          BinaryDocValues values = leafReader.getBinaryDocValues(\"number\");\n          NumericDocValues sortValues = leafReader.getNumericDocValues(\"sort\");\n          Bits liveDocs = leafReader.getLiveDocs();\n\n          long lastSortValue = Long.MIN_VALUE;\n          for (int i=0;i<leafReader.maxDoc();i++) {\n\n            Document doc = leafReader.document(i);\n            OneSortDoc sortDoc = docs.get(Integer.parseInt(doc.get(\"id\")));\n\n            assertEquals(i, values.nextDoc());\n            assertEquals(i, sortValues.nextDoc());\n\n            if (liveDocs != null && liveDocs.get(i) == false) {\n              assertTrue(sortDoc.deleted);\n              continue;\n            }\n            assertFalse(sortDoc.deleted);\n        \n            assertEquals(sortDoc.value, values.binaryValue());\n\n            long sortValue = sortValues.longValue();\n            assertEquals(sortDoc.sortValue, sortValue);\n            \n            assertTrue(sortValue >= lastSortValue);\n            lastSortValue = sortValue;\n            liveCount++;\n          }\n        }\n\n        assertEquals(docs.size() - deletedCount, liveCount);\n      }\n    }\n\n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBinaryDocValuesUpdates#testSortedIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBinaryDocValuesUpdates#testSortedIndex().mjava","sourceNew":"  public void testSortedIndex() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexSort(new Sort(new SortField(\"sort\", SortField.Type.LONG)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int valueRange = TestUtil.nextInt(random(), 1, 1000);\n    int sortValueRange = TestUtil.nextInt(random(), 1, 1000);\n\n    int refreshChance = TestUtil.nextInt(random(), 5, 200);\n    int deleteChance = TestUtil.nextInt(random(), 2, 100);\n\n    int deletedCount = 0;\n    \n    List<OneSortDoc> docs = new ArrayList<>();\n    DirectoryReader r = w.getReader();\n\n    int numIters = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    for(int iter=0;iter<numIters;iter++) {\n      BytesRef value = toBytes((long) random().nextInt(valueRange));\n      if (docs.isEmpty() || random().nextInt(3) == 1) {\n        int id = docs.size();\n        // add new doc\n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(id), Field.Store.YES));\n        doc.add(new BinaryDocValuesField(\"number\", value));\n        int sortValue = random().nextInt(sortValueRange);\n        doc.add(new NumericDocValuesField(\"sort\", sortValue));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add doc id=\" + id + \" sortValue=\" + sortValue + \" value=\" + value);\n        }\n        w.addDocument(doc);\n\n        docs.add(new OneSortDoc(id, value, sortValue));\n      } else {\n        // update existing doc value\n        int idToUpdate = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update doc id=\" + idToUpdate + \" new value=\" + value);\n        }\n        w.updateBinaryDocValue(new Term(\"id\", Integer.toString(idToUpdate)), \"number\", value);\n\n        docs.get(idToUpdate).value = value;\n      }\n\n      if (random().nextInt(deleteChance) == 0) {\n        int idToDelete = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + idToDelete);\n        }\n        w.deleteDocuments(new Term(\"id\", Integer.toString(idToDelete)));\n        if (docs.get(idToDelete).deleted == false) {\n          docs.get(idToDelete).deleted = true;\n          deletedCount++;\n        }\n      }\n\n      if (random().nextInt(refreshChance) == 0) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now get reader; old reader=\" + r);\n        }\n        DirectoryReader r2 = w.getReader();\n        r.close();\n        r = r2;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: got reader=\" + r);\n        }\n\n        int liveCount = 0;\n\n        for (LeafReaderContext ctx : r.leaves()) {\n          LeafReader leafReader = ctx.reader();\n          BinaryDocValues values = leafReader.getBinaryDocValues(\"number\");\n          NumericDocValues sortValues = leafReader.getNumericDocValues(\"sort\");\n          Bits liveDocs = leafReader.getLiveDocs();\n\n          long lastSortValue = Long.MIN_VALUE;\n          for (int i=0;i<leafReader.maxDoc();i++) {\n\n            Document doc = leafReader.document(i);\n            OneSortDoc sortDoc = docs.get(Integer.parseInt(doc.get(\"id\")));\n\n            assertEquals(i, values.nextDoc());\n            assertEquals(i, sortValues.nextDoc());\n\n            if (liveDocs != null && liveDocs.get(i) == false) {\n              assertTrue(sortDoc.deleted);\n              continue;\n            }\n            assertFalse(sortDoc.deleted);\n        \n            assertEquals(sortDoc.value, values.binaryValue());\n\n            long sortValue = sortValues.longValue();\n            assertEquals(sortDoc.sortValue, sortValue);\n            \n            assertTrue(sortValue >= lastSortValue);\n            lastSortValue = sortValue;\n            liveCount++;\n          }\n        }\n\n        assertEquals(docs.size() - deletedCount, liveCount);\n      }\n    }\n\n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":"  public void testSortedIndex() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexSort(new Sort(new SortField(\"sort\", SortField.Type.LONG)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int valueRange = TestUtil.nextInt(random(), 1, 1000);\n    int sortValueRange = TestUtil.nextInt(random(), 1, 1000);\n\n    int refreshChance = TestUtil.nextInt(random(), 5, 200);\n    int deleteChance = TestUtil.nextInt(random(), 2, 100);\n\n    int idUpto = 0;\n    int deletedCount = 0;\n    \n    List<OneSortDoc> docs = new ArrayList<>();\n    DirectoryReader r = w.getReader();\n\n    int numIters = atLeast(1000);\n    for(int iter=0;iter<numIters;iter++) {\n      BytesRef value = toBytes((long) random().nextInt(valueRange));\n      if (docs.isEmpty() || random().nextInt(3) == 1) {\n        int id = docs.size();\n        // add new doc\n        Document doc = new Document();\n        doc.add(newStringField(\"id\", Integer.toString(id), Field.Store.YES));\n        doc.add(new BinaryDocValuesField(\"number\", value));\n        int sortValue = random().nextInt(sortValueRange);\n        doc.add(new NumericDocValuesField(\"sort\", sortValue));\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" add doc id=\" + id + \" sortValue=\" + sortValue + \" value=\" + value);\n        }\n        w.addDocument(doc);\n\n        docs.add(new OneSortDoc(id, value, sortValue));\n      } else {\n        // update existing doc value\n        int idToUpdate = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: iter=\" + iter + \" update doc id=\" + idToUpdate + \" new value=\" + value);\n        }\n        w.updateBinaryDocValue(new Term(\"id\", Integer.toString(idToUpdate)), \"number\", value);\n\n        docs.get(idToUpdate).value = value;\n      }\n\n      if (random().nextInt(deleteChance) == 0) {\n        int idToDelete = random().nextInt(docs.size());\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + idToDelete);\n        }\n        w.deleteDocuments(new Term(\"id\", Integer.toString(idToDelete)));\n        if (docs.get(idToDelete).deleted == false) {\n          docs.get(idToDelete).deleted = true;\n          deletedCount++;\n        }\n      }\n\n      if (random().nextInt(refreshChance) == 0) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now get reader; old reader=\" + r);\n        }\n        DirectoryReader r2 = w.getReader();\n        r.close();\n        r = r2;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: got reader=\" + r);\n        }\n\n        int liveCount = 0;\n\n        for (LeafReaderContext ctx : r.leaves()) {\n          LeafReader leafReader = ctx.reader();\n          BinaryDocValues values = leafReader.getBinaryDocValues(\"number\");\n          NumericDocValues sortValues = leafReader.getNumericDocValues(\"sort\");\n          Bits liveDocs = leafReader.getLiveDocs();\n\n          long lastSortValue = Long.MIN_VALUE;\n          for (int i=0;i<leafReader.maxDoc();i++) {\n\n            Document doc = leafReader.document(i);\n            OneSortDoc sortDoc = docs.get(Integer.parseInt(doc.get(\"id\")));\n\n            assertEquals(i, values.nextDoc());\n            assertEquals(i, sortValues.nextDoc());\n\n            if (liveDocs != null && liveDocs.get(i) == false) {\n              assertTrue(sortDoc.deleted);\n              continue;\n            }\n            assertFalse(sortDoc.deleted);\n        \n            assertEquals(sortDoc.value, values.binaryValue());\n\n            long sortValue = sortValues.longValue();\n            assertEquals(sortDoc.sortValue, sortValue);\n            \n            assertTrue(sortValue >= lastSortValue);\n            lastSortValue = sortValue;\n            liveCount++;\n          }\n        }\n\n        assertEquals(docs.size() - deletedCount, liveCount);\n      }\n    }\n\n    IOUtils.close(r, w, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"]},"commit2Childs":{"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}