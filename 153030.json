{"path":"sandbox/projects/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","commits":[{"id":"9809dc8ba717640d1ea75b2404405c49070a4e84","date":1026267640,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/projects/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     *  index the fileset\n     *\n     * @exception  IOException  Description of Exception\n     * @todo refactor - definitely lots of room for improvement here\n     */\n    private void indexDocs() throws IOException {\n        Date start = new Date();\n\n        boolean create = overwrite;\n        // If the index directory doesn't exist,\n        // create it and force create mode\n        if (indexPath.mkdirs() && !overwrite) {\n            create = true;\n        }\n\n        Searcher searcher = null;\n        Analyzer analyzer = new StopAnalyzer();\n        boolean checkLastModified = false;\n        if (!create) {\n            try {\n                searcher = new IndexSearcher(indexPath.getAbsolutePath());\n                checkLastModified = true;\n            }\n            catch (IOException ioe) {\n                log(\"IOException: \" + ioe.getMessage());\n                // Empty - ignore, which indicates to index all\n                // documents\n            }\n        }\n\n        log(\"checkLastModified = \" + checkLastModified);\n\n        IndexWriter writer =\n                       new IndexWriter(indexPath, analyzer, create);\n        int totalFiles = 0;\n        int totalIndexed = 0;\n        int totalIgnored = 0;\n        try {\n            writer.mergeFactor = mergeFactor;\n\n            for (int i = 0; i < filesets.size(); i++) {\n                FileSet fs = (FileSet) filesets.elementAt(i);\n                if (fs != null) {\n                    DirectoryScanner ds =\n                                   fs.getDirectoryScanner(project);\n                    String[] dsfiles = ds.getIncludedFiles();\n                    File baseDir = ds.getBasedir();\n\n                    for (int j = 0; j < dsfiles.length; j++) {\n                        File file = new File(baseDir, dsfiles[j]);\n                        totalFiles++;\n\n                        if (!file.exists() || !file.canRead()) {\n                            throw new BuildException(\"File \\\"\" +\n                        file.getAbsolutePath()\n                        + \"\\\" does not exist or is not readable.\");\n                        }\n\n                        boolean indexIt = true;\n\n                        if (checkLastModified) {\n                            Hits hits = null;\n                            Term pathTerm = \n                                  new Term(\"path\", file.getPath());\n                            TermQuery query =\n                                           new TermQuery(pathTerm);\n                            hits = searcher.search(query);\n\n                            // if document is found, compare the\n                            // indexed last modified time with the\n                            // current file\n                            // - don't index if up to date\n                            if (hits.length() > 0) {\n                                Document doc = hits.doc(0);\n                                String indexModified =\n                                               doc.get(\"modified\");\n                                if (indexModified != null) {\n                                    if (DateField.stringToTime(indexModified)\n                                             == file.lastModified()) {\n                                        indexIt = false;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (indexIt) {\n                            try {\n                                log(\"Indexing \" + file.getPath(),\n                                    Project.MSG_VERBOSE);\n                                Document doc =\n                                         handler.getDocument(file);\n\n                                if (doc == null) {\n                                    totalIgnored++;\n                                }\n                                else {\n                                    // Add the path of the file as a field named \"path\".  Use a Text field, so\n                                    // that the index stores the path, and so that the path is searchable\n                                    doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                                    // Add the last modified date of the file a field named \"modified\".  Use a\n                                    // Keyword field, so that it's searchable, but so that no attempt is made\n                                    // to tokenize the field into words.\n                                    doc.add(Field.Keyword(\"modified\",\n                                            DateField.timeToString(file.lastModified())));\n\n                                    writer.addDocument(doc);\n                                    totalIndexed++;\n                                }\n                            }\n                            catch (DocumentHandlerException e) {\n                                throw new BuildException(e);\n                            }\n                        }\n                    }\n                    // for j\n                }\n                // if (fs != null)\n            }\n            // for i\n\n            writer.optimize();\n        }\n        //try\n        finally {\n            // always make sure everything gets closed,\n            // no matter how we exit.\n            writer.close();\n            if (searcher != null) {\n                searcher.close();\n            }\n        }\n\n        Date end = new Date();\n\n        log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n                totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n                \" milliseconds\");\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6cae9303ec860d8a88b807570b29e841a3d1fbd3","date":1026349951,"type":5,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"sandbox/projects/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","sourceNew":"    /**\n     *  index the fileset\n     *\n     * @exception  IOException  Description of Exception\n     * @todo refactor - definitely lots of room for improvement here\n     */\n    private void indexDocs() throws IOException {\n        Date start = new Date();\n\n        boolean create = overwrite;\n        // If the index directory doesn't exist,\n        // create it and force create mode\n        if (indexPath.mkdirs() && !overwrite) {\n            create = true;\n        }\n\n        Searcher searcher = null;\n        Analyzer analyzer = new StopAnalyzer();\n        boolean checkLastModified = false;\n        if (!create) {\n            try {\n                searcher = new IndexSearcher(indexPath.getAbsolutePath());\n                checkLastModified = true;\n            }\n            catch (IOException ioe) {\n                log(\"IOException: \" + ioe.getMessage());\n                // Empty - ignore, which indicates to index all\n                // documents\n            }\n        }\n\n        log(\"checkLastModified = \" + checkLastModified);\n\n        IndexWriter writer =\n                       new IndexWriter(indexPath, analyzer, create);\n        int totalFiles = 0;\n        int totalIndexed = 0;\n        int totalIgnored = 0;\n        try {\n            writer.mergeFactor = mergeFactor;\n\n            for (int i = 0; i < filesets.size(); i++) {\n                FileSet fs = (FileSet) filesets.elementAt(i);\n                if (fs != null) {\n                    DirectoryScanner ds =\n                                   fs.getDirectoryScanner(project);\n                    String[] dsfiles = ds.getIncludedFiles();\n                    File baseDir = ds.getBasedir();\n\n                    for (int j = 0; j < dsfiles.length; j++) {\n                        File file = new File(baseDir, dsfiles[j]);\n                        totalFiles++;\n\n                        if (!file.exists() || !file.canRead()) {\n                            throw new BuildException(\"File \\\"\" +\n                        file.getAbsolutePath()\n                        + \"\\\" does not exist or is not readable.\");\n                        }\n\n                        boolean indexIt = true;\n\n                        if (checkLastModified) {\n                            Hits hits = null;\n                            Term pathTerm = \n                                  new Term(\"path\", file.getPath());\n                            TermQuery query =\n                                           new TermQuery(pathTerm);\n                            hits = searcher.search(query);\n\n                            // if document is found, compare the\n                            // indexed last modified time with the\n                            // current file\n                            // - don't index if up to date\n                            if (hits.length() > 0) {\n                                Document doc = hits.doc(0);\n                                String indexModified =\n                                               doc.get(\"modified\");\n                                if (indexModified != null) {\n                                    if (DateField.stringToTime(indexModified)\n                                             == file.lastModified()) {\n                                        indexIt = false;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (indexIt) {\n                            try {\n                                log(\"Indexing \" + file.getPath(),\n                                    Project.MSG_VERBOSE);\n                                Document doc =\n                                         handler.getDocument(file);\n\n                                if (doc == null) {\n                                    totalIgnored++;\n                                }\n                                else {\n                                    // Add the path of the file as a field named \"path\".  Use a Text field, so\n                                    // that the index stores the path, and so that the path is searchable\n                                    doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                                    // Add the last modified date of the file a field named \"modified\".  Use a\n                                    // Keyword field, so that it's searchable, but so that no attempt is made\n                                    // to tokenize the field into words.\n                                    doc.add(Field.Keyword(\"modified\",\n                                            DateField.timeToString(file.lastModified())));\n\n                                    writer.addDocument(doc);\n                                    totalIndexed++;\n                                }\n                            }\n                            catch (DocumentHandlerException e) {\n                                throw new BuildException(e);\n                            }\n                        }\n                    }\n                    // for j\n                }\n                // if (fs != null)\n            }\n            // for i\n\n            writer.optimize();\n        }\n        //try\n        finally {\n            // always make sure everything gets closed,\n            // no matter how we exit.\n            writer.close();\n            if (searcher != null) {\n                searcher.close();\n            }\n        }\n\n        Date end = new Date();\n\n        log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n                totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n                \" milliseconds\");\n    }\n\n","sourceOld":"    /**\n     *  index the fileset\n     *\n     * @exception  IOException  Description of Exception\n     * @todo refactor - definitely lots of room for improvement here\n     */\n    private void indexDocs() throws IOException {\n        Date start = new Date();\n\n        boolean create = overwrite;\n        // If the index directory doesn't exist,\n        // create it and force create mode\n        if (indexPath.mkdirs() && !overwrite) {\n            create = true;\n        }\n\n        Searcher searcher = null;\n        Analyzer analyzer = new StopAnalyzer();\n        boolean checkLastModified = false;\n        if (!create) {\n            try {\n                searcher = new IndexSearcher(indexPath.getAbsolutePath());\n                checkLastModified = true;\n            }\n            catch (IOException ioe) {\n                log(\"IOException: \" + ioe.getMessage());\n                // Empty - ignore, which indicates to index all\n                // documents\n            }\n        }\n\n        log(\"checkLastModified = \" + checkLastModified);\n\n        IndexWriter writer =\n                       new IndexWriter(indexPath, analyzer, create);\n        int totalFiles = 0;\n        int totalIndexed = 0;\n        int totalIgnored = 0;\n        try {\n            writer.mergeFactor = mergeFactor;\n\n            for (int i = 0; i < filesets.size(); i++) {\n                FileSet fs = (FileSet) filesets.elementAt(i);\n                if (fs != null) {\n                    DirectoryScanner ds =\n                                   fs.getDirectoryScanner(project);\n                    String[] dsfiles = ds.getIncludedFiles();\n                    File baseDir = ds.getBasedir();\n\n                    for (int j = 0; j < dsfiles.length; j++) {\n                        File file = new File(baseDir, dsfiles[j]);\n                        totalFiles++;\n\n                        if (!file.exists() || !file.canRead()) {\n                            throw new BuildException(\"File \\\"\" +\n                        file.getAbsolutePath()\n                        + \"\\\" does not exist or is not readable.\");\n                        }\n\n                        boolean indexIt = true;\n\n                        if (checkLastModified) {\n                            Hits hits = null;\n                            Term pathTerm = \n                                  new Term(\"path\", file.getPath());\n                            TermQuery query =\n                                           new TermQuery(pathTerm);\n                            hits = searcher.search(query);\n\n                            // if document is found, compare the\n                            // indexed last modified time with the\n                            // current file\n                            // - don't index if up to date\n                            if (hits.length() > 0) {\n                                Document doc = hits.doc(0);\n                                String indexModified =\n                                               doc.get(\"modified\");\n                                if (indexModified != null) {\n                                    if (DateField.stringToTime(indexModified)\n                                             == file.lastModified()) {\n                                        indexIt = false;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (indexIt) {\n                            try {\n                                log(\"Indexing \" + file.getPath(),\n                                    Project.MSG_VERBOSE);\n                                Document doc =\n                                         handler.getDocument(file);\n\n                                if (doc == null) {\n                                    totalIgnored++;\n                                }\n                                else {\n                                    // Add the path of the file as a field named \"path\".  Use a Text field, so\n                                    // that the index stores the path, and so that the path is searchable\n                                    doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                                    // Add the last modified date of the file a field named \"modified\".  Use a\n                                    // Keyword field, so that it's searchable, but so that no attempt is made\n                                    // to tokenize the field into words.\n                                    doc.add(Field.Keyword(\"modified\",\n                                            DateField.timeToString(file.lastModified())));\n\n                                    writer.addDocument(doc);\n                                    totalIndexed++;\n                                }\n                            }\n                            catch (DocumentHandlerException e) {\n                                throw new BuildException(e);\n                            }\n                        }\n                    }\n                    // for j\n                }\n                // if (fs != null)\n            }\n            // for i\n\n            writer.optimize();\n        }\n        //try\n        finally {\n            // always make sure everything gets closed,\n            // no matter how we exit.\n            writer.close();\n            if (searcher != null) {\n                searcher.close();\n            }\n        }\n\n        Date end = new Date();\n\n        log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n                totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n                \" milliseconds\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9809dc8ba717640d1ea75b2404405c49070a4e84":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6cae9303ec860d8a88b807570b29e841a3d1fbd3":["9809dc8ba717640d1ea75b2404405c49070a4e84"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6cae9303ec860d8a88b807570b29e841a3d1fbd3"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9809dc8ba717640d1ea75b2404405c49070a4e84"],"9809dc8ba717640d1ea75b2404405c49070a4e84":["6cae9303ec860d8a88b807570b29e841a3d1fbd3"],"6cae9303ec860d8a88b807570b29e841a3d1fbd3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}