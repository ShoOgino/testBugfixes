{"path":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public PriorityQueue(int maxSize, boolean prepopulate) {\n    size = 0;\n    int heapSize;\n    if (0 == maxSize)\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    else {\n      if (maxSize == Integer.MAX_VALUE) {\n        // Don't wrap heapSize to -1, in this case, which\n        // causes a confusing NegativeArraySizeException.\n        // Note that very likely this will simply then hit\n        // an OOME, but at least that's more indicative to\n        // caller that this values is too big.  We don't +1\n        // in this case, but it's very unlikely in practice\n        // one will actually insert this many objects into\n        // the PQ:\n        heapSize = Integer.MAX_VALUE;\n      } else {\n        // NOTE: we add +1 because all access to heap is\n        // 1-based not 0-based.  heap[0] is unused.\n        heapSize = maxSize + 1;\n      }\n    }\n    heap = (T[]) new Object[heapSize]; // T is unbounded type, so this unchecked cast works always\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public PriorityQueue(int maxSize, boolean prepopulate) {\n    size = 0;\n    int heapSize;\n    if (0 == maxSize)\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    else {\n      if (maxSize == Integer.MAX_VALUE) {\n        // Don't wrap heapSize to -1, in this case, which\n        // causes a confusing NegativeArraySizeException.\n        // Note that very likely this will simply then hit\n        // an OOME, but at least that's more indicative to\n        // caller that this values is too big.  We don't +1\n        // in this case, but it's very unlikely in practice\n        // one will actually insert this many objects into\n        // the PQ:\n        heapSize = Integer.MAX_VALUE;\n      } else {\n        // NOTE: we add +1 because all access to heap is\n        // 1-based not 0-based.  heap[0] is unused.\n        heapSize = maxSize + 1;\n      }\n    }\n    heap = (T[]) new Object[heapSize]; // T is unbounded type, so this unchecked cast works always\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"315919a79e7aa3e6f022989bd2e522b592695022","date":1390676968,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public PriorityQueue(int maxSize, boolean prepopulate) {\n    size = 0;\n    int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      if (maxSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Don't wrap heapSize to -1, in this case, which\n        // causes a confusing NegativeArraySizeException.\n        // Note that very likely this will simply then hit\n        // an OOME, but at least that's more indicative to\n        // caller that this values is too big.  We don't +1\n        // in this case, but it's very unlikely in practice\n        // one will actually insert this many objects into\n        // the PQ:\n    \t// Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + ArrayUtil.MAX_ARRAY_LENGTH + \"; got: \" + maxSize);\n      } else {\n        // NOTE: we add +1 because all access to heap is\n        // 1-based not 0-based.  heap[0] is unused.\n        heapSize = maxSize + 1;\n      }\n    }\n    heap = (T[]) new Object[heapSize]; // T is unbounded type, so this unchecked cast works always\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public PriorityQueue(int maxSize, boolean prepopulate) {\n    size = 0;\n    int heapSize;\n    if (0 == maxSize)\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    else {\n      if (maxSize == Integer.MAX_VALUE) {\n        // Don't wrap heapSize to -1, in this case, which\n        // causes a confusing NegativeArraySizeException.\n        // Note that very likely this will simply then hit\n        // an OOME, but at least that's more indicative to\n        // caller that this values is too big.  We don't +1\n        // in this case, but it's very unlikely in practice\n        // one will actually insert this many objects into\n        // the PQ:\n        heapSize = Integer.MAX_VALUE;\n      } else {\n        // NOTE: we add +1 because all access to heap is\n        // 1-based not 0-based.  heap[0] is unused.\n        heapSize = maxSize + 1;\n      }\n    }\n    heap = (T[]) new Object[heapSize]; // T is unbounded type, so this unchecked cast works always\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":["34086bd39404420e6e5699d7c5f35c1c146bb2a4","5241670df94f0524d3e8e9764331dea13b545564"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bddeb3d34346fb1d088ccf7c0508ff924bb62e84","date":1390683499,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public PriorityQueue(int maxSize, boolean prepopulate) {\n    size = 0;\n    int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      if (maxSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Don't wrap heapSize to -1, in this case, which\n        // causes a confusing NegativeArraySizeException.\n        // Note that very likely this will simply then hit\n        // an OOME, but at least that's more indicative to\n        // caller that this values is too big.  We don't +1\n        // in this case, but it's very unlikely in practice\n        // one will actually insert this many objects into\n        // the PQ:\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + ArrayUtil.MAX_ARRAY_LENGTH + \"; got: \" + maxSize);\n      } else {\n        // NOTE: we add +1 because all access to heap is\n        // 1-based not 0-based.  heap[0] is unused.\n        heapSize = maxSize + 1;\n      }\n    }\n    heap = (T[]) new Object[heapSize]; // T is unbounded type, so this unchecked cast works always\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public PriorityQueue(int maxSize, boolean prepopulate) {\n    size = 0;\n    int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      if (maxSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Don't wrap heapSize to -1, in this case, which\n        // causes a confusing NegativeArraySizeException.\n        // Note that very likely this will simply then hit\n        // an OOME, but at least that's more indicative to\n        // caller that this values is too big.  We don't +1\n        // in this case, but it's very unlikely in practice\n        // one will actually insert this many objects into\n        // the PQ:\n    \t// Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + ArrayUtil.MAX_ARRAY_LENGTH + \"; got: \" + maxSize);\n      } else {\n        // NOTE: we add +1 because all access to heap is\n        // 1-based not 0-based.  heap[0] is unused.\n        heapSize = maxSize + 1;\n      }\n    }\n    heap = (T[]) new Object[heapSize]; // T is unbounded type, so this unchecked cast works always\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4558c401885b6fabe5999579714fcb6ea844c82f","date":1394575769,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      if (maxSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Don't wrap heapSize to -1, in this case, which\n        // causes a confusing NegativeArraySizeException.\n        // Note that very likely this will simply then hit\n        // an OOME, but at least that's more indicative to\n        // caller that this values is too big.  We don't +1\n        // in this case, but it's very unlikely in practice\n        // one will actually insert this many objects into\n        // the PQ:\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + ArrayUtil.MAX_ARRAY_LENGTH + \"; got: \" + maxSize);\n      } else {\n        // NOTE: we add +1 because all access to heap is\n        // 1-based not 0-based.  heap[0] is unused.\n        heapSize = maxSize + 1;\n      }\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public PriorityQueue(int maxSize, boolean prepopulate) {\n    size = 0;\n    int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      if (maxSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Don't wrap heapSize to -1, in this case, which\n        // causes a confusing NegativeArraySizeException.\n        // Note that very likely this will simply then hit\n        // an OOME, but at least that's more indicative to\n        // caller that this values is too big.  We don't +1\n        // in this case, but it's very unlikely in practice\n        // one will actually insert this many objects into\n        // the PQ:\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + ArrayUtil.MAX_ARRAY_LENGTH + \"; got: \" + maxSize);\n      } else {\n        // NOTE: we add +1 because all access to heap is\n        // 1-based not 0-based.  heap[0] is unused.\n        heapSize = maxSize + 1;\n      }\n    }\n    heap = (T[]) new Object[heapSize]; // T is unbounded type, so this unchecked cast works always\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56f04ece188fdfbd96973fde3e6ba7a6fbaaada","date":1406145387,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n\n      if (heapSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + (ArrayUtil.MAX_ARRAY_LENGTH-1) + \"; got: \" + maxSize);\n      }\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","sourceOld":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      if (maxSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Don't wrap heapSize to -1, in this case, which\n        // causes a confusing NegativeArraySizeException.\n        // Note that very likely this will simply then hit\n        // an OOME, but at least that's more indicative to\n        // caller that this values is too big.  We don't +1\n        // in this case, but it's very unlikely in practice\n        // one will actually insert this many objects into\n        // the PQ:\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + ArrayUtil.MAX_ARRAY_LENGTH + \"; got: \" + maxSize);\n      } else {\n        // NOTE: we add +1 because all access to heap is\n        // 1-based not 0-based.  heap[0] is unused.\n        heapSize = maxSize + 1;\n      }\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac8ce4febd838561b4317a75f81313066e6d91c3","date":1449851410,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n\n      if (heapSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + (ArrayUtil.MAX_ARRAY_LENGTH-1) + \"; got: \" + maxSize);\n      }\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n\n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","sourceOld":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n\n      if (heapSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + (ArrayUtil.MAX_ARRAY_LENGTH-1) + \"; got: \" + maxSize);\n      }\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n    \n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"456c216c84084d63bc5c6dbd0a1a994621b4f96b","date":1530202278,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n\n      if ((maxSize < 0) || (maxSize >= ArrayUtil.MAX_ARRAY_LENGTH)) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be >= 0 and < \" + (ArrayUtil.MAX_ARRAY_LENGTH) + \"; got: \" + maxSize);\n      }\n\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n\n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","sourceOld":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n\n      if (heapSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + (ArrayUtil.MAX_ARRAY_LENGTH-1) + \"; got: \" + maxSize);\n      }\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n\n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n\n      if ((maxSize < 0) || (maxSize >= ArrayUtil.MAX_ARRAY_LENGTH)) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be >= 0 and < \" + (ArrayUtil.MAX_ARRAY_LENGTH) + \"; got: \" + maxSize);\n      }\n\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n\n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","sourceOld":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n\n      if (heapSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + (ArrayUtil.MAX_ARRAY_LENGTH-1) + \"; got: \" + maxSize);\n      }\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n\n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n\n      if ((maxSize < 0) || (maxSize >= ArrayUtil.MAX_ARRAY_LENGTH)) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be >= 0 and < \" + (ArrayUtil.MAX_ARRAY_LENGTH) + \"; got: \" + maxSize);\n      }\n\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n\n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","sourceOld":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n\n      if (heapSize > ArrayUtil.MAX_ARRAY_LENGTH) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be <= \" + (ArrayUtil.MAX_ARRAY_LENGTH-1) + \"; got: \" + maxSize);\n      }\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n\n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f","date":1532682688,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,boolean).mjava","sourceNew":null,"sourceOld":"  public PriorityQueue(int maxSize, boolean prepopulate) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n\n      if ((maxSize < 0) || (maxSize >= ArrayUtil.MAX_ARRAY_LENGTH)) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be >= 0 and < \" + (ArrayUtil.MAX_ARRAY_LENGTH) + \"; got: \" + maxSize);\n      }\n\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n\n    if (prepopulate) {\n      // If sentinel objects are supported, populate the queue with them\n      T sentinel = getSentinelObject();\n      if (sentinel != null) {\n        heap[1] = sentinel;\n        for (int i = 2; i < heap.length; i++) {\n          heap[i] = getSentinelObject();\n        }\n        size = maxSize;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f56f04ece188fdfbd96973fde3e6ba7a6fbaaada":["4558c401885b6fabe5999579714fcb6ea844c82f"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["ac8ce4febd838561b4317a75f81313066e6d91c3","456c216c84084d63bc5c6dbd0a1a994621b4f96b"],"456c216c84084d63bc5c6dbd0a1a994621b4f96b":["ac8ce4febd838561b4317a75f81313066e6d91c3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f":["456c216c84084d63bc5c6dbd0a1a994621b4f96b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ac8ce4febd838561b4317a75f81313066e6d91c3":["f56f04ece188fdfbd96973fde3e6ba7a6fbaaada"],"4558c401885b6fabe5999579714fcb6ea844c82f":["bddeb3d34346fb1d088ccf7c0508ff924bb62e84"],"bddeb3d34346fb1d088ccf7c0508ff924bb62e84":["315919a79e7aa3e6f022989bd2e522b592695022"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f"],"315919a79e7aa3e6f022989bd2e522b592695022":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["ac8ce4febd838561b4317a75f81313066e6d91c3","456c216c84084d63bc5c6dbd0a1a994621b4f96b"]},"commit2Childs":{"f56f04ece188fdfbd96973fde3e6ba7a6fbaaada":["ac8ce4febd838561b4317a75f81313066e6d91c3"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"456c216c84084d63bc5c6dbd0a1a994621b4f96b":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["315919a79e7aa3e6f022989bd2e522b592695022"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ac8ce4febd838561b4317a75f81313066e6d91c3":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","456c216c84084d63bc5c6dbd0a1a994621b4f96b","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"4558c401885b6fabe5999579714fcb6ea844c82f":["f56f04ece188fdfbd96973fde3e6ba7a6fbaaada"],"bddeb3d34346fb1d088ccf7c0508ff924bb62e84":["4558c401885b6fabe5999579714fcb6ea844c82f"],"315919a79e7aa3e6f022989bd2e522b592695022":["bddeb3d34346fb1d088ccf7c0508ff924bb62e84"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}