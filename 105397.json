{"path":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","commits":[{"id":"0eff89b16ebd0046c839c5d02ee44500be5c7886","date":1355766557,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = atLeast(3);\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      collectionClient.setConnectionTimeout(20000);\n      collectionClient.setSoTimeout(60000);\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"/dev/null","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cfa38e36fa296bb93d77df7d5556257dffa4535","date":1362635543,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = ((HttpSolrServer) clients.get(0)).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) clients.get(0)).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe999fc2d95d6fea71f960bf9556858387ba21f5","date":1363294860,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n    } finally {\n      client.shutdown();\n    }\n    \n    // TODO: REMOVE THE SLEEP IN THE METHOD CALL WHEN WE HAVE COLLECTION API \n    // RESPONSES\n    checkCollectionIsNotCreated(collectionInfos.keySet().iterator().next());\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1eeda7e62e149f90eee8895af874c74efa7d4852","date":1375293182,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(OverseerCollectionProcessor.REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d642fe6577db47788146c0fc4fe14240ab1718b7","date":1376680349,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a82d855abc18f7ee3e1ec359d8f256c8c86977a","date":1381347960,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        \n        createCollection(collectionInfos, \"awholynewcollection_\" + i,\n            numShards, replicationFactor, maxShardsPerNode, client, null);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + cnt, numShards, replicationFactor, maxShardsPerNode, client, null);\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','));\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":["d334938e866757266d62025305edd378ac505a06","9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcb5de84d260a8919bf0f2d4d180df543a2ad07a","date":1381378233,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"270612d8e1a51cded91704d7af12f8979de0f584","date":1381502089,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"286db2cd7d8d9e3b02a5b51a58c2b18ce404f9aa","date":1386082542,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = _TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"840fc95f31a25d020cd825e880018bcfa0bacc71","date":1393483822,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if(disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":["eb4db141b31e99d2285436da1428411ed5501f56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","date":1393532551,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if(disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n \n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb4db141b31e99d2285436da1428411ed5501f56","date":1394114795,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if(disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":["840fc95f31a25d020cd825e880018bcfa0bacc71"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b51e891605604cf911ab579fb28c49b26749f93","date":1394126258,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if(disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if(disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<String,Long>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<Integer> (2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<String>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<String,List<Integer>>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8f0529666139e562ee655d544b667bfedab70c7","date":1394717900,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3a46663789411cdf016145a96a40cf861798ae3","date":1395119088,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(NUM_SLICES, 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(COLLECTION_CONFIG_NAME, \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"963b0a9b072593721af39e1d9b815fba17e88e7f","date":1395120846,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(NUM_SLICES, 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(COLLECTION_CONFIG_NAME, \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c7856260bc28f285ae7bfefa99b28db4dca6daf","date":1395253500,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70425c0eec3ca096a4265143bd0ea238b9fc66cc","date":1395639584,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 3) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrClient collectionClient = new HttpSolrClient(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    createNewSolrClient(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrClient(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrClient(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrClient(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrClient(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrServer client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrServer collectionClient = new HttpSolrServer(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrServer) clients.get(0));\n    \n    createNewSolrServer(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrServer(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrServer(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrServer client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrServer().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrClient collectionClient = new HttpSolrClient(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrClient(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrClient collectionClient = new HttpSolrClient(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    createNewSolrClient(\"\", baseUrl).request(request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    createNewSolrClient(\"\", baseUrl).request(request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      createNewSolrClient(\"\", baseUrl).request(request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrClient(\"\", baseUrl).request(request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrClient(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrClient collectionClient = new HttpSolrClient(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrClient(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, shardCount) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrClient collectionClient = new HttpSolrClient(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrClient(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n      \n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        HttpSolrClient collectionClient = new HttpSolrClient(url);\n        \n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n        collectionClient.shutdown();\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n    \n    \n    // lets try and use the solrj client to index a couple documents\n    SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\");\n    SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\");\n    SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\");\n\n    collectionClient.add(doc1);\n    \n    collectionClient.add(doc2);\n\n    collectionClient.add(doc3);\n    \n    collectionClient.commit();\n    \n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    collectionClient = new HttpSolrClient(url);\n    \n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n    collectionClient.shutdown();\n    collectionClient = null;\n    \n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt);\n    try {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    } finally {\n      client.shutdown();\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n    client = createCloudClient(\"awholynewcollection_\" + (cnt+1));\n    try {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    } finally {\n      client.shutdown();\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9bc766d645fa848f86c381c7f6acf2c881c99399","date":1425549246,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"234afba21d42e6c527535c6aa11baba09a4771f3","date":1432825127,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    assertCollectionNotExists(collectionName, 45);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    checkForMissingCollection(collectionName);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    assertCollectionNotExists(collectionName, 45);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    assertCollectionNotExists(collectionName, 45);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    assertCollectionNotExists(collectionName, 45);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    assertCollectionNotExists(collectionName, 45);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4efd3fffdd7acd625bb88e455c8097e17f75735","date":1477647201,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    assertEquals(3, cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    assertCollectionNotExists(collectionName, 45);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["8bfd562efb18c4452dfe3acc3cb6f1e24d864f2a","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"59dce44d6a0b58c171de1d47ad8c0a75831f94fd","date":1477668573,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    assertEquals(3, cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  private void testCollectionsAPI() throws Exception {\n\n    boolean disableLegacy = random().nextBoolean();\n    CloudSolrClient client1 = null;\n\n    if (disableLegacy) {\n      log.info(\"legacyCloud=false\");\n      client1 = createCloudClient(null);\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, \"false\");\n    }\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or \n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n    \n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    \n    for (int i = 0; i < cnt; i++) {\n      int numShards = TestUtil.nextInt(random(), 0, getShardCount()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      \n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(\"awholynewcollection_\" + i);\n        }\n        if (secondConfigSet) {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null, \"conf2\");\n        } else {\n          createCollection(collectionInfos, \"awholynewcollection_\" + i,\n              numShards, replicationFactor, maxShardsPerNode, client, null);\n        }\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n    \n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n      \n      String url = getUrlFromZk(collection);\n\n      try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    \n    // sometimes we restart one of the jetty nodes\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.stop(jetty);\n      log.info(\"============ Restarting jetty\");\n      ChaosMonkey.start(jetty);\n      \n      for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n        String collection = entry.getKey();\n        List<Integer> list = entry.getValue();\n        checkForCollection(collection, list, null);\n        \n        String url = getUrlFromZk(collection);\n        \n        try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n          // poll for a second - it can take a moment before we are ready to serve\n          waitForNon403or404or503(collectionClient);\n        }\n      }\n    }\n\n    // sometimes we restart zookeeper\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      log.info(\"============ Restarting zookeeper\");\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    // sometimes we cause a connection loss - sometimes it will hit the overseer\n    if (random().nextBoolean()) {\n      JettySolrRunner jetty = jettys.get(random().nextInt(jettys.size()));\n      ChaosMonkey.causeConnectionLoss(jetty);\n    }\n    \n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(\"awholynewcollection_\" + j, zkStateReader, false);\n      \n      if (secondConfigSet) {\n        // let's see if they are using the second config set\n        byte[] data = zkStateReader.getZkClient()\n            .getData(\n                ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + \"awholynewcollection_\"\n                    + j, null, null, true);\n        assertNotNull(data);\n        ZkNodeProps props = ZkNodeProps.load(data);\n        String configName = props.getStr(ZkController.CONFIGNAME_PROP);\n        assertEquals(\"conf2\", configName);\n        \n      }\n    }\n    \n    checkInstanceDirs(jettys.get(0)); \n    \n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n    \n    String url = getUrlFromZk(collectionName);\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n      SolrInputDocument doc1 = getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\");\n      SolrInputDocument doc2 = getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\");\n      SolrInputDocument doc3 = getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\");\n\n      collectionClient.add(doc1);\n\n      collectionClient.add(doc2);\n\n      collectionClient.add(doc3);\n\n      collectionClient.commit();\n\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    // lets try a collection reload\n    \n    // get core open times\n    Map<String,Long> urlToTimeBefore = new HashMap<>();\n    collectStartTimes(collectionName, urlToTimeBefore);\n    assertTrue(urlToTimeBefore.size() > 0);\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.RELOAD.toString());\n    params.set(\"name\", collectionName);\n    QueryRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    // we can use this client because we just want base url\n    final String baseUrl = getBaseUrl((HttpSolrClient) clients.get(0));\n    \n    makeRequest(baseUrl, request);\n\n    // reloads make take a short while\n    boolean allTimesAreCorrect = waitForReloads(collectionName, urlToTimeBefore);\n    assertTrue(\"some core start times did not change on reload\", allTimesAreCorrect);\n    \n    \n    waitForRecoveriesToFinish(\"awholynewcollection_\" + (cnt - 1), zkStateReader, false);\n    \n    // remove a collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", collectionName);\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    makeRequest(baseUrl, request);\n    \n    // ensure its out of the state\n    assertCollectionNotExists(collectionName, 45);\n    \n    //collectionNameList.remove(collectionName);\n\n    // remove an unknown collection\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.DELETE.toString());\n    params.set(\"name\", \"unknown_collection\");\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n \n    boolean exp = false;\n    try {\n      makeRequest(baseUrl, request);\n    } catch (SolrException e) {\n      exp = true;\n    }\n    assertTrue(\"Expected exception\", exp);\n    \n    // create another collection should still work\n    params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATE.toString());\n\n    params.set(\"numShards\", 1);\n    params.set(REPLICATION_FACTOR, 2);\n    collectionName = \"acollectionafterbaddelete\";\n\n    params.set(\"name\", collectionName);\n    if (secondConfigSet) {\n      params.set(\"collection.configName\", \"conf1\");\n    }\n    request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    makeRequest(baseUrl, request);\n    \n    List<Integer> list = new ArrayList<>(2);\n    list.add(1);\n    list.add(2);\n    checkForCollection(collectionName, list, null);\n    \n    url = getUrlFromZk(collectionName);\n    \n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(collectionName, zkStateReader, false);\n    }\n\n    // test maxShardsPerNode\n    int numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    int numShards = (numLiveNodes/2) + 1;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    collectionInfos = new HashMap<>();\n    try (CloudSolrClient client = createCloudClient(\"awholynewcollection_\" + cnt)) {\n      exp = false;\n      try {\n        createCollection(collectionInfos, \"awholynewcollection_\" + cnt,\n            numShards, replicationFactor, maxShardsPerNode, client, null, \"conf1\");\n      } catch (SolrException e) {\n        exp = true;\n      }\n      assertTrue(\"expected exception\", exp);\n    }\n\n    \n    // Test createNodeSet\n    numLiveNodes = getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes().size();\n    List<String> createNodeList = new ArrayList<>();\n    int numOfCreateNodes = numLiveNodes/2;\n    assertFalse(\"createNodeSet test is pointless with only \" + numLiveNodes + \" nodes running\", numOfCreateNodes == 0);\n    int i = 0;\n    for (String liveNode : getCommonCloudSolrClient().getZkStateReader().getClusterState().getLiveNodes()) {\n      if (i < numOfCreateNodes) {\n        createNodeList.add(liveNode);\n        i++;\n      } else {\n        break;\n      }\n    }\n    maxShardsPerNode = 2;\n    numShards = createNodeList.size() * maxShardsPerNode;\n    replicationFactor = 1;\n    collectionInfos = new HashMap<>();\n\n    try (SolrClient client = createCloudClient(\"awholynewcollection_\" + (cnt+1))) {\n      CollectionAdminResponse res = createCollection(collectionInfos, \"awholynewcollection_\" + (cnt+1), numShards, replicationFactor, maxShardsPerNode, client, StrUtils.join(createNodeList, ','), \"conf1\");\n      assertTrue(res.isSuccess());\n    }\n    checkForCollection(collectionInfos.keySet().iterator().next(), collectionInfos.entrySet().iterator().next().getValue(), createNodeList);\n    \n    checkNoTwoShardsUseTheSameIndexDir();\n    if(disableLegacy) {\n      setClusterProp(client1, ZkStateReader.LEGACY_CLOUD, null);\n      client1.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61118c6bab4aec08950461e2765c8a86ddf0b205","date":1487384563,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    assertEquals(3, cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 6 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    assertEquals(3, cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8bfd562efb18c4452dfe3acc3cb6f1e24d864f2a","date":1509415982,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    assertEquals(3, cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":["a4efd3fffdd7acd625bb88e455c8097e17f75735"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a4efd3fffdd7acd625bb88e455c8097e17f75735":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"270612d8e1a51cded91704d7af12f8979de0f584":["dcb5de84d260a8919bf0f2d4d180df543a2ad07a"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0eff89b16ebd0046c839c5d02ee44500be5c7886"],"b94236357aaa22b76c10629851fe4e376e0cea82":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["840fc95f31a25d020cd825e880018bcfa0bacc71","eb4db141b31e99d2285436da1428411ed5501f56"],"6b51e891605604cf911ab579fb28c49b26749f93":["840fc95f31a25d020cd825e880018bcfa0bacc71","eb4db141b31e99d2285436da1428411ed5501f56"],"d3a46663789411cdf016145a96a40cf861798ae3":["e8f0529666139e562ee655d544b667bfedab70c7"],"abb23fcc2461782ab204e61213240feb77d355aa":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["0eff89b16ebd0046c839c5d02ee44500be5c7886"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["234afba21d42e6c527535c6aa11baba09a4771f3"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"bafca15d8e408346a67f4282ad1143b88023893b":["70425c0eec3ca096a4265143bd0ea238b9fc66cc"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["fe999fc2d95d6fea71f960bf9556858387ba21f5"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":["6613659748fe4411a7dcf85266e55db1f95f7315","840fc95f31a25d020cd825e880018bcfa0bacc71"],"5a82d855abc18f7ee3e1ec359d8f256c8c86977a":["d642fe6577db47788146c0fc4fe14240ab1718b7"],"963b0a9b072593721af39e1d9b815fba17e88e7f":["d3a46663789411cdf016145a96a40cf861798ae3"],"d642fe6577db47788146c0fc4fe14240ab1718b7":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["cc3b13b430571c2e169f98fe38e1e7666f88522d","9bc766d645fa848f86c381c7f6acf2c881c99399"],"dcb5de84d260a8919bf0f2d4d180df543a2ad07a":["5a82d855abc18f7ee3e1ec359d8f256c8c86977a"],"234afba21d42e6c527535c6aa11baba09a4771f3":["9bc766d645fa848f86c381c7f6acf2c881c99399"],"0eff89b16ebd0046c839c5d02ee44500be5c7886":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["abb23fcc2461782ab204e61213240feb77d355aa"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["8bfd562efb18c4452dfe3acc3cb6f1e24d864f2a"],"61118c6bab4aec08950461e2765c8a86ddf0b205":["a4efd3fffdd7acd625bb88e455c8097e17f75735"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["bafca15d8e408346a67f4282ad1143b88023893b"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["eb4db141b31e99d2285436da1428411ed5501f56"],"59dce44d6a0b58c171de1d47ad8c0a75831f94fd":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","a4efd3fffdd7acd625bb88e455c8097e17f75735"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["fe999fc2d95d6fea71f960bf9556858387ba21f5","1eeda7e62e149f90eee8895af874c74efa7d4852"],"eb4db141b31e99d2285436da1428411ed5501f56":["840fc95f31a25d020cd825e880018bcfa0bacc71"],"6613659748fe4411a7dcf85266e55db1f95f7315":["286db2cd7d8d9e3b02a5b51a58c2b18ce404f9aa"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","d642fe6577db47788146c0fc4fe14240ab1718b7"],"31d4861802ca404d78ca1d15f4550eec415b9199":["1eeda7e62e149f90eee8895af874c74efa7d4852","d642fe6577db47788146c0fc4fe14240ab1718b7"],"8bfd562efb18c4452dfe3acc3cb6f1e24d864f2a":["61118c6bab4aec08950461e2765c8a86ddf0b205"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"fe999fc2d95d6fea71f960bf9556858387ba21f5":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"840fc95f31a25d020cd825e880018bcfa0bacc71":["6613659748fe4411a7dcf85266e55db1f95f7315"],"e8f0529666139e562ee655d544b667bfedab70c7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["963b0a9b072593721af39e1d9b815fba17e88e7f"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["234afba21d42e6c527535c6aa11baba09a4771f3","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["270612d8e1a51cded91704d7af12f8979de0f584","286db2cd7d8d9e3b02a5b51a58c2b18ce404f9aa"],"286db2cd7d8d9e3b02a5b51a58c2b18ce404f9aa":["270612d8e1a51cded91704d7af12f8979de0f584"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"],"70425c0eec3ca096a4265143bd0ea238b9fc66cc":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"]},"commit2Childs":{"a4efd3fffdd7acd625bb88e455c8097e17f75735":["61118c6bab4aec08950461e2765c8a86ddf0b205","59dce44d6a0b58c171de1d47ad8c0a75831f94fd"],"270612d8e1a51cded91704d7af12f8979de0f584":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","286db2cd7d8d9e3b02a5b51a58c2b18ce404f9aa"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"6b51e891605604cf911ab579fb28c49b26749f93":[],"d3a46663789411cdf016145a96a40cf861798ae3":["963b0a9b072593721af39e1d9b815fba17e88e7f"],"abb23fcc2461782ab204e61213240feb77d355aa":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["fe999fc2d95d6fea71f960bf9556858387ba21f5"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","234afba21d42e6c527535c6aa11baba09a4771f3"],"bafca15d8e408346a67f4282ad1143b88023893b":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["d642fe6577db47788146c0fc4fe14240ab1718b7","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","31d4861802ca404d78ca1d15f4550eec415b9199"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":[],"5a82d855abc18f7ee3e1ec359d8f256c8c86977a":["dcb5de84d260a8919bf0f2d4d180df543a2ad07a"],"963b0a9b072593721af39e1d9b815fba17e88e7f":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"],"d642fe6577db47788146c0fc4fe14240ab1718b7":["5a82d855abc18f7ee3e1ec359d8f256c8c86977a","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"dcb5de84d260a8919bf0f2d4d180df543a2ad07a":["270612d8e1a51cded91704d7af12f8979de0f584"],"234afba21d42e6c527535c6aa11baba09a4771f3":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","0eff89b16ebd0046c839c5d02ee44500be5c7886"],"0eff89b16ebd0046c839c5d02ee44500be5c7886":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","1cfa38e36fa296bb93d77df7d5556257dffa4535"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["9bc766d645fa848f86c381c7f6acf2c881c99399","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"61118c6bab4aec08950461e2765c8a86ddf0b205":["8bfd562efb18c4452dfe3acc3cb6f1e24d864f2a"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["abb23fcc2461782ab204e61213240feb77d355aa"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["e8f0529666139e562ee655d544b667bfedab70c7"],"59dce44d6a0b58c171de1d47ad8c0a75831f94fd":[],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"eb4db141b31e99d2285436da1428411ed5501f56":["96ea64d994d340044e0d57aeb6a5871539d10ca5","6b51e891605604cf911ab579fb28c49b26749f93","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"6613659748fe4411a7dcf85266e55db1f95f7315":["13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","840fc95f31a25d020cd825e880018bcfa0bacc71"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"8bfd562efb18c4452dfe3acc3cb6f1e24d864f2a":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"fe999fc2d95d6fea71f960bf9556858387ba21f5":["1eeda7e62e149f90eee8895af874c74efa7d4852","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"840fc95f31a25d020cd825e880018bcfa0bacc71":["96ea64d994d340044e0d57aeb6a5871539d10ca5","6b51e891605604cf911ab579fb28c49b26749f93","13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","eb4db141b31e99d2285436da1428411ed5501f56"],"e8f0529666139e562ee655d544b667bfedab70c7":["d3a46663789411cdf016145a96a40cf861798ae3"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["70425c0eec3ca096a4265143bd0ea238b9fc66cc"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["a4efd3fffdd7acd625bb88e455c8097e17f75735","59dce44d6a0b58c171de1d47ad8c0a75831f94fd"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"286db2cd7d8d9e3b02a5b51a58c2b18ce404f9aa":["6613659748fe4411a7dcf85266e55db1f95f7315","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"70425c0eec3ca096a4265143bd0ea238b9fc66cc":["bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","96ea64d994d340044e0d57aeb6a5871539d10ca5","6b51e891605604cf911ab579fb28c49b26749f93","13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","59dce44d6a0b58c171de1d47ad8c0a75831f94fd","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}