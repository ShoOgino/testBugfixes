{"path":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    int flags = CachedArrayCreator.CACHE_VALUES_AND_BITS;\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( new IntValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_INT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( new FloatValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_FLOAT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( new LongValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_LONG_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( new DoubleValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    int flags = CachedArrayCreator.CACHE_VALUES_AND_BITS;\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( new IntValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_INT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( new FloatValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_FLOAT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( new LongValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_LONG_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( new DoubleValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    int flags = CachedArrayCreator.CACHE_VALUES_AND_BITS;\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( new IntValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_INT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( new FloatValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_FLOAT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( new LongValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_LONG_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( new DoubleValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    int flags = CachedArrayCreator.CACHE_VALUES_AND_BITS;\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( new IntValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_INT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( new FloatValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_FLOAT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( new LongValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_LONG_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( new DoubleValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    int flags = CachedArrayCreator.CACHE_VALUES_AND_BITS;\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( new IntValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_INT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( new FloatValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_FLOAT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( new LongValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_LONG_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( new DoubleValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    int flags = CachedArrayCreator.CACHE_VALUES_AND_BITS;\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( new IntValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_INT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( new FloatValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_FLOAT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( new LongValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_LONG_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( new DoubleValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"382fe3a6ca9745891afebda9b9a57cc158305545","date":1320952430,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_INT_PARSER, top).setMissingValue(missingValue);\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_FLOAT_PARSER, top).setMissingValue(missingValue);\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_LONG_PARSER, top).setMissingValue(missingValue);\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, top).setMissingValue(missingValue);\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    int flags = CachedArrayCreator.CACHE_VALUES_AND_BITS;\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( new IntValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_INT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( new FloatValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_FLOAT_PARSER, flags ), top).setMissingValue( missingValue );\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( new LongValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_LONG_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( new DoubleValuesCreator( field.getName(), \n            FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, flags ), top).setMissingValue( missingValue );\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7615b855702e008d91a95a2578bf05d27372f599","date":1389802891,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_INT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_FLOAT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_LONG_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_INT_PARSER, top).setMissingValue(missingValue);\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_FLOAT_PARSER, top).setMissingValue(missingValue);\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_LONG_PARSER, top).setMissingValue(missingValue);\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, top).setMissingValue(missingValue);\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":["70052d44b40be0028db94b4cffeb9aaa5468055e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27ab7b234eab0cbc020836989b96ed430e1065bb","date":1389894025,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_INT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_FLOAT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_LONG_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n    \n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_INT_PARSER, top).setMissingValue(missingValue);\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_FLOAT_PARSER, top).setMissingValue(missingValue);\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_LONG_PARSER, top).setMissingValue(missingValue);\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        return new SortField( field.getName(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, top).setMissingValue(missingValue);\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.INT, top, FieldCache.NUMERIC_UTILS_INT_PARSER);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.FLOAT, top, FieldCache.NUMERIC_UTILS_FLOAT_PARSER);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.LONG, top, FieldCache.NUMERIC_UTILS_LONG_PARSER);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.DOUBLE, top, FieldCache.NUMERIC_UTILS_DOUBLE_PARSER);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_INT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_FLOAT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_LONG_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e28b14e7783d24ca69089f13ddadadbd2afdcb29","date":1399840701,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.INT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.FLOAT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.LONG, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.DOUBLE, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.INT, top, FieldCache.NUMERIC_UTILS_INT_PARSER);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.FLOAT, top, FieldCache.NUMERIC_UTILS_FLOAT_PARSER);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.LONG, top, FieldCache.NUMERIC_UTILS_LONG_PARSER);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.DOUBLE, top, FieldCache.NUMERIC_UTILS_DOUBLE_PARSER);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":["70052d44b40be0028db94b4cffeb9aaa5468055e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.INT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.FLOAT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.LONG, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.DOUBLE, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_INT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_FLOAT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_LONG_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.INT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.FLOAT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.LONG, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.DOUBLE, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_INT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_FLOAT_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_LONG_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70052d44b40be0028db94b4cffeb9aaa5468055e","date":1505151510,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        return getSortField(field, SortField.Type.INT, top, Integer.MIN_VALUE, Integer.MAX_VALUE);\n      case FLOAT:\n        return getSortField(field, SortField.Type.FLOAT, top, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);\n      case DATE: // fallthrough\n      case LONG:\n        return getSortField(field, SortField.Type.LONG, top, Long.MIN_VALUE, Long.MAX_VALUE);\n      case DOUBLE:\n        return getSortField(field, SortField.Type.DOUBLE, top, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.INT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.FLOAT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.LONG, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.DOUBLE, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":["7615b855702e008d91a95a2578bf05d27372f599","e28b14e7783d24ca69089f13ddadadbd2afdcb29","b967739c936b1616f0a7ed24fe5f046dfa7559ca"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ffb85feece8645a035c02443a625f5af15e1106b","date":1505219692,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        return getSortField(field, SortField.Type.INT, top, Integer.MIN_VALUE, Integer.MAX_VALUE);\n      case FLOAT:\n        return getSortField(field, SortField.Type.FLOAT, top, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);\n      case DATE: // fallthrough\n      case LONG:\n        return getSortField(field, SortField.Type.LONG, top, Long.MIN_VALUE, Long.MAX_VALUE);\n      case DOUBLE:\n        return getSortField(field, SortField.Type.DOUBLE, top, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.INT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.FLOAT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.LONG, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.DOUBLE, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"685bd38810c206c93e9058f3c2cfa9827c086c27","date":1505751821,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        return getSortField(field, SortField.Type.INT, top, Integer.MIN_VALUE, Integer.MAX_VALUE);\n      case FLOAT:\n        return getSortField(field, SortField.Type.FLOAT, top, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);\n      case DATE: // fallthrough\n      case LONG:\n        return getSortField(field, SortField.Type.LONG, top, Long.MIN_VALUE, Long.MAX_VALUE);\n      case DOUBLE:\n        return getSortField(field, SortField.Type.DOUBLE, top, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        if( sortMissingLast ) {\n          missingValue = top ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.INT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case FLOAT:\n        if( sortMissingLast ) {\n          missingValue = top ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.FLOAT, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n      \n      case DATE: // fallthrough\n      case LONG:\n        if( sortMissingLast ) {\n          missingValue = top ? Long.MIN_VALUE : Long.MAX_VALUE;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Long.MAX_VALUE : Long.MIN_VALUE;\n        }\n        sf = new SortField( field.getName(), SortField.Type.LONG, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      case DOUBLE:\n        if( sortMissingLast ) {\n          missingValue = top ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n        else if( sortMissingFirst ) {\n          missingValue = top ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n        sf = new SortField( field.getName(), SortField.Type.DOUBLE, top);\n        sf.setMissingValue(missingValue);\n        return sf;\n        \n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cf2282b6a7c3f113e7a233b785b80527c03d590","date":1516129064,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean reverse) {\n    // NOTE: can't use getNumericSort because our multivalued case is special: we use SortedSet\n\n    if (field.multiValued()) {\n      MultiValueSelector selector = field.type.getDefaultMultiValueSelectorForSort(field, reverse);\n      if (null != selector) {\n        return getSortedSetSortField(field, selector.getSortedSetSelectorType(),\n                                     // yes: we really want Strings here, regardless of NumberType\n                                     reverse, SortField.STRING_FIRST, SortField.STRING_LAST);\n      }\n    }\n    \n    // else...\n    // either single valued, or don't support implicit multi selector\n    // (in which case let getSortField() give the error)\n    NumberType type = getNumberType();\n    return getSortField(field, type.sortType, reverse, type.sortMissingLow, type.sortMissingHigh);\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        return getSortField(field, SortField.Type.INT, top, Integer.MIN_VALUE, Integer.MAX_VALUE);\n      case FLOAT:\n        return getSortField(field, SortField.Type.FLOAT, top, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);\n      case DATE: // fallthrough\n      case LONG:\n        return getSortField(field, SortField.Type.LONG, top, Long.MIN_VALUE, Long.MAX_VALUE);\n      case DOUBLE:\n        return getSortField(field, SortField.Type.DOUBLE, top, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getSortField(SchemaField,boolean).mjava","sourceNew":"  @Override\n  public SortField getSortField(SchemaField field, boolean reverse) {\n    // NOTE: can't use getNumericSort because our multivalued case is special: we use SortedSet\n\n    if (field.multiValued()) {\n      MultiValueSelector selector = field.type.getDefaultMultiValueSelectorForSort(field, reverse);\n      if (null != selector) {\n        return getSortedSetSortField(field, selector.getSortedSetSelectorType(),\n                                     // yes: we really want Strings here, regardless of NumberType\n                                     reverse, SortField.STRING_FIRST, SortField.STRING_LAST);\n      }\n    }\n    \n    // else...\n    // either single valued, or don't support implicit multi selector\n    // (in which case let getSortField() give the error)\n    NumberType type = getNumberType();\n    return getSortField(field, type.sortType, reverse, type.sortMissingLow, type.sortMissingHigh);\n  }\n\n","sourceOld":"  @Override\n  public SortField getSortField(SchemaField field, boolean top) {\n    field.checkSortability();\n\n    Object missingValue = null;\n    boolean sortMissingLast  = field.sortMissingLast();\n    boolean sortMissingFirst = field.sortMissingFirst();\n\n    SortField sf;\n\n    switch (type) {\n      case INTEGER:\n        return getSortField(field, SortField.Type.INT, top, Integer.MIN_VALUE, Integer.MAX_VALUE);\n      case FLOAT:\n        return getSortField(field, SortField.Type.FLOAT, top, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);\n      case DATE: // fallthrough\n      case LONG:\n        return getSortField(field, SortField.Type.LONG, top, Long.MIN_VALUE, Long.MAX_VALUE);\n      case DOUBLE:\n        return getSortField(field, SortField.Type.DOUBLE, top, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n      default:\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown type for trie field: \" + field.name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["ffb85feece8645a035c02443a625f5af15e1106b","4cf2282b6a7c3f113e7a233b785b80527c03d590"],"ffb85feece8645a035c02443a625f5af15e1106b":["93dd449115a9247533e44bab47e8429e5dccbc6d","70052d44b40be0028db94b4cffeb9aaa5468055e"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["382fe3a6ca9745891afebda9b9a57cc158305545","7615b855702e008d91a95a2578bf05d27372f599"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"70052d44b40be0028db94b4cffeb9aaa5468055e":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"382fe3a6ca9745891afebda9b9a57cc158305545":["c26f00b574427b55127e869b935845554afde1fa"],"56572ec06f1407c066d6b7399413178b33176cd8":["27ab7b234eab0cbc020836989b96ed430e1065bb","93dd449115a9247533e44bab47e8429e5dccbc6d"],"685bd38810c206c93e9058f3c2cfa9827c086c27":["93dd449115a9247533e44bab47e8429e5dccbc6d","ffb85feece8645a035c02443a625f5af15e1106b"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["27ab7b234eab0cbc020836989b96ed430e1065bb","e28b14e7783d24ca69089f13ddadadbd2afdcb29"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7615b855702e008d91a95a2578bf05d27372f599":["382fe3a6ca9745891afebda9b9a57cc158305545"],"4cf2282b6a7c3f113e7a233b785b80527c03d590":["ffb85feece8645a035c02443a625f5af15e1106b"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e28b14e7783d24ca69089f13ddadadbd2afdcb29":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ffb85feece8645a035c02443a625f5af15e1106b":["b94236357aaa22b76c10629851fe4e376e0cea82","685bd38810c206c93e9058f3c2cfa9827c086c27","4cf2282b6a7c3f113e7a233b785b80527c03d590"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c26f00b574427b55127e869b935845554afde1fa":["382fe3a6ca9745891afebda9b9a57cc158305545"],"70052d44b40be0028db94b4cffeb9aaa5468055e":["ffb85feece8645a035c02443a625f5af15e1106b"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["e28b14e7783d24ca69089f13ddadadbd2afdcb29"],"382fe3a6ca9745891afebda9b9a57cc158305545":["27ab7b234eab0cbc020836989b96ed430e1065bb","7615b855702e008d91a95a2578bf05d27372f599"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"685bd38810c206c93e9058f3c2cfa9827c086c27":[],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ffb85feece8645a035c02443a625f5af15e1106b","70052d44b40be0028db94b4cffeb9aaa5468055e","56572ec06f1407c066d6b7399413178b33176cd8","685bd38810c206c93e9058f3c2cfa9827c086c27"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"4cf2282b6a7c3f113e7a233b785b80527c03d590":["b94236357aaa22b76c10629851fe4e376e0cea82"],"7615b855702e008d91a95a2578bf05d27372f599":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"e28b14e7783d24ca69089f13ddadadbd2afdcb29":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","685bd38810c206c93e9058f3c2cfa9827c086c27","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}