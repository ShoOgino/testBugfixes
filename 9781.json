{"path":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set[#]).mjava","commits":[{"id":"60cdc0e643184821eb066795a8791cd82559f46e","date":1257941914,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set[#]).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set).mjava","sourceNew":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucene's scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set<?> stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet<String> already = new HashSet<String>(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","sourceOld":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucene's scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet already = new HashSet(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set[#]).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/similar/SimilarityQueries#formSimilarQuery(String,Analyzer,String,Set[#]).mjava","sourceNew":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucene's scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set<?> stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet<String> already = new HashSet<String>(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","sourceOld":"\t/**\n\t * Simple similarity query generators.\n\t * Takes every unique word and forms a boolean query where all words are optional.\n\t * After you get this you'll use to to query your {@link IndexSearcher} for similar docs.\n\t * The only caveat is the first hit returned <b>should be</b> your source document - you'll\n\t * need to then ignore that.\n\t *\n\t * <p>\n\t * So, if you have a code fragment like this:\n\t * <br>\n\t * <code>\n\t * Query q = formSimilaryQuery( \"I use Lucene to search fast. Fast searchers are good\", new StandardAnalyzer(), \"contents\", null);\n\t * </code>\n\t *\n\t * <p>\n\t * The query returned, in string form, will be <code>'(i use lucene to search fast searchers are good')</code>.\n\t *\n\t * <p>\n\t * The philosophy behind this method is \"two documents are similar if they share lots of words\".\n\t * Note that behind the scenes, Lucene's scoring algorithm will tend to give two documents a higher similarity score if the share more uncommon words.\n\t *\n\t * <P>\n\t * This method is fail-safe in that if a long 'body' is passed in and\n\t * {@link BooleanQuery#add BooleanQuery.add()} (used internally)\n\t * throws\n\t * {@link org.apache.lucene.search.BooleanQuery.TooManyClauses BooleanQuery.TooManyClauses}, the\n\t * query as it is will be returned.\n\t *\n\t * @param body the body of the document you want to find similar documents to\n\t * @param a the analyzer to use to parse the body\n\t * @param field the field you want to search on, probably something like \"contents\" or \"body\"\n\t * @param stop optional set of stop words to ignore\n\t * @return a query with all unique words in 'body'\n\t * @throws IOException this can't happen...\n\t */\n    public static Query formSimilarQuery( String body,\n\t\t\t\t\t\t\t\t\t\t  Analyzer a,\n\t\t\t\t\t\t\t\t\t\t  String field,\n\t\t\t\t\t\t\t\t\t\t  Set<?> stop)\n\t\t\t\t\t\t\t\t\t\t  throws IOException\n\t{\t\n\t\tTokenStream ts = a.tokenStream( field, new StringReader( body));\n\t\tTermAttribute termAtt = ts.addAttribute(TermAttribute.class);\n\t\t\n\t\tBooleanQuery tmp = new BooleanQuery();\n\t\tSet<String> already = new HashSet<String>(); // ignore dups\n\t\twhile (ts.incrementToken()) {\n\t\t  String word = termAtt.term();\n\t\t\t// ignore opt stop words\n\t\t\tif ( stop != null &&\n\t\t\t\t stop.contains( word)) continue;\n\t\t\t// ignore dups\n\t\t\tif ( ! already.add( word)) continue;\n\t\t\t// add to query\n\t\t\tTermQuery tq = new TermQuery( new Term( field, word));\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmp.add( tq, BooleanClause.Occur.SHOULD);\n\t\t\t}\n\t\t\tcatch( BooleanQuery.TooManyClauses too)\n\t\t\t{\n\t\t\t\t// fail-safe, just return what we have, not the end of the world\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60cdc0e643184821eb066795a8791cd82559f46e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["60cdc0e643184821eb066795a8791cd82559f46e"]},"commit2Childs":{"60cdc0e643184821eb066795a8791cd82559f46e":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60cdc0e643184821eb066795a8791cd82559f46e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}