{"path":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceLeaders(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"5455c7b3fed6c1671990a44c19071cb0488c2c25","date":1413557414,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceLeaders(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  private void handleBalanceLeaders(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP);\n\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n    if (StringUtils.isBlank(collectionName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"The \" + COLLECTION_PROP + \" is required for the REASSIGNLEADERS command.\"));\n    }\n    coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n    ClusterState clusterState = coreContainer.getZkController().getClusterState();\n    DocCollection dc = clusterState.getCollection(collectionName);\n    if (dc == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection '\" + collectionName + \"' does not exist, no action taken.\");\n    }\n    Map<String, String> current = new HashMap<>();\n    int max = req.getParams().getInt(MAX_AT_ONCE_PROP, Integer.MAX_VALUE);\n    if (max <= 0) max = Integer.MAX_VALUE;\n    int maxWaitSecs = req.getParams().getInt(MAX_WAIT_SECONDS_PROP, 60);\n    NamedList<Object> results = new NamedList<>();\n    SolrQueryResponse rspIgnore = new SolrQueryResponse();\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    boolean keepGoing = true;\n    for (Slice slice : dc.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n        if (replica.getBool(Overseer.preferredLeaderProp, false) == false) {\n          continue;\n        }\n        if (StringUtils.equalsIgnoreCase(replica.getStr(STATE_PROP), ACTIVE) == false) {\n          NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n          if (inactives == null) {\n            inactives = new NamedList<>();\n            results.add(inactivePreferreds, inactives);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"skipped\");\n          res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n          res.add(\"nodeName\", replica.getNodeName());\n          inactives.add(replica.getName(), res);\n          break; // Don't try to assign if we're not active!\n        }        // OK, we're the one, get in the queue to become the leader.\n        if (replica.getBool(LEADER_PROP, false)) {\n          NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n          if (noops == null) {\n            noops = new NamedList<>();\n            results.add(alreadyLeaders, noops);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"success\");\n          res.add(\"msg\", \"Already leader\");\n          res.add(\"nodeName\", replica.getNodeName());\n          noops.add(replica.getName(), res);\n          break; // already the leader, do nothing.\n        }\n        Map<String, Object> propMap = new HashMap<>();\n        propMap.put(Overseer.QUEUE_OPERATION, REBALANCELEADERS.toLower());\n        propMap.put(COLLECTION_PROP, collectionName);\n        propMap.put(SHARD_ID_PROP, slice.getName());\n        propMap.put(BASE_URL_PROP, replica.get(BASE_URL_PROP));\n\n        String coreName = (String) replica.get(CORE_NAME_PROP);\n        // Put it in the waiting list.\n        String asyncId = REBALANCELEADERS.toLower() + \"_\" + coreName;\n        current.put(asyncId, String.format(Locale.ROOT, \"Collection: '%s', Shard: '%s', Core: '%s', BaseUrl: '%s'\",\n            collectionName, slice.getName(), coreName, replica.get(BASE_URL_PROP)));\n\n        propMap.put(CORE_NAME_PROP, coreName);\n        propMap.put(ASYNC, asyncId);\n\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        log.info(\"Queueing collection '\" + collectionName + \"' slice '\" + slice.getName() + \"' replica '\" +\n                coreName + \"' to become leader.\");\n        handleResponse(REBALANCELEADERS.toLower(), m, rspIgnore); // Want to construct my own response here.\n        break; // Done with this slice, skip the rest of the replicas.\n      }\n      if (current.size() == max) {\n        log.info(\"Queued \" + max + \" leader reassgnments, waiting for some to complete.\");\n        keepGoing = waitForLeaderChange(current, maxWaitSecs, false, results);\n        if (keepGoing == false) {\n          break; // If we've waited longer than specified, don't continue to wait!\n        }\n      }\n    }\n    if (keepGoing == true) {\n      keepGoing = waitForLeaderChange(current, maxWaitSecs, true, results);\n    }\n    if (keepGoing == true) {\n      log.info(\"All leader reassignments completed.\");\n    } else {\n      log.warn(\"Exceeded specified timeout of .\" + maxWaitSecs + \"' all leaders may not have been reassigned\");\n    }\n\n    rsp.getValues().addAll(results);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064","73fd358e8ec697393d56617f4d9cedaca74dca14"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceLeaders(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  private void handleBalanceLeaders(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP);\n\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n    if (StringUtils.isBlank(collectionName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"The \" + COLLECTION_PROP + \" is required for the REASSIGNLEADERS command.\"));\n    }\n    coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n    ClusterState clusterState = coreContainer.getZkController().getClusterState();\n    DocCollection dc = clusterState.getCollection(collectionName);\n    if (dc == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection '\" + collectionName + \"' does not exist, no action taken.\");\n    }\n    Map<String, String> current = new HashMap<>();\n    int max = req.getParams().getInt(MAX_AT_ONCE_PROP, Integer.MAX_VALUE);\n    if (max <= 0) max = Integer.MAX_VALUE;\n    int maxWaitSecs = req.getParams().getInt(MAX_WAIT_SECONDS_PROP, 60);\n    NamedList<Object> results = new NamedList<>();\n    SolrQueryResponse rspIgnore = new SolrQueryResponse();\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    boolean keepGoing = true;\n    for (Slice slice : dc.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n        if (replica.getBool(Overseer.preferredLeaderProp, false) == false) {\n          continue;\n        }\n        if (StringUtils.equalsIgnoreCase(replica.getStr(STATE_PROP), ACTIVE) == false) {\n          NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n          if (inactives == null) {\n            inactives = new NamedList<>();\n            results.add(inactivePreferreds, inactives);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"skipped\");\n          res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n          res.add(\"nodeName\", replica.getNodeName());\n          inactives.add(replica.getName(), res);\n          break; // Don't try to assign if we're not active!\n        }        // OK, we're the one, get in the queue to become the leader.\n        if (replica.getBool(LEADER_PROP, false)) {\n          NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n          if (noops == null) {\n            noops = new NamedList<>();\n            results.add(alreadyLeaders, noops);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"success\");\n          res.add(\"msg\", \"Already leader\");\n          res.add(\"nodeName\", replica.getNodeName());\n          noops.add(replica.getName(), res);\n          break; // already the leader, do nothing.\n        }\n        Map<String, Object> propMap = new HashMap<>();\n        propMap.put(Overseer.QUEUE_OPERATION, REBALANCELEADERS.toLower());\n        propMap.put(COLLECTION_PROP, collectionName);\n        propMap.put(SHARD_ID_PROP, slice.getName());\n        propMap.put(BASE_URL_PROP, replica.get(BASE_URL_PROP));\n\n        String coreName = (String) replica.get(CORE_NAME_PROP);\n        // Put it in the waiting list.\n        String asyncId = REBALANCELEADERS.toLower() + \"_\" + coreName;\n        current.put(asyncId, String.format(Locale.ROOT, \"Collection: '%s', Shard: '%s', Core: '%s', BaseUrl: '%s'\",\n            collectionName, slice.getName(), coreName, replica.get(BASE_URL_PROP)));\n\n        propMap.put(CORE_NAME_PROP, coreName);\n        propMap.put(ASYNC, asyncId);\n\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        log.info(\"Queueing collection '\" + collectionName + \"' slice '\" + slice.getName() + \"' replica '\" +\n                coreName + \"' to become leader.\");\n        handleResponse(REBALANCELEADERS.toLower(), m, rspIgnore); // Want to construct my own response here.\n        break; // Done with this slice, skip the rest of the replicas.\n      }\n      if (current.size() == max) {\n        log.info(\"Queued \" + max + \" leader reassgnments, waiting for some to complete.\");\n        keepGoing = waitForLeaderChange(current, maxWaitSecs, false, results);\n        if (keepGoing == false) {\n          break; // If we've waited longer than specified, don't continue to wait!\n        }\n      }\n    }\n    if (keepGoing == true) {\n      keepGoing = waitForLeaderChange(current, maxWaitSecs, true, results);\n    }\n    if (keepGoing == true) {\n      log.info(\"All leader reassignments completed.\");\n    } else {\n      log.warn(\"Exceeded specified timeout of .\" + maxWaitSecs + \"' all leaders may not have been reassigned\");\n    }\n\n    rsp.getValues().addAll(results);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceLeaders(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceLeaders(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private void handleBalanceLeaders(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP);\n\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n    if (StringUtils.isBlank(collectionName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"The \" + COLLECTION_PROP + \" is required for the REASSIGNLEADERS command.\"));\n    }\n    coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n    ClusterState clusterState = coreContainer.getZkController().getClusterState();\n    DocCollection dc = clusterState.getCollection(collectionName);\n    if (dc == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection '\" + collectionName + \"' does not exist, no action taken.\");\n    }\n    Map<String, String> current = new HashMap<>();\n    int max = req.getParams().getInt(MAX_AT_ONCE_PROP, Integer.MAX_VALUE);\n    if (max <= 0) max = Integer.MAX_VALUE;\n    int maxWaitSecs = req.getParams().getInt(MAX_WAIT_SECONDS_PROP, 60);\n    NamedList<Object> results = new NamedList<>();\n    SolrQueryResponse rspIgnore = new SolrQueryResponse();\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    boolean keepGoing = true;\n    for (Slice slice : dc.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n        if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n          continue;\n        }\n        if (StringUtils.equalsIgnoreCase(replica.getStr(STATE_PROP), ACTIVE) == false) {\n          NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n          if (inactives == null) {\n            inactives = new NamedList<>();\n            results.add(inactivePreferreds, inactives);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"skipped\");\n          res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n          res.add(\"nodeName\", replica.getNodeName());\n          inactives.add(replica.getName(), res);\n          break; // Don't try to assign if we're not active!\n        }        // OK, we're the one, get in the queue to become the leader.\n        if (replica.getBool(LEADER_PROP, false)) {\n          NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n          if (noops == null) {\n            noops = new NamedList<>();\n            results.add(alreadyLeaders, noops);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"success\");\n          res.add(\"msg\", \"Already leader\");\n          res.add(\"nodeName\", replica.getNodeName());\n          noops.add(replica.getName(), res);\n          break; // already the leader, do nothing.\n        }\n        Map<String, Object> propMap = new HashMap<>();\n        propMap.put(Overseer.QUEUE_OPERATION, REBALANCELEADERS.toLower());\n        propMap.put(COLLECTION_PROP, collectionName);\n        propMap.put(SHARD_ID_PROP, slice.getName());\n        propMap.put(BASE_URL_PROP, replica.get(BASE_URL_PROP));\n\n        String coreName = (String) replica.get(CORE_NAME_PROP);\n        // Put it in the waiting list.\n        String asyncId = REBALANCELEADERS.toLower() + \"_\" + coreName;\n        current.put(asyncId, String.format(Locale.ROOT, \"Collection: '%s', Shard: '%s', Core: '%s', BaseUrl: '%s'\",\n            collectionName, slice.getName(), coreName, replica.get(BASE_URL_PROP)));\n\n        propMap.put(CORE_NAME_PROP, coreName);\n        propMap.put(ASYNC, asyncId);\n\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        log.info(\"Queueing collection '\" + collectionName + \"' slice '\" + slice.getName() + \"' replica '\" +\n                coreName + \"' to become leader.\");\n        handleResponse(REBALANCELEADERS.toLower(), m, rspIgnore); // Want to construct my own response here.\n        break; // Done with this slice, skip the rest of the replicas.\n      }\n      if (current.size() == max) {\n        log.info(\"Queued \" + max + \" leader reassgnments, waiting for some to complete.\");\n        keepGoing = waitForLeaderChange(current, maxWaitSecs, false, results);\n        if (keepGoing == false) {\n          break; // If we've waited longer than specified, don't continue to wait!\n        }\n      }\n    }\n    if (keepGoing == true) {\n      keepGoing = waitForLeaderChange(current, maxWaitSecs, true, results);\n    }\n    if (keepGoing == true) {\n      log.info(\"All leader reassignments completed.\");\n    } else {\n      log.warn(\"Exceeded specified timeout of .\" + maxWaitSecs + \"' all leaders may not have been reassigned\");\n    }\n\n    rsp.getValues().addAll(results);\n  }\n\n","sourceOld":"  private void handleBalanceLeaders(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP);\n\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n    if (StringUtils.isBlank(collectionName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"The \" + COLLECTION_PROP + \" is required for the REASSIGNLEADERS command.\"));\n    }\n    coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n    ClusterState clusterState = coreContainer.getZkController().getClusterState();\n    DocCollection dc = clusterState.getCollection(collectionName);\n    if (dc == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection '\" + collectionName + \"' does not exist, no action taken.\");\n    }\n    Map<String, String> current = new HashMap<>();\n    int max = req.getParams().getInt(MAX_AT_ONCE_PROP, Integer.MAX_VALUE);\n    if (max <= 0) max = Integer.MAX_VALUE;\n    int maxWaitSecs = req.getParams().getInt(MAX_WAIT_SECONDS_PROP, 60);\n    NamedList<Object> results = new NamedList<>();\n    SolrQueryResponse rspIgnore = new SolrQueryResponse();\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    boolean keepGoing = true;\n    for (Slice slice : dc.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n        if (replica.getBool(Overseer.preferredLeaderProp, false) == false) {\n          continue;\n        }\n        if (StringUtils.equalsIgnoreCase(replica.getStr(STATE_PROP), ACTIVE) == false) {\n          NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n          if (inactives == null) {\n            inactives = new NamedList<>();\n            results.add(inactivePreferreds, inactives);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"skipped\");\n          res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n          res.add(\"nodeName\", replica.getNodeName());\n          inactives.add(replica.getName(), res);\n          break; // Don't try to assign if we're not active!\n        }        // OK, we're the one, get in the queue to become the leader.\n        if (replica.getBool(LEADER_PROP, false)) {\n          NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n          if (noops == null) {\n            noops = new NamedList<>();\n            results.add(alreadyLeaders, noops);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"success\");\n          res.add(\"msg\", \"Already leader\");\n          res.add(\"nodeName\", replica.getNodeName());\n          noops.add(replica.getName(), res);\n          break; // already the leader, do nothing.\n        }\n        Map<String, Object> propMap = new HashMap<>();\n        propMap.put(Overseer.QUEUE_OPERATION, REBALANCELEADERS.toLower());\n        propMap.put(COLLECTION_PROP, collectionName);\n        propMap.put(SHARD_ID_PROP, slice.getName());\n        propMap.put(BASE_URL_PROP, replica.get(BASE_URL_PROP));\n\n        String coreName = (String) replica.get(CORE_NAME_PROP);\n        // Put it in the waiting list.\n        String asyncId = REBALANCELEADERS.toLower() + \"_\" + coreName;\n        current.put(asyncId, String.format(Locale.ROOT, \"Collection: '%s', Shard: '%s', Core: '%s', BaseUrl: '%s'\",\n            collectionName, slice.getName(), coreName, replica.get(BASE_URL_PROP)));\n\n        propMap.put(CORE_NAME_PROP, coreName);\n        propMap.put(ASYNC, asyncId);\n\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        log.info(\"Queueing collection '\" + collectionName + \"' slice '\" + slice.getName() + \"' replica '\" +\n                coreName + \"' to become leader.\");\n        handleResponse(REBALANCELEADERS.toLower(), m, rspIgnore); // Want to construct my own response here.\n        break; // Done with this slice, skip the rest of the replicas.\n      }\n      if (current.size() == max) {\n        log.info(\"Queued \" + max + \" leader reassgnments, waiting for some to complete.\");\n        keepGoing = waitForLeaderChange(current, maxWaitSecs, false, results);\n        if (keepGoing == false) {\n          break; // If we've waited longer than specified, don't continue to wait!\n        }\n      }\n    }\n    if (keepGoing == true) {\n      keepGoing = waitForLeaderChange(current, maxWaitSecs, true, results);\n    }\n    if (keepGoing == true) {\n      log.info(\"All leader reassignments completed.\");\n    } else {\n      log.warn(\"Exceeded specified timeout of .\" + maxWaitSecs + \"' all leaders may not have been reassigned\");\n    }\n\n    rsp.getValues().addAll(results);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e6b620c271c84c0f14919eec7b90083b292ee51","date":1419461736,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceLeaders(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceLeaders(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private void handleBalanceLeaders(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP);\n\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n    if (StringUtils.isBlank(collectionName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"The \" + COLLECTION_PROP + \" is required for the REASSIGNLEADERS command.\"));\n    }\n    coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n    ClusterState clusterState = coreContainer.getZkController().getClusterState();\n    DocCollection dc = clusterState.getCollection(collectionName);\n    if (dc == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection '\" + collectionName + \"' does not exist, no action taken.\");\n    }\n    Map<String, String> currentRequests = new HashMap<>();\n    int max = req.getParams().getInt(MAX_AT_ONCE_PROP, Integer.MAX_VALUE);\n    if (max <= 0) max = Integer.MAX_VALUE;\n    int maxWaitSecs = req.getParams().getInt(MAX_WAIT_SECONDS_PROP, 60);\n    NamedList<Object> results = new NamedList<>();\n\n    boolean keepGoing = true;\n    for (Slice slice : dc.getSlices()) {\n      insurePreferredIsLeader(req, results, slice, currentRequests);\n      if (currentRequests.size() == max) {\n        log.info(\"Queued \" + max + \" leader reassignments, waiting for some to complete.\");\n        keepGoing = waitForLeaderChange(currentRequests, maxWaitSecs, false, results);\n        if (keepGoing == false) {\n          break; // If we've waited longer than specified, don't continue to wait!\n        }\n      }\n    }\n    if (keepGoing == true) {\n      keepGoing = waitForLeaderChange(currentRequests, maxWaitSecs, true, results);\n    }\n    if (keepGoing == true) {\n      log.info(\"All leader reassignments completed.\");\n    } else {\n      log.warn(\"Exceeded specified timeout of .\" + maxWaitSecs + \"' all leaders may not have been reassigned\");\n    }\n\n    rsp.getValues().addAll(results);\n  }\n\n","sourceOld":"  private void handleBalanceLeaders(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP);\n\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n    if (StringUtils.isBlank(collectionName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"The \" + COLLECTION_PROP + \" is required for the REASSIGNLEADERS command.\"));\n    }\n    coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n    ClusterState clusterState = coreContainer.getZkController().getClusterState();\n    DocCollection dc = clusterState.getCollection(collectionName);\n    if (dc == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection '\" + collectionName + \"' does not exist, no action taken.\");\n    }\n    Map<String, String> current = new HashMap<>();\n    int max = req.getParams().getInt(MAX_AT_ONCE_PROP, Integer.MAX_VALUE);\n    if (max <= 0) max = Integer.MAX_VALUE;\n    int maxWaitSecs = req.getParams().getInt(MAX_WAIT_SECONDS_PROP, 60);\n    NamedList<Object> results = new NamedList<>();\n    SolrQueryResponse rspIgnore = new SolrQueryResponse();\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    boolean keepGoing = true;\n    for (Slice slice : dc.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n        if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n          continue;\n        }\n        if (StringUtils.equalsIgnoreCase(replica.getStr(STATE_PROP), ACTIVE) == false) {\n          NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n          if (inactives == null) {\n            inactives = new NamedList<>();\n            results.add(inactivePreferreds, inactives);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"skipped\");\n          res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n          res.add(\"nodeName\", replica.getNodeName());\n          inactives.add(replica.getName(), res);\n          break; // Don't try to assign if we're not active!\n        }        // OK, we're the one, get in the queue to become the leader.\n        if (replica.getBool(LEADER_PROP, false)) {\n          NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n          if (noops == null) {\n            noops = new NamedList<>();\n            results.add(alreadyLeaders, noops);\n          }\n          NamedList<Object> res = new NamedList<>();\n          res.add(\"status\", \"success\");\n          res.add(\"msg\", \"Already leader\");\n          res.add(\"nodeName\", replica.getNodeName());\n          noops.add(replica.getName(), res);\n          break; // already the leader, do nothing.\n        }\n        Map<String, Object> propMap = new HashMap<>();\n        propMap.put(Overseer.QUEUE_OPERATION, REBALANCELEADERS.toLower());\n        propMap.put(COLLECTION_PROP, collectionName);\n        propMap.put(SHARD_ID_PROP, slice.getName());\n        propMap.put(BASE_URL_PROP, replica.get(BASE_URL_PROP));\n\n        String coreName = (String) replica.get(CORE_NAME_PROP);\n        // Put it in the waiting list.\n        String asyncId = REBALANCELEADERS.toLower() + \"_\" + coreName;\n        current.put(asyncId, String.format(Locale.ROOT, \"Collection: '%s', Shard: '%s', Core: '%s', BaseUrl: '%s'\",\n            collectionName, slice.getName(), coreName, replica.get(BASE_URL_PROP)));\n\n        propMap.put(CORE_NAME_PROP, coreName);\n        propMap.put(ASYNC, asyncId);\n\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        log.info(\"Queueing collection '\" + collectionName + \"' slice '\" + slice.getName() + \"' replica '\" +\n                coreName + \"' to become leader.\");\n        handleResponse(REBALANCELEADERS.toLower(), m, rspIgnore); // Want to construct my own response here.\n        break; // Done with this slice, skip the rest of the replicas.\n      }\n      if (current.size() == max) {\n        log.info(\"Queued \" + max + \" leader reassgnments, waiting for some to complete.\");\n        keepGoing = waitForLeaderChange(current, maxWaitSecs, false, results);\n        if (keepGoing == false) {\n          break; // If we've waited longer than specified, don't continue to wait!\n        }\n      }\n    }\n    if (keepGoing == true) {\n      keepGoing = waitForLeaderChange(current, maxWaitSecs, true, results);\n    }\n    if (keepGoing == true) {\n      log.info(\"All leader reassignments completed.\");\n    } else {\n      log.warn(\"Exceeded specified timeout of .\" + maxWaitSecs + \"' all leaders may not have been reassigned\");\n    }\n\n    rsp.getValues().addAll(results);\n  }\n\n","bugFix":null,"bugIntro":["73fd358e8ec697393d56617f4d9cedaca74dca14"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ebd3a557326ef3eab85b73a8cff781f7d801248","date":1431620752,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#execute().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleBalanceLeaders(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  void execute() throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP);\n\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n    if (StringUtils.isBlank(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"The \" + COLLECTION_PROP + \" is required for the REASSIGNLEADERS command.\"));\n    }\n    coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n    ClusterState clusterState = coreContainer.getZkController().getClusterState();\n    DocCollection dc = clusterState.getCollection(collectionName);\n    if (dc == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection '\" + collectionName + \"' does not exist, no action taken.\");\n    }\n    Map<String, String> currentRequests = new HashMap<>();\n    int max = req.getParams().getInt(MAX_AT_ONCE_PROP, Integer.MAX_VALUE);\n    if (max <= 0) max = Integer.MAX_VALUE;\n    int maxWaitSecs = req.getParams().getInt(MAX_WAIT_SECONDS_PROP, 60);\n    NamedList<Object> results = new NamedList<>();\n\n    boolean keepGoing = true;\n    for (Slice slice : dc.getSlices()) {\n      insurePreferredIsLeader(results, slice, currentRequests);\n      if (currentRequests.size() == max) {\n        CollectionsHandler.log.info(\"Queued \" + max + \" leader reassignments, waiting for some to complete.\");\n        keepGoing = waitForLeaderChange(currentRequests, maxWaitSecs, false, results);\n        if (keepGoing == false) {\n          break; // If we've waited longer than specified, don't continue to wait!\n        }\n      }\n    }\n    if (keepGoing == true) {\n      keepGoing = waitForLeaderChange(currentRequests, maxWaitSecs, true, results);\n    }\n    if (keepGoing == true) {\n      CollectionsHandler.log.info(\"All leader reassignments completed.\");\n    } else {\n      CollectionsHandler.log.warn(\"Exceeded specified timeout of .\" + maxWaitSecs + \"' all leaders may not have been reassigned\");\n    }\n\n    rsp.getValues().addAll(results);\n  }\n\n","sourceOld":"  private void handleBalanceLeaders(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {\n    req.getParams().required().check(COLLECTION_PROP);\n\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n    if (StringUtils.isBlank(collectionName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          String.format(Locale.ROOT, \"The \" + COLLECTION_PROP + \" is required for the REASSIGNLEADERS command.\"));\n    }\n    coreContainer.getZkController().getZkStateReader().updateClusterState(true);\n    ClusterState clusterState = coreContainer.getZkController().getClusterState();\n    DocCollection dc = clusterState.getCollection(collectionName);\n    if (dc == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection '\" + collectionName + \"' does not exist, no action taken.\");\n    }\n    Map<String, String> currentRequests = new HashMap<>();\n    int max = req.getParams().getInt(MAX_AT_ONCE_PROP, Integer.MAX_VALUE);\n    if (max <= 0) max = Integer.MAX_VALUE;\n    int maxWaitSecs = req.getParams().getInt(MAX_WAIT_SECONDS_PROP, 60);\n    NamedList<Object> results = new NamedList<>();\n\n    boolean keepGoing = true;\n    for (Slice slice : dc.getSlices()) {\n      insurePreferredIsLeader(req, results, slice, currentRequests);\n      if (currentRequests.size() == max) {\n        log.info(\"Queued \" + max + \" leader reassignments, waiting for some to complete.\");\n        keepGoing = waitForLeaderChange(currentRequests, maxWaitSecs, false, results);\n        if (keepGoing == false) {\n          break; // If we've waited longer than specified, don't continue to wait!\n        }\n      }\n    }\n    if (keepGoing == true) {\n      keepGoing = waitForLeaderChange(currentRequests, maxWaitSecs, true, results);\n    }\n    if (keepGoing == true) {\n      log.info(\"All leader reassignments completed.\");\n    } else {\n      log.warn(\"Exceeded specified timeout of .\" + maxWaitSecs + \"' all leaders may not have been reassigned\");\n    }\n\n    rsp.getValues().addAll(results);\n  }\n\n","bugFix":null,"bugIntro":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064","73fd358e8ec697393d56617f4d9cedaca74dca14"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["5455c7b3fed6c1671990a44c19071cb0488c2c25"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5455c7b3fed6c1671990a44c19071cb0488c2c25"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ebd3a557326ef3eab85b73a8cff781f7d801248":["4e6b620c271c84c0f14919eec7b90083b292ee51"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4e6b620c271c84c0f14919eec7b90083b292ee51":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ebd3a557326ef3eab85b73a8cff781f7d801248"]},"commit2Childs":{"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["4e6b620c271c84c0f14919eec7b90083b292ee51"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","5455c7b3fed6c1671990a44c19071cb0488c2c25"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"9ebd3a557326ef3eab85b73a8cff781f7d801248":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4e6b620c271c84c0f14919eec7b90083b292ee51":["9ebd3a557326ef3eab85b73a8cff781f7d801248"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}