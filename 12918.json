{"path":"lucene/core/src/test/org/apache/lucene/util/automaton/TestRegExp#checkRandomExpression(String).mjava","commits":[{"id":"074f544130034fba3e820179fe98defcf2e5c165","date":1589447065,"type":0,"author":"markharwood","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestRegExp#checkRandomExpression(String).mjava","pathOld":"/dev/null","sourceNew":"  protected String checkRandomExpression(String docValue) {\n    // Generate and test a random regular expression which should match the given docValue\n    StringBuilder result = new StringBuilder();\n    // Pick a part of the string to change\n    int substitutionPoint = randomInt(docValue.length() - 1);\n    int substitutionLength = 1 + randomInt(Math.min(10, docValue.length() - substitutionPoint));\n\n    // Add any head to the result, unchanged\n    if (substitutionPoint > 0) {\n      result.append(docValue.substring(0, substitutionPoint));\n    }\n\n    // Modify the middle...\n    String replacementPart = docValue.substring(substitutionPoint, substitutionPoint + substitutionLength);\n    int mutation = random().nextInt(13);\n    switch (mutation) {\n      case 0:\n        // OR with random alpha of same length\n        result.append(\"(\" + replacementPart + \"|d\" + randomDocValue(replacementPart.length()) + \")\");\n        break;\n      case 1:\n        // OR with non-existant value\n        result.append(\"(\" + replacementPart + \"|doesnotexist)\");\n        break;\n      case 2:\n        // OR with another randomised regex (used to create nested levels of expression).\n        result.append(\"(\" + checkRandomExpression(replacementPart) + \"|doesnotexist)\");\n        break;\n      case 3:\n        // Star-replace all ab sequences.\n        result.append(replacementPart.replaceAll(\"ab\", \".*\"));\n        break;\n      case 4:\n        // .-replace all b chars\n        result.append(replacementPart.replaceAll(\"b\", \".\"));\n        break;\n      case 5:\n        // length-limited stars {1,2}\n        result.append(\".{1,\" + replacementPart.length() + \"}\");\n        break;\n      case 6:\n        // replace all chars with .\n        result.append(replacementPart.replaceAll(\".\", \".\"));\n        break;\n      case 7:\n        // OR with uppercase chars eg [aA] (many of these sorts of expression in the wild..\n        char[] chars = replacementPart.toCharArray();\n        for (char c : chars) {\n          result.append(\"[\" + c + Character.toUpperCase(c) + \"]\");\n        }\n        break;\n      case 8:\n        // NOT a character - replace all b's with \"not a\"\n        result.append(replacementPart.replaceAll(\"b\", \"[^a]\"));\n        break;\n      case 9:\n        // Make whole part repeatable 1 or more times\n        result.append(\"(\" + replacementPart + \")+\");\n        break;\n      case 10:\n        // Make whole part repeatable 0 or more times\n        result.append(\"(\" + replacementPart + \")?\");\n        break;\n      case 11:\n        // Make any digits replaced by character class\n        result.append(replacementPart.replaceAll(\"\\\\d\", \"\\\\\\\\d\"));\n        break;\n      case 12:\n        // Make any whitespace chars replaced by not word class\n        result.append(replacementPart.replaceAll(\"\\\\s\", \"\\\\\\\\W\"));\n        break;\n      case 13:\n        // Make any whitespace chars replace by whitespace class\n        result.append(replacementPart.replaceAll(\"\\\\s\", \"\\\\\\\\s\"));\n        break;\n      default:\n        break;\n    }\n    // add any remaining tail, unchanged\n    if (substitutionPoint + substitutionLength <= docValue.length() - 1) {\n      result.append(docValue.substring(substitutionPoint + substitutionLength));\n    }\n\n    String regexPattern = result.toString();\n    // Assert our randomly generated regex actually matches the provided raw input using java's expression matcher\n    Pattern pattern = Pattern.compile(regexPattern);\n    Matcher matcher = pattern.matcher(docValue);\n    assertTrue(\"Java regex \" + regexPattern + \" did not match doc value \" + docValue, matcher.matches());\n\n    RegExp regex = new RegExp(regexPattern);\n    Automaton automaton = regex.toAutomaton();\n    ByteRunAutomaton bytesMatcher = new ByteRunAutomaton(automaton);\n    BytesRef br = new BytesRef(docValue);\n    assertTrue(\n        \"[\" + regexPattern + \"]should match [\" + docValue + \"]\" + substitutionPoint + \"-\" + substitutionLength + \"/\"\n            + docValue.length(),\n        bytesMatcher.run(br.bytes, br.offset, br.length)\n    );\n    return regexPattern;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601","date":1594220892,"type":3,"author":"markharwood","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestRegExp#checkRandomExpression(String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestRegExp#checkRandomExpression(String).mjava","sourceNew":"  protected String checkRandomExpression(String docValue) {\n    // Generate and test a random regular expression which should match the given docValue\n    StringBuilder result = new StringBuilder();\n    // Pick a part of the string to change\n    int substitutionPoint = randomInt(docValue.length() - 1);\n    int substitutionLength = 1 + randomInt(Math.min(10, docValue.length() - substitutionPoint));\n\n    // Add any head to the result, unchanged\n    if (substitutionPoint > 0) {\n      result.append(docValue.substring(0, substitutionPoint));\n    }\n\n    // Modify the middle...\n    String replacementPart = docValue.substring(substitutionPoint, substitutionPoint + substitutionLength);\n    int mutation = random().nextInt(15);\n    switch (mutation) {\n      case 0:\n        // OR with random alpha of same length\n        result.append(\"(\" + replacementPart + \"|d\" + randomDocValue(replacementPart.length()) + \")\");\n        break;\n      case 1:\n        // OR with non-existant value\n        result.append(\"(\" + replacementPart + \"|doesnotexist)\");\n        break;\n      case 2:\n        // OR with another randomised regex (used to create nested levels of expression).\n        result.append(\"(\" + checkRandomExpression(replacementPart) + \"|doesnotexist)\");\n        break;\n      case 3:\n        // Star-replace all ab sequences.\n        result.append(replacementPart.replaceAll(\"ab\", \".*\"));\n        break;\n      case 4:\n        // .-replace all b chars\n        result.append(replacementPart.replaceAll(\"b\", \".\"));\n        break;\n      case 5:\n        // length-limited stars {1,2}\n        result.append(\".{1,\" + replacementPart.length() + \"}\");\n        break;\n      case 6:\n        // replace all chars with .\n        result.append(replacementPart.replaceAll(\".\", \".\"));\n        break;\n      case 7:\n        // OR with uppercase chars eg [aA] (many of these sorts of expression in the wild..\n        char[] chars = replacementPart.toCharArray();\n        for (char c : chars) {\n          result.append(\"[\" + c + Character.toUpperCase(c) + \"]\");\n        }\n        break;\n      case 8:\n        // NOT a character - replace all b's with \"not a\"\n        result.append(replacementPart.replaceAll(\"b\", \"[^a]\"));\n        break;\n      case 9:\n        // Make whole part repeatable 1 or more times\n        result.append(\"(\" + replacementPart + \")+\");\n        break;\n      case 10:\n        // Make whole part repeatable 0 or more times\n        result.append(\"(\" + replacementPart + \")?\");\n        break;\n      case 11:\n        // Make any digits replaced by character class\n        result.append(replacementPart.replaceAll(\"\\\\d\", \"\\\\\\\\d\"));\n        break;\n      case 12:\n        // Make any whitespace chars replaced by not word class\n        result.append(replacementPart.replaceAll(\"\\\\s\", \"\\\\\\\\W\"));\n        break;\n      case 13:\n        // Make any whitespace chars replace by whitespace class\n        result.append(replacementPart.replaceAll(\"\\\\s\", \"\\\\\\\\s\"));\n        break;\n      case 14:\n        // Switch case of characters\n        StringBuilder switchedCase = new StringBuilder();\n        replacementPart.codePoints().forEach(\n            p -> {\n              int switchedP = p;\n              if (Character.isLowerCase(p)) {\n                switchedP = Character.toUpperCase(p);\n              } else {\n                switchedP = Character.toLowerCase(p);                \n              }\n              switchedCase.appendCodePoint(switchedP);\n              if (p != switchedP) {\n                caseSensitiveQuery = false;\n              }\n            }\n        );        \n        result.append(switchedCase.toString());\n        break;\n      default:\n        break;\n    }\n    // add any remaining tail, unchanged\n    if (substitutionPoint + substitutionLength <= docValue.length() - 1) {\n      result.append(docValue.substring(substitutionPoint + substitutionLength));\n    }\n\n    String regexPattern = result.toString();\n    // Assert our randomly generated regex actually matches the provided raw input using java's expression matcher\n    Pattern pattern = caseSensitiveQuery ? Pattern.compile(regexPattern): \n                                           Pattern.compile(regexPattern, Pattern.CASE_INSENSITIVE); \n                                             ;\n    Matcher matcher = pattern.matcher(docValue);\n    assertTrue(\"Java regex \" + regexPattern + \" did not match doc value \" + docValue, matcher.matches());\n\n    int matchFlags = caseSensitiveQuery ? 0 : RegExp.ASCII_CASE_INSENSITIVE;\n    RegExp regex =  new RegExp(regexPattern, RegExp.ALL, matchFlags);\n    Automaton automaton = regex.toAutomaton();\n    ByteRunAutomaton bytesMatcher = new ByteRunAutomaton(automaton);\n    BytesRef br = new BytesRef(docValue);\n    assertTrue(\n        \"[\" + regexPattern + \"]should match [\" + docValue + \"]\" + substitutionPoint + \"-\" + substitutionLength + \"/\"\n            + docValue.length(),\n        bytesMatcher.run(br.bytes, br.offset, br.length)\n    );\n    if (caseSensitiveQuery == false) {\n      RegExp caseSensitiveRegex = new RegExp(regexPattern);\n      Automaton csAutomaton = caseSensitiveRegex.toAutomaton();\n      ByteRunAutomaton csBytesMatcher = new ByteRunAutomaton(csAutomaton);\n      assertFalse(\n          \"[\" + regexPattern + \"] with case sensitive setting should not match [\" + docValue + \"]\", \n          csBytesMatcher.run(br.bytes, br.offset, br.length)\n      );\n      \n    }\n    return regexPattern;\n  }\n\n","sourceOld":"  protected String checkRandomExpression(String docValue) {\n    // Generate and test a random regular expression which should match the given docValue\n    StringBuilder result = new StringBuilder();\n    // Pick a part of the string to change\n    int substitutionPoint = randomInt(docValue.length() - 1);\n    int substitutionLength = 1 + randomInt(Math.min(10, docValue.length() - substitutionPoint));\n\n    // Add any head to the result, unchanged\n    if (substitutionPoint > 0) {\n      result.append(docValue.substring(0, substitutionPoint));\n    }\n\n    // Modify the middle...\n    String replacementPart = docValue.substring(substitutionPoint, substitutionPoint + substitutionLength);\n    int mutation = random().nextInt(13);\n    switch (mutation) {\n      case 0:\n        // OR with random alpha of same length\n        result.append(\"(\" + replacementPart + \"|d\" + randomDocValue(replacementPart.length()) + \")\");\n        break;\n      case 1:\n        // OR with non-existant value\n        result.append(\"(\" + replacementPart + \"|doesnotexist)\");\n        break;\n      case 2:\n        // OR with another randomised regex (used to create nested levels of expression).\n        result.append(\"(\" + checkRandomExpression(replacementPart) + \"|doesnotexist)\");\n        break;\n      case 3:\n        // Star-replace all ab sequences.\n        result.append(replacementPart.replaceAll(\"ab\", \".*\"));\n        break;\n      case 4:\n        // .-replace all b chars\n        result.append(replacementPart.replaceAll(\"b\", \".\"));\n        break;\n      case 5:\n        // length-limited stars {1,2}\n        result.append(\".{1,\" + replacementPart.length() + \"}\");\n        break;\n      case 6:\n        // replace all chars with .\n        result.append(replacementPart.replaceAll(\".\", \".\"));\n        break;\n      case 7:\n        // OR with uppercase chars eg [aA] (many of these sorts of expression in the wild..\n        char[] chars = replacementPart.toCharArray();\n        for (char c : chars) {\n          result.append(\"[\" + c + Character.toUpperCase(c) + \"]\");\n        }\n        break;\n      case 8:\n        // NOT a character - replace all b's with \"not a\"\n        result.append(replacementPart.replaceAll(\"b\", \"[^a]\"));\n        break;\n      case 9:\n        // Make whole part repeatable 1 or more times\n        result.append(\"(\" + replacementPart + \")+\");\n        break;\n      case 10:\n        // Make whole part repeatable 0 or more times\n        result.append(\"(\" + replacementPart + \")?\");\n        break;\n      case 11:\n        // Make any digits replaced by character class\n        result.append(replacementPart.replaceAll(\"\\\\d\", \"\\\\\\\\d\"));\n        break;\n      case 12:\n        // Make any whitespace chars replaced by not word class\n        result.append(replacementPart.replaceAll(\"\\\\s\", \"\\\\\\\\W\"));\n        break;\n      case 13:\n        // Make any whitespace chars replace by whitespace class\n        result.append(replacementPart.replaceAll(\"\\\\s\", \"\\\\\\\\s\"));\n        break;\n      default:\n        break;\n    }\n    // add any remaining tail, unchanged\n    if (substitutionPoint + substitutionLength <= docValue.length() - 1) {\n      result.append(docValue.substring(substitutionPoint + substitutionLength));\n    }\n\n    String regexPattern = result.toString();\n    // Assert our randomly generated regex actually matches the provided raw input using java's expression matcher\n    Pattern pattern = Pattern.compile(regexPattern);\n    Matcher matcher = pattern.matcher(docValue);\n    assertTrue(\"Java regex \" + regexPattern + \" did not match doc value \" + docValue, matcher.matches());\n\n    RegExp regex = new RegExp(regexPattern);\n    Automaton automaton = regex.toAutomaton();\n    ByteRunAutomaton bytesMatcher = new ByteRunAutomaton(automaton);\n    BytesRef br = new BytesRef(docValue);\n    assertTrue(\n        \"[\" + regexPattern + \"]should match [\" + docValue + \"]\" + substitutionPoint + \"-\" + substitutionLength + \"/\"\n            + docValue.length(),\n        bytesMatcher.run(br.bytes, br.offset, br.length)\n    );\n    return regexPattern;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"074f544130034fba3e820179fe98defcf2e5c165":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601":["074f544130034fba3e820179fe98defcf2e5c165"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601"]},"commit2Childs":{"074f544130034fba3e820179fe98defcf2e5c165":["0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["074f544130034fba3e820179fe98defcf2e5c165"],"0785d1d3506a0f4d8fd4adc2efe29f0e1a9c2601":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}