{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","commits":[{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"/dev/null","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"/dev/null","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9798d0818e7a880546802b509792d3f3d57babd2","date":1528358901,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDataDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, config.packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * config.packedBytesLength, maxPackedValue, 0, config.packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, config.packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, config.bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<config.numDims;dim++) {\n        int offset1 = dim * config.bytesPerDim;\n        int offset2 = (leafCount - 1) * config.packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = config.packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = config.packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, config.packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * config.packedBytesLength, leafCount * config.packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDataDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["f6652c943595e92c187ee904c382863013eae28f"],"f6652c943595e92c187ee904c382863013eae28f":["9798d0818e7a880546802b509792d3f3d57babd2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9798d0818e7a880546802b509792d3f3d57babd2"],"9856095f7afb5a607bf5e65077615ed91273508c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"9798d0818e7a880546802b509792d3f3d57babd2":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9798d0818e7a880546802b509792d3f3d57babd2"]},"commit2Childs":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["b70042a8a492f7054d480ccdd2be9796510d4327","9856095f7afb5a607bf5e65077615ed91273508c","9798d0818e7a880546802b509792d3f3d57babd2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9856095f7afb5a607bf5e65077615ed91273508c"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"9856095f7afb5a607bf5e65077615ed91273508c":[],"9798d0818e7a880546802b509792d3f3d57babd2":["f6652c943595e92c187ee904c382863013eae28f","b70042a8a492f7054d480ccdd2be9796510d4327","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}