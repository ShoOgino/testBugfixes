{"path":"solr/core/src/java/org/apache/solr/cloud/Overseer#doCompatCheck(BiConsumer[String,Object]).mjava","commits":[{"id":"dad6a48950aafc9c2f5dc54740f8c6ab81304203","date":1552999379,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer#doCompatCheck(BiConsumer[String,Object]).mjava","pathOld":"/dev/null","sourceNew":"  private void doCompatCheck(BiConsumer<String, Object> consumer) {\n    if (systemCollCompatCheck) {\n      systemCollCompatCheck = false;\n    } else {\n      return;\n    }\n    try (CloudSolrClient client = new CloudSolrClient.Builder(Collections.singletonList(getZkController().getZkServerAddress()), Optional.empty())\n          .withSocketTimeout(30000).withConnectionTimeout(15000)\n        .withHttpClient(updateShardHandler.getDefaultHttpClient()).build()) {\n      CollectionAdminRequest.ColStatus req = CollectionAdminRequest.collectionStatus(CollectionAdminParams.SYSTEM_COLL)\n          .setWithSegments(true)\n          .setWithFieldInfo(true);\n      CollectionAdminResponse rsp = req.process(client);\n      NamedList<Object> status = (NamedList<Object>)rsp.getResponse().get(CollectionAdminParams.SYSTEM_COLL);\n      Collection<String> nonCompliant = (Collection<String>)status.get(\"schemaNonCompliant\");\n      if (!nonCompliant.contains(\"(NONE)\")) {\n        consumer.accept(\"indexFieldsNotMatchingSchema\", nonCompliant);\n      }\n      Set<Integer> segmentCreatedMajorVersions = new HashSet<>();\n      Set<String> segmentVersions = new HashSet<>();\n      int currentMajorVersion = Version.LATEST.major;\n      String currentVersion = Version.LATEST.toString();\n      segmentVersions.add(currentVersion);\n      segmentCreatedMajorVersions.add(currentMajorVersion);\n      NamedList<Object> shards = (NamedList<Object>)status.get(\"shards\");\n      for (Map.Entry<String, Object> entry : shards) {\n        NamedList<Object> leader = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"leader\");\n        if (leader == null) {\n          continue;\n        }\n        NamedList<Object> segInfos = (NamedList<Object>)leader.get(\"segInfos\");\n        if (segInfos == null) {\n          continue;\n        }\n        NamedList<Object> infos = (NamedList<Object>)segInfos.get(\"info\");\n        if (((Number)infos.get(\"numSegments\")).intValue() > 0) {\n          segmentVersions.add(infos.get(\"minSegmentLuceneVersion\").toString());\n        }\n        if (infos.get(\"commitLuceneVersion\") != null) {\n          segmentVersions.add(infos.get(\"commitLuceneVersion\").toString());\n        }\n        NamedList<Object> segmentInfos = (NamedList<Object>)segInfos.get(\"segments\");\n        segmentInfos.forEach((k, v) -> {\n          NamedList<Object> segment = (NamedList<Object>)v;\n          segmentVersions.add(segment.get(\"version\").toString());\n          if (segment.get(\"minVersion\") != null) {\n            segmentVersions.add(segment.get(\"version\").toString());\n          }\n          if (segment.get(\"createdVersionMajor\") != null) {\n            segmentCreatedMajorVersions.add(((Number)segment.get(\"createdVersionMajor\")).intValue());\n          }\n        });\n      }\n      if (segmentVersions.size() > 1) {\n        consumer.accept(\"differentSegmentVersions\", segmentVersions);\n        consumer.accept(\"currentLuceneVersion\", currentVersion);\n      }\n      if (segmentCreatedMajorVersions.size() > 1) {\n        consumer.accept(\"differentMajorSegmentVersions\", segmentCreatedMajorVersions);\n        consumer.accept(\"currentLuceneMajorVersion\", currentMajorVersion);\n      }\n\n    } catch (SolrServerException | IOException e) {\n      log.warn(\"Unable to perform back-compat check of .system collection\", e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer#doCompatCheck(BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer#doCompatCheck(BiConsumer[String,Object]).mjava","sourceNew":"  private void doCompatCheck(BiConsumer<String, Object> consumer) {\n    if (systemCollCompatCheck) {\n      systemCollCompatCheck = false;\n    } else {\n      return;\n    }\n    try (CloudSolrClient client = new CloudSolrClient.Builder(Collections.singletonList(getZkController().getZkServerAddress()), Optional.empty())\n          .withSocketTimeout(30000).withConnectionTimeout(15000)\n        .withHttpClient(updateShardHandler.getDefaultHttpClient()).build()) {\n      CollectionAdminRequest.ColStatus req = CollectionAdminRequest.collectionStatus(CollectionAdminParams.SYSTEM_COLL)\n          .setWithSegments(true)\n          .setWithFieldInfo(true);\n      CollectionAdminResponse rsp = req.process(client);\n      @SuppressWarnings({\"unchecked\"})\n      NamedList<Object> status = (NamedList<Object>)rsp.getResponse().get(CollectionAdminParams.SYSTEM_COLL);\n      @SuppressWarnings({\"unchecked\"})\n      Collection<String> nonCompliant = (Collection<String>)status.get(\"schemaNonCompliant\");\n      if (!nonCompliant.contains(\"(NONE)\")) {\n        consumer.accept(\"indexFieldsNotMatchingSchema\", nonCompliant);\n      }\n      Set<Integer> segmentCreatedMajorVersions = new HashSet<>();\n      Set<String> segmentVersions = new HashSet<>();\n      int currentMajorVersion = Version.LATEST.major;\n      String currentVersion = Version.LATEST.toString();\n      segmentVersions.add(currentVersion);\n      segmentCreatedMajorVersions.add(currentMajorVersion);\n      @SuppressWarnings({\"unchecked\"})\n      NamedList<Object> shards = (NamedList<Object>)status.get(\"shards\");\n      for (Map.Entry<String, Object> entry : shards) {\n        @SuppressWarnings({\"unchecked\"})\n        NamedList<Object> leader = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"leader\");\n        if (leader == null) {\n          continue;\n        }\n        @SuppressWarnings({\"unchecked\"})\n        NamedList<Object> segInfos = (NamedList<Object>)leader.get(\"segInfos\");\n        if (segInfos == null) {\n          continue;\n        }\n        @SuppressWarnings({\"unchecked\"})\n        NamedList<Object> infos = (NamedList<Object>)segInfos.get(\"info\");\n        if (((Number)infos.get(\"numSegments\")).intValue() > 0) {\n          segmentVersions.add(infos.get(\"minSegmentLuceneVersion\").toString());\n        }\n        if (infos.get(\"commitLuceneVersion\") != null) {\n          segmentVersions.add(infos.get(\"commitLuceneVersion\").toString());\n        }\n        @SuppressWarnings({\"unchecked\"})\n        NamedList<Object> segmentInfos = (NamedList<Object>)segInfos.get(\"segments\");\n        segmentInfos.forEach((k, v) -> {\n          @SuppressWarnings({\"unchecked\"})\n          NamedList<Object> segment = (NamedList<Object>)v;\n          segmentVersions.add(segment.get(\"version\").toString());\n          if (segment.get(\"minVersion\") != null) {\n            segmentVersions.add(segment.get(\"version\").toString());\n          }\n          if (segment.get(\"createdVersionMajor\") != null) {\n            segmentCreatedMajorVersions.add(((Number)segment.get(\"createdVersionMajor\")).intValue());\n          }\n        });\n      }\n      if (segmentVersions.size() > 1) {\n        consumer.accept(\"differentSegmentVersions\", segmentVersions);\n        consumer.accept(\"currentLuceneVersion\", currentVersion);\n      }\n      if (segmentCreatedMajorVersions.size() > 1) {\n        consumer.accept(\"differentMajorSegmentVersions\", segmentCreatedMajorVersions);\n        consumer.accept(\"currentLuceneMajorVersion\", currentMajorVersion);\n      }\n\n    } catch (SolrServerException | IOException e) {\n      log.warn(\"Unable to perform back-compat check of .system collection\", e);\n    }\n  }\n\n","sourceOld":"  private void doCompatCheck(BiConsumer<String, Object> consumer) {\n    if (systemCollCompatCheck) {\n      systemCollCompatCheck = false;\n    } else {\n      return;\n    }\n    try (CloudSolrClient client = new CloudSolrClient.Builder(Collections.singletonList(getZkController().getZkServerAddress()), Optional.empty())\n          .withSocketTimeout(30000).withConnectionTimeout(15000)\n        .withHttpClient(updateShardHandler.getDefaultHttpClient()).build()) {\n      CollectionAdminRequest.ColStatus req = CollectionAdminRequest.collectionStatus(CollectionAdminParams.SYSTEM_COLL)\n          .setWithSegments(true)\n          .setWithFieldInfo(true);\n      CollectionAdminResponse rsp = req.process(client);\n      NamedList<Object> status = (NamedList<Object>)rsp.getResponse().get(CollectionAdminParams.SYSTEM_COLL);\n      Collection<String> nonCompliant = (Collection<String>)status.get(\"schemaNonCompliant\");\n      if (!nonCompliant.contains(\"(NONE)\")) {\n        consumer.accept(\"indexFieldsNotMatchingSchema\", nonCompliant);\n      }\n      Set<Integer> segmentCreatedMajorVersions = new HashSet<>();\n      Set<String> segmentVersions = new HashSet<>();\n      int currentMajorVersion = Version.LATEST.major;\n      String currentVersion = Version.LATEST.toString();\n      segmentVersions.add(currentVersion);\n      segmentCreatedMajorVersions.add(currentMajorVersion);\n      NamedList<Object> shards = (NamedList<Object>)status.get(\"shards\");\n      for (Map.Entry<String, Object> entry : shards) {\n        NamedList<Object> leader = (NamedList<Object>)((NamedList<Object>)entry.getValue()).get(\"leader\");\n        if (leader == null) {\n          continue;\n        }\n        NamedList<Object> segInfos = (NamedList<Object>)leader.get(\"segInfos\");\n        if (segInfos == null) {\n          continue;\n        }\n        NamedList<Object> infos = (NamedList<Object>)segInfos.get(\"info\");\n        if (((Number)infos.get(\"numSegments\")).intValue() > 0) {\n          segmentVersions.add(infos.get(\"minSegmentLuceneVersion\").toString());\n        }\n        if (infos.get(\"commitLuceneVersion\") != null) {\n          segmentVersions.add(infos.get(\"commitLuceneVersion\").toString());\n        }\n        NamedList<Object> segmentInfos = (NamedList<Object>)segInfos.get(\"segments\");\n        segmentInfos.forEach((k, v) -> {\n          NamedList<Object> segment = (NamedList<Object>)v;\n          segmentVersions.add(segment.get(\"version\").toString());\n          if (segment.get(\"minVersion\") != null) {\n            segmentVersions.add(segment.get(\"version\").toString());\n          }\n          if (segment.get(\"createdVersionMajor\") != null) {\n            segmentCreatedMajorVersions.add(((Number)segment.get(\"createdVersionMajor\")).intValue());\n          }\n        });\n      }\n      if (segmentVersions.size() > 1) {\n        consumer.accept(\"differentSegmentVersions\", segmentVersions);\n        consumer.accept(\"currentLuceneVersion\", currentVersion);\n      }\n      if (segmentCreatedMajorVersions.size() > 1) {\n        consumer.accept(\"differentMajorSegmentVersions\", segmentCreatedMajorVersions);\n        consumer.accept(\"currentLuceneMajorVersion\", currentMajorVersion);\n      }\n\n    } catch (SolrServerException | IOException e) {\n      log.warn(\"Unable to perform back-compat check of .system collection\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"]},"commit2Childs":{"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}