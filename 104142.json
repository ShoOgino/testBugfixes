{"path":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random.nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random.nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.normsPresent());\n    } else {\n      assertFalse(fieldInfo.normsPresent());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random));\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.normsPresent());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.normsPresent());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.type());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random.nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random.nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.normsPresent());\n    } else {\n      assertFalse(fieldInfo.normsPresent());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random));\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.normsPresent());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.normsPresent());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.type());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46818a810eab72123f0e37e6ec5f2d426bd47be1","date":1331482161,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random.nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random.nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random));\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.type());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random.nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random.nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.normsPresent());\n    } else {\n      assertFalse(fieldInfo.normsPresent());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random));\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.normsPresent());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.normsPresent());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.type());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd0f953fbccd59aa346f280fe7e30a698f5ecb04","date":1331511349,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random.nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random.nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random));\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random.nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random.nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random));\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.type());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random.nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random.nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random));\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random.nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random.nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.normsPresent());\n    } else {\n      assertFalse(fieldInfo.normsPresent());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random));\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.normsPresent());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.normsPresent());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.type());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random.nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random.nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random));\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a3b1d1827232fee926b12cd22842daa4e39cd68","date":1336175028,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newDirectory();\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newDirectory();\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":["9e8d5a6ffbfa3405d234a87c833741eabed98d13"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76923f6a33f2c4bec7f584e3f251261afe7ea276","date":1337149711,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitNorms);\n    assertTrue(fieldInfo.isIndexed);\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitNorms);\n      assertTrue(fi.isIndexed);\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(DirectoryReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(IndexReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","date":1341839195,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(DirectoryReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        StoredDocument document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(DirectoryReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d028314cced5858683a1bb4741423d0f934257b","date":1346596535,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(DirectoryReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        StoredDocument document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(DirectoryReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        Document document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":null,"sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(DirectoryReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        StoredDocument document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNorms#testNormsNotPresent().mjava","sourceNew":null,"sourceOld":"  /**\n   * this test randomly creates segments with or without norms but not omitting\n   * norms. The similarity used doesn't write a norm value if writeNorms = false is\n   * passed. This differs from omitNorm since norms are simply not written for this segment\n   * while merging fills in default values based on the Norm {@link Type}\n   */\n  public void testNormsNotPresent() throws IOException {\n    Directory dir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.1\"));\n    boolean firstWriteNorm = random().nextBoolean();\n    buildIndex(dir, firstWriteNorm);\n\n    Directory otherDir = newFSDirectory(_TestUtil.getTempDir(\"TestNorms.testNormsNotPresent.2\"));\n    boolean secondWriteNorm = random().nextBoolean();\n    buildIndex(otherDir, secondWriteNorm);\n\n    AtomicReader reader = SlowCompositeReaderWrapper.wrap(DirectoryReader.open(otherDir));\n    FieldInfos fieldInfos = reader.getFieldInfos();\n    FieldInfo fieldInfo = fieldInfos.fieldInfo(byteTestField);\n    assertFalse(fieldInfo.omitsNorms());\n    assertTrue(fieldInfo.isIndexed());\n    if (secondWriteNorm) {\n      assertTrue(fieldInfo.hasNorms());\n    } else {\n      assertFalse(fieldInfo.hasNorms());  \n    }\n    \n    IndexWriterConfig config = newIndexWriterConfig(TEST_VERSION_CURRENT,\n        new MockAnalyzer(random()));\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, config);\n    writer.addIndexes(reader);\n    AtomicReader mergedReader = SlowCompositeReaderWrapper.wrap(writer.getReader());\n    if (!firstWriteNorm && !secondWriteNorm) {\n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNull(normValues);\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertFalse(fi.hasNorms());\n    } else {\n      FieldInfo fi = mergedReader.getFieldInfos().fieldInfo(byteTestField);\n      assertFalse(fi.omitsNorms());\n      assertTrue(fi.isIndexed());\n      assertTrue(fi.hasNorms());\n      \n      DocValues normValues = mergedReader.normValues(byteTestField);\n      assertNotNull(normValues);\n      Source source = normValues.getSource();\n      assertTrue(source.hasArray());\n      assertEquals(Type.FIXED_INTS_8, normValues.getType());\n      byte[] norms = (byte[]) source.getArray();\n      for (int i = 0; i < mergedReader.maxDoc(); i++) {\n        StoredDocument document = mergedReader.document(i);\n        int expected = Integer.parseInt(document.get(byteTestField));\n        assertEquals((byte) expected, norms[i]);\n      }\n    }\n    mergedReader.close();\n    reader.close();\n\n    writer.close();\n    dir.close();\n    otherDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","cd0f953fbccd59aa346f280fe7e30a698f5ecb04"],"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5a3b1d1827232fee926b12cd22842daa4e39cd68":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"76923f6a33f2c4bec7f584e3f251261afe7ea276":["5a3b1d1827232fee926b12cd22842daa4e39cd68"],"1d028314cced5858683a1bb4741423d0f934257b":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["5a3b1d1827232fee926b12cd22842daa4e39cd68","76923f6a33f2c4bec7f584e3f251261afe7ea276"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["1d028314cced5858683a1bb4741423d0f934257b","0837ab0472feecb3a54260729d845f839e1cbd72"],"cd0f953fbccd59aa346f280fe7e30a698f5ecb04":["46818a810eab72123f0e37e6ec5f2d426bd47be1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"46818a810eab72123f0e37e6ec5f2d426bd47be1":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"0837ab0472feecb3a54260729d845f839e1cbd72":["1d028314cced5858683a1bb4741423d0f934257b"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["cd0f953fbccd59aa346f280fe7e30a698f5ecb04"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["1d028314cced5858683a1bb4741423d0f934257b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","46818a810eab72123f0e37e6ec5f2d426bd47be1"],"5a3b1d1827232fee926b12cd22842daa4e39cd68":["76923f6a33f2c4bec7f584e3f251261afe7ea276","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"76923f6a33f2c4bec7f584e3f251261afe7ea276":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"1d028314cced5858683a1bb4741423d0f934257b":["d4d69c535930b5cce125cff868d40f6373dc27d4","0837ab0472feecb3a54260729d845f839e1cbd72"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","1d028314cced5858683a1bb4741423d0f934257b"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd0f953fbccd59aa346f280fe7e30a698f5ecb04":["38e3b736c7ca086d61b7dbb841c905ee115490da","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"0837ab0472feecb3a54260729d845f839e1cbd72":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"46818a810eab72123f0e37e6ec5f2d426bd47be1":["cd0f953fbccd59aa346f280fe7e30a698f5ecb04"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["5a3b1d1827232fee926b12cd22842daa4e39cd68"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}