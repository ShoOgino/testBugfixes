{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#run().mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;            \n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = client.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    client.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, client.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n            method = new HttpPost(client.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = client.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n\n              SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n              // parse out the metadata from the SolrException\n              try {\n                NamedList<Object> resp =\n                    client.parser.processResponse(response.getEntity().getContent(),\n                        response.getEntity().getContentType().getValue());\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null)\n                  solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \"+ client.getBaseURL()+\" due to: \"+exc);\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;            \n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n\n              SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n              // parse out the metadata from the SolrException\n              try {\n                NamedList<Object> resp =\n                    server.parser.processResponse(response.getEntity().getContent(),\n                        response.getEntity().getContentType().getValue());\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null)\n                  solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \"+server.getBaseURL()+\" due to: \"+exc);\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b","date":1432083803,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = client.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    client.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n\n                    if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                      // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                      req = queue.poll(0, TimeUnit.MILLISECONDS);\n                    } else {\n                      req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                    }\n\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, client.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n            method = new HttpPost(client.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = client.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n\n              SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n              // parse out the metadata from the SolrException\n              try {\n                NamedList<Object> resp =\n                    client.parser.processResponse(response.getEntity().getContent(),\n                        response.getEntity().getContentType().getValue());\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null)\n                  solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \"+ client.getBaseURL()+\" due to: \"+exc);\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;            \n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = client.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    client.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, client.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n            method = new HttpPost(client.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = client.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n\n              SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n              // parse out the metadata from the SolrException\n              try {\n                NamedList<Object> resp =\n                    client.parser.processResponse(response.getEntity().getContent(),\n                        response.getEntity().getContentType().getValue());\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null)\n                  solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \"+ client.getBaseURL()+\" due to: \"+exc);\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"50e202028300f452744bbd0e537a0f5c0cf044b6","date":1446478140,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      log.debug(\"starting runner: {}\", this);\n\n      // This loop is so we can continue if an element was added to the queue after the last runner exited.\n      for (;;) {\n\n        try {\n\n          sendUpdateStream();\n\n        } catch (Throwable e) {\n          if (e instanceof OutOfMemoryError) {\n            throw (OutOfMemoryError) e;\n          }\n          handleError(e);\n        } finally {\n\n          synchronized (runners) {\n            // check to see if anything else was added to the queue\n            if (runners.size() == 1 && !queue.isEmpty() && !scheduler.isShutdown()) {\n              // If there is something else to process, keep last runner alive by staying in the loop.\n            } else {\n              runners.remove(this);\n              if (runners.isEmpty()) {\n                // notify anyone waiting in blockUntilFinished\n                runners.notifyAll();\n              }\n              break;\n            }\n          }\n\n        }\n      }\n\n      log.debug(\"finished: {}\", this);\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = client.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    client.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n\n                    if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                      // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                      req = queue.poll(0, TimeUnit.MILLISECONDS);\n                    } else {\n                      req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                    }\n\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, client.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n            method = new HttpPost(client.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = client.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n\n              SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n              // parse out the metadata from the SolrException\n              try {\n                NamedList<Object> resp =\n                    client.parser.processResponse(response.getEntity().getContent(),\n                        response.getEntity().getContentType().getValue());\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null)\n                  solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \"+ client.getBaseURL()+\" due to: \"+exc);\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b","7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ca1cace44c816965501b934686a2354382f000","date":1487792658,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      this.thread = Thread.currentThread();\n      log.debug(\"starting runner: {}\", this);\n      // This loop is so we can continue if an element was added to the queue after the last runner exited.\n      for (;;) {\n        try {\n\n          sendUpdateStream();\n\n        } catch (Throwable e) {\n          if (e instanceof OutOfMemoryError) {\n            throw (OutOfMemoryError) e;\n          }\n          handleError(e);\n        } finally {\n          synchronized (runners) {\n            // check to see if anything else was added to the queue\n            if (runners.size() == 1 && !queue.isEmpty() && !scheduler.isShutdown()) {\n              // If there is something else to process, keep last runner alive by staying in the loop.\n            } else {\n              runners.remove(this);\n              if (runners.isEmpty()) {\n                // notify anyone waiting in blockUntilFinished\n                runners.notifyAll();\n              }\n              break;\n            }\n          }\n        }\n      }\n\n      log.debug(\"finished: {}\", this);\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      log.debug(\"starting runner: {}\", this);\n\n      // This loop is so we can continue if an element was added to the queue after the last runner exited.\n      for (;;) {\n\n        try {\n\n          sendUpdateStream();\n\n        } catch (Throwable e) {\n          if (e instanceof OutOfMemoryError) {\n            throw (OutOfMemoryError) e;\n          }\n          handleError(e);\n        } finally {\n\n          synchronized (runners) {\n            // check to see if anything else was added to the queue\n            if (runners.size() == 1 && !queue.isEmpty() && !scheduler.isShutdown()) {\n              // If there is something else to process, keep last runner alive by staying in the loop.\n            } else {\n              runners.remove(this);\n              if (runners.isEmpty()) {\n                // notify anyone waiting in blockUntilFinished\n                runners.notifyAll();\n              }\n              break;\n            }\n          }\n\n        }\n      }\n\n      log.debug(\"finished: {}\", this);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b":["bafca15d8e408346a67f4282ad1143b88023893b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"50e202028300f452744bbd0e537a0f5c0cf044b6":["7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b"],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c7ca1cace44c816965501b934686a2354382f000":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c7ca1cace44c816965501b934686a2354382f000"]},"commit2Childs":{"7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b"],"50e202028300f452744bbd0e537a0f5c0cf044b6":["c7ca1cace44c816965501b934686a2354382f000"],"c7ca1cace44c816965501b934686a2354382f000":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}