{"path":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","commits":[{"id":"e2c4c8fcff2030acaf17ea1c5b036989ba27678d","date":1294184310,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        int start = end;\n        leaf.norms(field, norms, start);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        int start = end;\n        leaf.norms(field, norms, start);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a54e23e03b47f3d568ab3020bdd386e4b2f0a05","date":1294877328,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","sourceNew":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        Fields fields = leaf.fields();\n        boolean hasField = (fields != null && fields.terms(field) != null);\n        \n        int start = end;\n        byte leafNorms[] = leaf.norms(field);\n        if (leafNorms == null) {\n          if (hasField) { // omitted norms\n            return null;\n          }\n          // doesn't have field, fill bytes\n          leafNorms = new byte[leaf.maxDoc()];\n          Arrays.fill(leafNorms, (byte) 0);\n        }\n        \n        System.arraycopy(leafNorms, 0, norms, start, leafNorms.length);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","sourceOld":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        int start = end;\n        leaf.norms(field, norms, start);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        Fields fields = leaf.fields();\n        boolean hasField = (fields != null && fields.terms(field) != null);\n        \n        int start = end;\n        byte leafNorms[] = leaf.norms(field);\n        if (leafNorms == null) {\n          if (hasField) { // omitted norms\n            return null;\n          }\n          // doesn't have field, fill bytes\n          leafNorms = new byte[leaf.maxDoc()];\n          Arrays.fill(leafNorms, (byte) 0);\n        }\n        \n        System.arraycopy(leafNorms, 0, norms, start, leafNorms.length);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","sourceNew":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        Fields fields = leaf.fields();\n        boolean hasField = (fields != null && fields.terms(field) != null);\n        \n        int start = end;\n        byte leafNorms[] = leaf.norms(field);\n        if (leafNorms == null) {\n          if (hasField) { // omitted norms\n            return null;\n          }\n          // doesn't have field, fill bytes\n          leafNorms = new byte[leaf.maxDoc()];\n          Arrays.fill(leafNorms, (byte) 0);\n        }\n        \n        System.arraycopy(leafNorms, 0, norms, start, leafNorms.length);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","sourceOld":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        int start = end;\n        leaf.norms(field, norms, start);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6e3376a314fcc2b31bc46d399c2ff23552b78d6","date":1325780477,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiNorms#norms(IndexReader,String).mjava","sourceNew":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        Fields fields = leaf.fields();\n        boolean hasField = (fields != null && fields.terms(field) != null);\n        \n        int start = end;\n        byte leafNorms[] = leaf.norms(field);\n        if (leafNorms == null) {\n          if (hasField) { // omitted norms\n            return null;\n          }\n          // doesn't have field, fill bytes\n          leafNorms = new byte[leaf.maxDoc()];\n          Arrays.fill(leafNorms, (byte) 0);\n        }\n        \n        System.arraycopy(leafNorms, 0, norms, start, leafNorms.length);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","sourceOld":"  /**\n   * Warning: this is heavy! Do not use in a loop, or implement norms()\n   * in your own reader with this (you should likely cache the result).\n   */\n  public static byte[] norms(IndexReader r, String field) throws IOException {\n    final IndexReader[] subs = r.getSequentialSubReaders();\n    if (subs == null) {\n      // already an atomic reader\n      return r.norms(field);\n    } else if (subs.length == 0 || !r.hasNorms(field)) {\n      // no norms\n      return null;\n    } else if (subs.length == 1) {\n      return norms(subs[0], field);\n    } else {\n      // TODO: optimize more maybe\n      byte norms[] = new byte[r.maxDoc()];\n      final List<IndexReader> leaves = new ArrayList<IndexReader>();\n      ReaderUtil.gatherSubReaders(leaves, r);\n      int end = 0;\n      for (IndexReader leaf : leaves) {\n        Fields fields = leaf.fields();\n        boolean hasField = (fields != null && fields.terms(field) != null);\n        \n        int start = end;\n        byte leafNorms[] = leaf.norms(field);\n        if (leafNorms == null) {\n          if (hasField) { // omitted norms\n            return null;\n          }\n          // doesn't have field, fill bytes\n          leafNorms = new byte[leaf.maxDoc()];\n          Arrays.fill(leafNorms, (byte) 0);\n        }\n        \n        System.arraycopy(leafNorms, 0, norms, start, leafNorms.length);\n        end += leaf.maxDoc();\n      }\n      return norms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a54e23e03b47f3d568ab3020bdd386e4b2f0a05":["e2c4c8fcff2030acaf17ea1c5b036989ba27678d"],"70ad682703b8585f5d0a637efec044d57ec05efb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e2c4c8fcff2030acaf17ea1c5b036989ba27678d"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","7a54e23e03b47f3d568ab3020bdd386e4b2f0a05"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2c4c8fcff2030acaf17ea1c5b036989ba27678d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f6e3376a314fcc2b31bc46d399c2ff23552b78d6":["7a54e23e03b47f3d568ab3020bdd386e4b2f0a05"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a54e23e03b47f3d568ab3020bdd386e4b2f0a05"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f6e3376a314fcc2b31bc46d399c2ff23552b78d6"]},"commit2Childs":{"7a54e23e03b47f3d568ab3020bdd386e4b2f0a05":["29ef99d61cda9641b6250bf9567329a6e65f901d","f6e3376a314fcc2b31bc46d399c2ff23552b78d6","868da859b43505d9d2a023bfeae6dd0c795f5295"],"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70ad682703b8585f5d0a637efec044d57ec05efb","e2c4c8fcff2030acaf17ea1c5b036989ba27678d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"e2c4c8fcff2030acaf17ea1c5b036989ba27678d":["7a54e23e03b47f3d568ab3020bdd386e4b2f0a05","70ad682703b8585f5d0a637efec044d57ec05efb"],"f6e3376a314fcc2b31bc46d399c2ff23552b78d6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}