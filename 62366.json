{"path":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafetyInListAll().mjava","commits":[{"id":"f3adea0022cffaaa592081efed775a7b8bf86b51","date":1532414870,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafetyInListAll().mjava","pathOld":"/dev/null","sourceNew":"  public void testThreadSafetyInListAll() throws Exception {\n    try (Directory dir = getDirectory(createTempDir(\"testThreadSafety\"))) {\n      if (dir instanceof BaseDirectoryWrapper) {\n        // we are not making a real index, just writing, reading files.\n        ((BaseDirectoryWrapper) dir).setCheckIndexOnClose(false);\n      }\n      if (dir instanceof MockDirectoryWrapper) {\n        // makes this test really slow\n        ((MockDirectoryWrapper) dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n\n      AtomicBoolean stop = new AtomicBoolean();\n      Thread writer = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong() + 1);\n          for (int i = 0, max = RandomizedTest.randomIntBetween(500, 1000); i < max; i++) {\n            String fileName = \"file-\" + i;\n            try (IndexOutput output = dir.createOutput(fileName, newIOContext(random()))) {\n              // Add some lags so that the other thread can read the content of the directory.\n              Thread.yield();\n            }\n            assertTrue(slowFileExists(dir, fileName));\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        } finally {\n          stop.set(true);\n        }\n      });\n\n      Thread reader = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong());\n          while (!stop.get()) {\n            String [] files = Arrays.stream(dir.listAll())\n                .filter(name -> !ExtrasFS.isExtra(name)) // Ignore anything from ExtraFS.\n                .toArray(String[]::new);\n\n            if (files.length > 0) {\n              do {\n                String file = RandomPicks.randomFrom(rnd, files);\n                try (IndexInput input = dir.openInput(file, newIOContext(random()))) {\n                  // Just open, nothing else.\n                } catch (AccessDeniedException e) {\n                  // Access denied is allowed for files for which the output is still open.\n                  // Since we don't synchronize with the writer thread, just ignore it.\n                } catch (IOException e) {\n                  throw new UncheckedIOException(\"Something went wrong when opening: \" + file, e);\n                }\n              } while (rnd.nextInt(3) != 0); // Sometimes break and list files again.\n            }\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      });\n\n      reader.start();\n      writer.start();\n\n      writer.join();\n      reader.join();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d203e5c4d54b6f6e78e98d2342905df37f816f6","date":1532511271,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafetyInListAll().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafetyInListAll().mjava","sourceNew":"  public void testThreadSafetyInListAll() throws Exception {\n    try (Directory dir = getDirectory(createTempDir(\"testThreadSafety\"))) {\n      if (dir instanceof BaseDirectoryWrapper) {\n        // we are not making a real index, just writing, reading files.\n        ((BaseDirectoryWrapper) dir).setCheckIndexOnClose(false);\n      }\n      if (dir instanceof MockDirectoryWrapper) {\n        // makes this test really slow\n        ((MockDirectoryWrapper) dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n\n      AtomicBoolean stop = new AtomicBoolean();\n      Thread writer = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong() + 1);\n          for (int i = 0, max = RandomizedTest.randomIntBetween(500, 1000); i < max; i++) {\n            String fileName = \"file-\" + i;\n            try (IndexOutput output = dir.createOutput(fileName, newIOContext(random()))) {\n              // Add some lags so that the other thread can read the content of the directory.\n              Thread.yield();\n            }\n            assertTrue(slowFileExists(dir, fileName));\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        } finally {\n          stop.set(true);\n        }\n      });\n\n      Thread reader = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong());\n          while (!stop.get()) {\n            String [] files = Arrays.stream(dir.listAll())\n                .filter(name -> !ExtrasFS.isExtra(name)) // Ignore anything from ExtraFS.\n                .toArray(String[]::new);\n\n            if (files.length > 0) {\n              do {\n                String file = RandomPicks.randomFrom(rnd, files);\n                try (IndexInput input = dir.openInput(file, newIOContext(random()))) {\n                  // Just open, nothing else.\n                } catch (AccessDeniedException e) {\n                  // Access denied is allowed for files for which the output is still open (MockDirectoryWriter enforces\n                  // this, for example). Since we don't synchronize with the writer thread, just ignore it.\n                } catch (IOException e) {\n                  throw new UncheckedIOException(\"Something went wrong when opening: \" + file, e);\n                }\n              } while (rnd.nextInt(3) != 0); // Sometimes break and list files again.\n            }\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      });\n\n      reader.start();\n      writer.start();\n\n      writer.join();\n      reader.join();\n    }\n  }\n\n","sourceOld":"  public void testThreadSafetyInListAll() throws Exception {\n    try (Directory dir = getDirectory(createTempDir(\"testThreadSafety\"))) {\n      if (dir instanceof BaseDirectoryWrapper) {\n        // we are not making a real index, just writing, reading files.\n        ((BaseDirectoryWrapper) dir).setCheckIndexOnClose(false);\n      }\n      if (dir instanceof MockDirectoryWrapper) {\n        // makes this test really slow\n        ((MockDirectoryWrapper) dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n\n      AtomicBoolean stop = new AtomicBoolean();\n      Thread writer = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong() + 1);\n          for (int i = 0, max = RandomizedTest.randomIntBetween(500, 1000); i < max; i++) {\n            String fileName = \"file-\" + i;\n            try (IndexOutput output = dir.createOutput(fileName, newIOContext(random()))) {\n              // Add some lags so that the other thread can read the content of the directory.\n              Thread.yield();\n            }\n            assertTrue(slowFileExists(dir, fileName));\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        } finally {\n          stop.set(true);\n        }\n      });\n\n      Thread reader = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong());\n          while (!stop.get()) {\n            String [] files = Arrays.stream(dir.listAll())\n                .filter(name -> !ExtrasFS.isExtra(name)) // Ignore anything from ExtraFS.\n                .toArray(String[]::new);\n\n            if (files.length > 0) {\n              do {\n                String file = RandomPicks.randomFrom(rnd, files);\n                try (IndexInput input = dir.openInput(file, newIOContext(random()))) {\n                  // Just open, nothing else.\n                } catch (AccessDeniedException e) {\n                  // Access denied is allowed for files for which the output is still open.\n                  // Since we don't synchronize with the writer thread, just ignore it.\n                } catch (IOException e) {\n                  throw new UncheckedIOException(\"Something went wrong when opening: \" + file, e);\n                }\n              } while (rnd.nextInt(3) != 0); // Sometimes break and list files again.\n            }\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      });\n\n      reader.start();\n      writer.start();\n\n      writer.join();\n      reader.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"409da428f28953cf35fddd5c9ff5c7e4f5439863","date":1547556145,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafetyInListAll().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafetyInListAll().mjava","sourceNew":"  public void testThreadSafetyInListAll() throws Exception {\n    try (Directory dir = getDirectory(createTempDir(\"testThreadSafety\"))) {\n      if (dir instanceof BaseDirectoryWrapper) {\n        // we are not making a real index, just writing, reading files.\n        ((BaseDirectoryWrapper) dir).setCheckIndexOnClose(false);\n      }\n      if (dir instanceof MockDirectoryWrapper) {\n        // makes this test really slow\n        ((MockDirectoryWrapper) dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n\n      AtomicBoolean stop = new AtomicBoolean();\n      Thread writer = new Thread(() -> {\n        try {\n          for (int i = 0, max = RandomizedTest.randomIntBetween(500, 1000); i < max; i++) {\n            String fileName = \"file-\" + i;\n            try (IndexOutput output = dir.createOutput(fileName, newIOContext(random()))) {\n              // Add some lags so that the other thread can read the content of the directory.\n              Thread.yield();\n            }\n            assertTrue(slowFileExists(dir, fileName));\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        } finally {\n          stop.set(true);\n        }\n      });\n\n      Thread reader = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong());\n          while (!stop.get()) {\n            String [] files = Arrays.stream(dir.listAll())\n                .filter(name -> !ExtrasFS.isExtra(name)) // Ignore anything from ExtraFS.\n                .toArray(String[]::new);\n\n            if (files.length > 0) {\n              do {\n                String file = RandomPicks.randomFrom(rnd, files);\n                try (IndexInput input = dir.openInput(file, newIOContext(random()))) {\n                  // Just open, nothing else.\n                } catch (AccessDeniedException e) {\n                  // Access denied is allowed for files for which the output is still open (MockDirectoryWriter enforces\n                  // this, for example). Since we don't synchronize with the writer thread, just ignore it.\n                } catch (IOException e) {\n                  throw new UncheckedIOException(\"Something went wrong when opening: \" + file, e);\n                }\n              } while (rnd.nextInt(3) != 0); // Sometimes break and list files again.\n            }\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      });\n\n      reader.start();\n      writer.start();\n\n      writer.join();\n      reader.join();\n    }\n  }\n\n","sourceOld":"  public void testThreadSafetyInListAll() throws Exception {\n    try (Directory dir = getDirectory(createTempDir(\"testThreadSafety\"))) {\n      if (dir instanceof BaseDirectoryWrapper) {\n        // we are not making a real index, just writing, reading files.\n        ((BaseDirectoryWrapper) dir).setCheckIndexOnClose(false);\n      }\n      if (dir instanceof MockDirectoryWrapper) {\n        // makes this test really slow\n        ((MockDirectoryWrapper) dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n\n      AtomicBoolean stop = new AtomicBoolean();\n      Thread writer = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong() + 1);\n          for (int i = 0, max = RandomizedTest.randomIntBetween(500, 1000); i < max; i++) {\n            String fileName = \"file-\" + i;\n            try (IndexOutput output = dir.createOutput(fileName, newIOContext(random()))) {\n              // Add some lags so that the other thread can read the content of the directory.\n              Thread.yield();\n            }\n            assertTrue(slowFileExists(dir, fileName));\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        } finally {\n          stop.set(true);\n        }\n      });\n\n      Thread reader = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong());\n          while (!stop.get()) {\n            String [] files = Arrays.stream(dir.listAll())\n                .filter(name -> !ExtrasFS.isExtra(name)) // Ignore anything from ExtraFS.\n                .toArray(String[]::new);\n\n            if (files.length > 0) {\n              do {\n                String file = RandomPicks.randomFrom(rnd, files);\n                try (IndexInput input = dir.openInput(file, newIOContext(random()))) {\n                  // Just open, nothing else.\n                } catch (AccessDeniedException e) {\n                  // Access denied is allowed for files for which the output is still open (MockDirectoryWriter enforces\n                  // this, for example). Since we don't synchronize with the writer thread, just ignore it.\n                } catch (IOException e) {\n                  throw new UncheckedIOException(\"Something went wrong when opening: \" + file, e);\n                }\n              } while (rnd.nextInt(3) != 0); // Sometimes break and list files again.\n            }\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      });\n\n      reader.start();\n      writer.start();\n\n      writer.join();\n      reader.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c21918ef3ad23e254f39cb0cd6c86851fcb993","date":1580123310,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafetyInListAll().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafetyInListAll().mjava","sourceNew":"  public void testThreadSafetyInListAll() throws Exception {\n    try (Directory dir = getDirectory(createTempDir(\"testThreadSafety\"))) {\n      if (dir instanceof BaseDirectoryWrapper) {\n        // we are not making a real index, just writing, reading files.\n        ((BaseDirectoryWrapper) dir).setCheckIndexOnClose(false);\n      }\n      if (dir instanceof MockDirectoryWrapper) {\n        // makes this test really slow\n        ((MockDirectoryWrapper) dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n\n      AtomicBoolean stop = new AtomicBoolean();\n      Thread writer = new Thread(() -> {\n        try {\n          for (int i = 0, max = RandomizedTest.randomIntBetween(500, 1000); i < max; i++) {\n            String fileName = \"file-\" + i;\n            try (IndexOutput output = dir.createOutput(fileName, newIOContext(random()))) {\n              assert output != null;\n              // Add some lags so that the other thread can read the content of the directory.\n              Thread.yield();\n            }\n            assertTrue(slowFileExists(dir, fileName));\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        } finally {\n          stop.set(true);\n        }\n      });\n\n      Thread reader = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong());\n          while (!stop.get()) {\n            String [] files = Arrays.stream(dir.listAll())\n                .filter(name -> !ExtrasFS.isExtra(name)) // Ignore anything from ExtraFS.\n                .toArray(String[]::new);\n\n            if (files.length > 0) {\n              do {\n                String file = RandomPicks.randomFrom(rnd, files);\n                try (IndexInput input = dir.openInput(file, newIOContext(random()))) {\n                  // Just open, nothing else.\n                  assert input != null;\n                } catch (AccessDeniedException e) {\n                  // Access denied is allowed for files for which the output is still open (MockDirectoryWriter enforces\n                  // this, for example). Since we don't synchronize with the writer thread, just ignore it.\n                } catch (IOException e) {\n                  throw new UncheckedIOException(\"Something went wrong when opening: \" + file, e);\n                }\n              } while (rnd.nextInt(3) != 0); // Sometimes break and list files again.\n            }\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      });\n\n      reader.start();\n      writer.start();\n\n      writer.join();\n      reader.join();\n    }\n  }\n\n","sourceOld":"  public void testThreadSafetyInListAll() throws Exception {\n    try (Directory dir = getDirectory(createTempDir(\"testThreadSafety\"))) {\n      if (dir instanceof BaseDirectoryWrapper) {\n        // we are not making a real index, just writing, reading files.\n        ((BaseDirectoryWrapper) dir).setCheckIndexOnClose(false);\n      }\n      if (dir instanceof MockDirectoryWrapper) {\n        // makes this test really slow\n        ((MockDirectoryWrapper) dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n\n      AtomicBoolean stop = new AtomicBoolean();\n      Thread writer = new Thread(() -> {\n        try {\n          for (int i = 0, max = RandomizedTest.randomIntBetween(500, 1000); i < max; i++) {\n            String fileName = \"file-\" + i;\n            try (IndexOutput output = dir.createOutput(fileName, newIOContext(random()))) {\n              // Add some lags so that the other thread can read the content of the directory.\n              Thread.yield();\n            }\n            assertTrue(slowFileExists(dir, fileName));\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        } finally {\n          stop.set(true);\n        }\n      });\n\n      Thread reader = new Thread(() -> {\n        try {\n          Random rnd = new Random(RandomizedTest.randomLong());\n          while (!stop.get()) {\n            String [] files = Arrays.stream(dir.listAll())\n                .filter(name -> !ExtrasFS.isExtra(name)) // Ignore anything from ExtraFS.\n                .toArray(String[]::new);\n\n            if (files.length > 0) {\n              do {\n                String file = RandomPicks.randomFrom(rnd, files);\n                try (IndexInput input = dir.openInput(file, newIOContext(random()))) {\n                  // Just open, nothing else.\n                } catch (AccessDeniedException e) {\n                  // Access denied is allowed for files for which the output is still open (MockDirectoryWriter enforces\n                  // this, for example). Since we don't synchronize with the writer thread, just ignore it.\n                } catch (IOException e) {\n                  throw new UncheckedIOException(\"Something went wrong when opening: \" + file, e);\n                }\n              } while (rnd.nextInt(3) != 0); // Sometimes break and list files again.\n            }\n          }\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      });\n\n      reader.start();\n      writer.start();\n\n      writer.join();\n      reader.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3d203e5c4d54b6f6e78e98d2342905df37f816f6":["f3adea0022cffaaa592081efed775a7b8bf86b51"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["3d203e5c4d54b6f6e78e98d2342905df37f816f6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30c21918ef3ad23e254f39cb0cd6c86851fcb993":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"f3adea0022cffaaa592081efed775a7b8bf86b51":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["30c21918ef3ad23e254f39cb0cd6c86851fcb993"]},"commit2Childs":{"3d203e5c4d54b6f6e78e98d2342905df37f816f6":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["30c21918ef3ad23e254f39cb0cd6c86851fcb993"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f3adea0022cffaaa592081efed775a7b8bf86b51"],"30c21918ef3ad23e254f39cb0cd6c86851fcb993":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f3adea0022cffaaa592081efed775a7b8bf86b51":["3d203e5c4d54b6f6e78e98d2342905df37f816f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}