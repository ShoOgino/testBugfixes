{"path":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","commits":[{"id":"9499b09dd7d06d975f31e59a9b00653a86f9cad2","date":1343325589,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9a56a9413181d8bfb3992127b4ed8a1814a97209"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a56a9413181d8bfb3992127b4ed8a1814a97209","date":1361897644,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d36289b32dcfabd6c7130691192ff72363543c1","date":1433668098,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public synchronized void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c876aba909b05165f3d290e26b5a4121214f553","date":1449340310,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.getConstructor().newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32694fa3bbb984d3054955e48d946708e16110ff","date":1585155816,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#reload(ClassLoader).mjava","sourceNew":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);\n    for (final S service : ServiceLoader.load(clazz, classloader)) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  /** \n   * Reloads the internal SPI list from the given {@link ClassLoader}.\n   * Changes to the service list are visible after the method ends, all\n   * iterators ({@link #iterator()},...) stay consistent. \n   * \n   * <p><b>NOTE:</b> Only new service providers are added, existing ones are\n   * never removed or replaced.\n   * \n   * <p><em>This method is expensive and should only be called for discovery\n   * of new service providers on the given classpath/classloader!</em>\n   */\n  public void reload(ClassLoader classloader) {\n    Objects.requireNonNull(classloader, \"classloader\");\n    final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.getConstructor().newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9a56a9413181d8bfb3992127b4ed8a1814a97209"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["1c876aba909b05165f3d290e26b5a4121214f553"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"32694fa3bbb984d3054955e48d946708e16110ff":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9a56a9413181d8bfb3992127b4ed8a1814a97209":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"1c876aba909b05165f3d290e26b5a4121214f553":["2d36289b32dcfabd6c7130691192ff72363543c1"],"2d36289b32dcfabd6c7130691192ff72363543c1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["32694fa3bbb984d3054955e48d946708e16110ff"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2d36289b32dcfabd6c7130691192ff72363543c1"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["32694fa3bbb984d3054955e48d946708e16110ff"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"32694fa3bbb984d3054955e48d946708e16110ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["aba371508186796cc6151d8223a5b4e16d02e26e","9a56a9413181d8bfb3992127b4ed8a1814a97209","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"9a56a9413181d8bfb3992127b4ed8a1814a97209":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aba371508186796cc6151d8223a5b4e16d02e26e","9499b09dd7d06d975f31e59a9b00653a86f9cad2","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"1c876aba909b05165f3d290e26b5a4121214f553":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"2d36289b32dcfabd6c7130691192ff72363543c1":["1c876aba909b05165f3d290e26b5a4121214f553"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}