{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField]).mjava","commits":[{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":1,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String).mjava","sourceNew":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma seperate list of refinement values corrisponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n    (List<String> pivotFields,\n     String refinements,\n     List<StatsField> statsFields) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<Integer>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs, statsFields));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs, statsFields));\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma seperate list of refinement values corrisponding to each field in the pivot, or null if there are no refinements\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle(List<String> pivotFields,\n                                                                  String refinements) throws IOException {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<Integer>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs));\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"658218bdad5bc0415007e8e0cd9197fb3b0298af","date":1423726262,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField]).mjava","sourceNew":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma separate list of refinement values corresponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n    (List<String> pivotFields,\n     String refinements,\n     List<StatsField> statsFields) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<Integer>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs, statsFields));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs, statsFields));\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma seperate list of refinement values corrisponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n    (List<String> pivotFields,\n     String refinements,\n     List<StatsField> statsFields) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<Integer>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs, statsFields));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs, statsFields));\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c169312e8f621502de0661c48a43e492983cd28a","date":1423728604,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField]).mjava","sourceNew":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma separate list of refinement values corresponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n    (List<String> pivotFields,\n     String refinements,\n     List<StatsField> statsFields) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs, statsFields));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs, statsFields));\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma separate list of refinement values corresponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n    (List<String> pivotFields,\n     String refinements,\n     List<StatsField> statsFields) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<Integer>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs, statsFields));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs, statsFields));\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField],ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField]).mjava","sourceNew":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma separate list of refinement values corresponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n    (List<String> pivotFields,\n     String refinements,\n     List<StatsField> statsFields,\n     final ParsedParams parsed) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(parsed.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, parsed);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(parsed.key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, parsed, statsFields));\n    } else {\n      pivotResponse.add(parsed.key, doPivots(facetCounts, field, null, fnames, vnames, parsed, statsFields));\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma separate list of refinement values corresponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n    (List<String> pivotFields,\n     String refinements,\n     List<StatsField> statsFields) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(this.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, this.docs);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, this.docs, statsFields));\n    } else {\n      pivotResponse.add(key, doPivots(facetCounts, field, null, fnames, vnames, this.docs, statsFields));\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c169312e8f621502de0661c48a43e492983cd28a":["658218bdad5bc0415007e8e0cd9197fb3b0298af"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["c169312e8f621502de0661c48a43e492983cd28a"],"658218bdad5bc0415007e8e0cd9197fb3b0298af":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"]},"commit2Childs":{"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["658218bdad5bc0415007e8e0cd9197fb3b0298af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"c169312e8f621502de0661c48a43e492983cd28a":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"658218bdad5bc0415007e8e0cd9197fb3b0298af":["c169312e8f621502de0661c48a43e492983cd28a"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}