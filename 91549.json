{"path":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","commits":[{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    assert merge.registerDone;\n\n    int mergedDocCount;\n    boolean success = false;\n\n    try {\n\n      if (merge.info == null)\n        mergeInit(merge);\n\n      if (infoStream != null)\n        message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n      mergedDocCount = mergeMiddle(merge);\n\n      success = true;\n    } finally {\n      synchronized(this) {\n        if (!success && infoStream != null)\n          message(\"hit exception during merge\");\n\n        mergeFinish(merge);\n\n        // This merge (and, generally, any change to the\n        // segments) may now enable new merges, so we call\n        // merge policy & update pending merges.\n        if (success && !merge.isAborted() && !closed && !closing)\n          updatePendingMerges(merge.optimize);\n\n        runningMerges.remove(merge);\n\n        // Optimize may be waiting on the final optimize\n        // merge to finish; and finishMerges() may be\n        // waiting for all merges to finish:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["346d5897e4c4e77ed5dbd31f7730ff30973d5971","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6a1f29c9b1051488fd5fa7d56c98db5f4388408","date":1196281221,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    assert merge.registerDone;\n\n    boolean success = false;\n\n    try {\n\n      if (merge.info == null)\n        mergeInit(merge);\n\n      if (infoStream != null)\n        message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n      mergeMiddle(merge);\n\n      success = true;\n    } finally {\n      synchronized(this) {\n        if (!success && infoStream != null)\n          message(\"hit exception during merge\");\n\n        mergeFinish(merge);\n\n        // This merge (and, generally, any change to the\n        // segments) may now enable new merges, so we call\n        // merge policy & update pending merges.\n        if (success && !merge.isAborted() && !closed && !closing)\n          updatePendingMerges(merge.optimize);\n\n        runningMerges.remove(merge);\n\n        // Optimize may be waiting on the final optimize\n        // merge to finish; and finishMerges() may be\n        // waiting for all merges to finish:\n        notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    assert merge.registerDone;\n\n    int mergedDocCount;\n    boolean success = false;\n\n    try {\n\n      if (merge.info == null)\n        mergeInit(merge);\n\n      if (infoStream != null)\n        message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n      mergedDocCount = mergeMiddle(merge);\n\n      success = true;\n    } finally {\n      synchronized(this) {\n        if (!success && infoStream != null)\n          message(\"hit exception during merge\");\n\n        mergeFinish(merge);\n\n        // This merge (and, generally, any change to the\n        // segments) may now enable new merges, so we call\n        // merge policy & update pending merges.\n        if (success && !merge.isAborted() && !closed && !closing)\n          updatePendingMerges(merge.optimize);\n\n        runningMerges.remove(merge);\n\n        // Optimize may be waiting on the final optimize\n        // merge to finish; and finishMerges() may be\n        // waiting for all merges to finish:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"52e9359ec09a0ce311e6ce95805998bebc7f7fd0","date":1196417385,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    assert merge.registerDone;\n    assert !merge.optimize || merge.maxNumSegmentsOptimize > 0;\n\n    boolean success = false;\n\n    try {\n\n      if (merge.info == null)\n        mergeInit(merge);\n\n      if (infoStream != null)\n        message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n      mergeMiddle(merge);\n\n      success = true;\n    } finally {\n      synchronized(this) {\n        try {\n          if (!success && infoStream != null)\n            message(\"hit exception during merge\");\n\n          mergeFinish(merge);\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        } finally {\n          runningMerges.remove(merge);\n          // Optimize may be waiting on the final optimize\n          // merge to finish; and finishMerges() may be\n          // waiting for all merges to finish:\n          notifyAll();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    assert merge.registerDone;\n\n    boolean success = false;\n\n    try {\n\n      if (merge.info == null)\n        mergeInit(merge);\n\n      if (infoStream != null)\n        message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n      mergeMiddle(merge);\n\n      success = true;\n    } finally {\n      synchronized(this) {\n        if (!success && infoStream != null)\n          message(\"hit exception during merge\");\n\n        mergeFinish(merge);\n\n        // This merge (and, generally, any change to the\n        // segments) may now enable new merges, so we call\n        // merge policy & update pending merges.\n        if (success && !merge.isAborted() && !closed && !closing)\n          updatePendingMerges(merge.optimize);\n\n        runningMerges.remove(merge);\n\n        // Optimize may be waiting on the final optimize\n        // merge to finish; and finishMerges() may be\n        // waiting for all merges to finish:\n        notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"346d5897e4c4e77ed5dbd31f7730ff30973d5971","date":1198317988,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    assert merge.registerDone;\n    assert !merge.optimize || merge.maxNumSegmentsOptimize > 0;\n\n    boolean success = false;\n\n    try {\n\n      try {\n        if (merge.info == null)\n          mergeInit(merge);\n\n        if (infoStream != null)\n          message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n        mergeMiddle(merge);\n        success = true;\n      } catch (MergePolicy.MergeAbortedException e) {\n        merge.setException(e);\n        addMergeException(merge);\n        // We can ignore this exception, unless the merge\n        // involves segments from external directories, in\n        // which case we must throw it so, for example, the\n        // rollbackTransaction code in addIndexes* is\n        // executed.\n        if (merge.isExternal)\n          throw e;\n      }\n    } finally {\n      synchronized(this) {\n        try {\n          if (!success && infoStream != null)\n            message(\"hit exception during merge\");\n\n          mergeFinish(merge);\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        } finally {\n          runningMerges.remove(merge);\n          // Optimize may be waiting on the final optimize\n          // merge to finish; and finishMerges() may be\n          // waiting for all merges to finish:\n          notifyAll();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    assert merge.registerDone;\n    assert !merge.optimize || merge.maxNumSegmentsOptimize > 0;\n\n    boolean success = false;\n\n    try {\n\n      if (merge.info == null)\n        mergeInit(merge);\n\n      if (infoStream != null)\n        message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n      mergeMiddle(merge);\n\n      success = true;\n    } finally {\n      synchronized(this) {\n        try {\n          if (!success && infoStream != null)\n            message(\"hit exception during merge\");\n\n          mergeFinish(merge);\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        } finally {\n          runningMerges.remove(merge);\n          // Optimize may be waiting on the final optimize\n          // merge to finish; and finishMerges() may be\n          // waiting for all merges to finish:\n          notifyAll();\n        }\n      }\n    }\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf","b6a1f29c9b1051488fd5fa7d56c98db5f4388408"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n\n      try {\n        mergeInit(merge);\n\n        if (infoStream != null)\n          message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n        mergeMiddle(merge);\n        success = true;\n      } catch (MergePolicy.MergeAbortedException e) {\n        merge.setException(e);\n        addMergeException(merge);\n        // We can ignore this exception, unless the merge\n        // involves segments from external directories, in\n        // which case we must throw it so, for example, the\n        // rollbackTransaction code in addIndexes* is\n        // executed.\n        if (merge.isExternal)\n          throw e;\n      }\n    } finally {\n      synchronized(this) {\n        try {\n\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            addMergeException(merge);\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        } finally {\n          runningMerges.remove(merge);\n          // Optimize may be waiting on the final optimize\n          // merge to finish; and finishMerges() may be\n          // waiting for all merges to finish:\n          notifyAll();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    assert merge.registerDone;\n    assert !merge.optimize || merge.maxNumSegmentsOptimize > 0;\n\n    boolean success = false;\n\n    try {\n\n      try {\n        if (merge.info == null)\n          mergeInit(merge);\n\n        if (infoStream != null)\n          message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n        mergeMiddle(merge);\n        success = true;\n      } catch (MergePolicy.MergeAbortedException e) {\n        merge.setException(e);\n        addMergeException(merge);\n        // We can ignore this exception, unless the merge\n        // involves segments from external directories, in\n        // which case we must throw it so, for example, the\n        // rollbackTransaction code in addIndexes* is\n        // executed.\n        if (merge.isExternal)\n          throw e;\n      }\n    } finally {\n      synchronized(this) {\n        try {\n          if (!success && infoStream != null)\n            message(\"hit exception during merge\");\n\n          mergeFinish(merge);\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        } finally {\n          runningMerges.remove(merge);\n          // Optimize may be waiting on the final optimize\n          // merge to finish; and finishMerges() may be\n          // waiting for all merges to finish:\n          notifyAll();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63","date":1204234542,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (MergePolicy.MergeAbortedException e) {\n          merge.setException(e);\n          addMergeException(merge);\n          // We can ignore this exception, unless the merge\n          // involves segments from external directories, in\n          // which case we must throw it so, for example, the\n          // rollbackTransaction code in addIndexes* is\n          // executed.\n          if (merge.isExternal)\n            throw e;\n        }\n      } finally {\n        synchronized(this) {\n          try {\n\n            mergeFinish(merge);\n\n            if (!success) {\n              if (infoStream != null)\n                message(\"hit exception during merge\");\n              addMergeException(merge);\n              if (merge.info != null && !segmentInfos.contains(merge.info))\n                deleter.refresh(merge.info.name);\n            }\n\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            if (success && !merge.isAborted() && !closed && !closing)\n              updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n          } finally {\n            runningMerges.remove(merge);\n            // Optimize may be waiting on the final optimize\n            // merge to finish; and finishMerges() may be\n            // waiting for all merges to finish:\n            notifyAll();\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n\n      try {\n        mergeInit(merge);\n\n        if (infoStream != null)\n          message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n        mergeMiddle(merge);\n        success = true;\n      } catch (MergePolicy.MergeAbortedException e) {\n        merge.setException(e);\n        addMergeException(merge);\n        // We can ignore this exception, unless the merge\n        // involves segments from external directories, in\n        // which case we must throw it so, for example, the\n        // rollbackTransaction code in addIndexes* is\n        // executed.\n        if (merge.isExternal)\n          throw e;\n      }\n    } finally {\n      synchronized(this) {\n        try {\n\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            addMergeException(merge);\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        } finally {\n          runningMerges.remove(merge);\n          // Optimize may be waiting on the final optimize\n          // merge to finish; and finishMerges() may be\n          // waiting for all merges to finish:\n          notifyAll();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["cd488f50316362b01a7f67b11a96796b9652e3e5","b6b0122d107a2f2a35007aca038d2a7fde039266"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2586f96f60332eb97ecd2934b0763791462568b2","date":1220116589,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (MergePolicy.MergeAbortedException e) {\n          merge.setException(e);\n          addMergeException(merge);\n\n          // We can ignore this exception, unless the merge\n          // involves segments from external directories, in\n          // which case we must throw it so, for example, the\n          // rollbackTransaction code in addIndexes* is\n          // executed.\n          if (merge.isExternal)\n            throw e;\n        }\n      } finally {\n        synchronized(this) {\n          try {\n\n            mergeFinish(merge);\n\n            if (!success) {\n              if (infoStream != null)\n                message(\"hit exception during merge\");\n              addMergeException(merge);\n              if (merge.info != null && !segmentInfos.contains(merge.info))\n                deleter.refresh(merge.info.name);\n            }\n\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            if (success && !merge.isAborted() && !closed && !closing)\n              updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n          } finally {\n            runningMerges.remove(merge);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (MergePolicy.MergeAbortedException e) {\n          merge.setException(e);\n          addMergeException(merge);\n          // We can ignore this exception, unless the merge\n          // involves segments from external directories, in\n          // which case we must throw it so, for example, the\n          // rollbackTransaction code in addIndexes* is\n          // executed.\n          if (merge.isExternal)\n            throw e;\n        }\n      } finally {\n        synchronized(this) {\n          try {\n\n            mergeFinish(merge);\n\n            if (!success) {\n              if (infoStream != null)\n                message(\"hit exception during merge\");\n              addMergeException(merge);\n              if (merge.info != null && !segmentInfos.contains(merge.info))\n                deleter.refresh(merge.info.name);\n            }\n\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            if (success && !merge.isAborted() && !closed && !closing)\n              updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n          } finally {\n            runningMerges.remove(merge);\n            // Optimize may be waiting on the final optimize\n            // merge to finish; and finishMerges() may be\n            // waiting for all merges to finish:\n            notifyAll();\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","bugFix":null,"bugIntro":["b6b0122d107a2f2a35007aca038d2a7fde039266"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6b0122d107a2f2a35007aca038d2a7fde039266","date":1222123999,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          try {\n\n            mergeFinish(merge);\n\n            if (!success) {\n              if (infoStream != null)\n                message(\"hit exception during merge\");\n              if (merge.info != null && !segmentInfos.contains(merge.info))\n                deleter.refresh(merge.info.name);\n            }\n\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            if (success && !merge.isAborted() && !closed && !closing)\n              updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n          } finally {\n            runningMerges.remove(merge);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (MergePolicy.MergeAbortedException e) {\n          merge.setException(e);\n          addMergeException(merge);\n\n          // We can ignore this exception, unless the merge\n          // involves segments from external directories, in\n          // which case we must throw it so, for example, the\n          // rollbackTransaction code in addIndexes* is\n          // executed.\n          if (merge.isExternal)\n            throw e;\n        }\n      } finally {\n        synchronized(this) {\n          try {\n\n            mergeFinish(merge);\n\n            if (!success) {\n              if (infoStream != null)\n                message(\"hit exception during merge\");\n              addMergeException(merge);\n              if (merge.info != null && !segmentInfos.contains(merge.info))\n                deleter.refresh(merge.info.name);\n            }\n\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            if (success && !merge.isAborted() && !closed && !closing)\n              updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n          } finally {\n            runningMerges.remove(merge);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","bugFix":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63","2586f96f60332eb97ecd2934b0763791462568b2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          try {\n\n            mergeFinish(merge);\n\n            if (!success) {\n              if (infoStream != null)\n                message(\"hit exception during merge\");\n              if (merge.info != null && !segmentInfos.contains(merge.info))\n                deleter.refresh(merge.info.name);\n            }\n\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            if (success && !merge.isAborted() && !closed && !closing)\n              updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n          } finally {\n            runningMerges.remove(merge);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd488f50316362b01a7f67b11a96796b9652e3e5","date":1241121034,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","bugFix":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6df892b1b163e38ed793ded3e54e4e17f6b4548e","date":1244679712,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f5ebdc25cde64f1bd2b6337721292bdd1b23f714","date":1258737814,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (infoStream != null) {\n      message(\"merge time \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8984893e6e8e4eaf80ab863dafae092a2e9b0eaa","date":1261431504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (infoStream != null) {\n      message(\"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (infoStream != null) {\n      message(\"merge time \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (infoStream != null) {\n      message(\"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   */\n\n  final void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream != null)\n            message(\"now merge\\n  merge=\" + merge.segString(directory) + \"\\n  merge=\" + merge + \"\\n  index=\" + segString());\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream != null)\n              message(\"hit exception during merge\");\n            if (merge.info != null && !segmentInfos.contains(merge.info))\n              deleter.refresh(merge.info.name);\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && !closed && !closing)\n            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (infoStream != null) {\n      message(\"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["52e9359ec09a0ce311e6ce95805998bebc7f7fd0"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["b6b0122d107a2f2a35007aca038d2a7fde039266"],"b6a1f29c9b1051488fd5fa7d56c98db5f4388408":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"cd488f50316362b01a7f67b11a96796b9652e3e5":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63":["e82780afe6097066eb5befb86e9432f077667e3d"],"b6b0122d107a2f2a35007aca038d2a7fde039266":["2586f96f60332eb97ecd2934b0763791462568b2"],"52e9359ec09a0ce311e6ce95805998bebc7f7fd0":["b6a1f29c9b1051488fd5fa7d56c98db5f4388408"],"8984893e6e8e4eaf80ab863dafae092a2e9b0eaa":["f5ebdc25cde64f1bd2b6337721292bdd1b23f714"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f5ebdc25cde64f1bd2b6337721292bdd1b23f714":["6df892b1b163e38ed793ded3e54e4e17f6b4548e"],"e82780afe6097066eb5befb86e9432f077667e3d":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"6df892b1b163e38ed793ded3e54e4e17f6b4548e":["cd488f50316362b01a7f67b11a96796b9652e3e5"],"2586f96f60332eb97ecd2934b0763791462568b2":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["8984893e6e8e4eaf80ab863dafae092a2e9b0eaa"]},"commit2Childs":{"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["e82780afe6097066eb5befb86e9432f077667e3d"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["b6a1f29c9b1051488fd5fa7d56c98db5f4388408"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["cd488f50316362b01a7f67b11a96796b9652e3e5"],"b6a1f29c9b1051488fd5fa7d56c98db5f4388408":["52e9359ec09a0ce311e6ce95805998bebc7f7fd0"],"cd488f50316362b01a7f67b11a96796b9652e3e5":["6df892b1b163e38ed793ded3e54e4e17f6b4548e"],"01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63":["2586f96f60332eb97ecd2934b0763791462568b2"],"52e9359ec09a0ce311e6ce95805998bebc7f7fd0":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"b6b0122d107a2f2a35007aca038d2a7fde039266":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"8984893e6e8e4eaf80ab863dafae092a2e9b0eaa":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"f5ebdc25cde64f1bd2b6337721292bdd1b23f714":["8984893e6e8e4eaf80ab863dafae092a2e9b0eaa"],"e82780afe6097066eb5befb86e9432f077667e3d":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63"],"2586f96f60332eb97ecd2934b0763791462568b2":["b6b0122d107a2f2a35007aca038d2a7fde039266"],"6df892b1b163e38ed793ded3e54e4e17f6b4548e":["f5ebdc25cde64f1bd2b6337721292bdd1b23f714"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}