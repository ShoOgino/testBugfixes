{"path":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","commits":[{"id":"0713b289be914e52cc2ec942aeb7306f0593a787","date":1361852996,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"/dev/null","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(true);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n        \n        int theByte;\n        if (req.getMethod().equals(\"POST\")) {\n          BufferedInputStream bis = new BufferedInputStream(\n              req.getInputStream());\n          BufferedOutputStream os = new BufferedOutputStream(\n              con.getOutputStream());\n          try {\n            while ((theByte = bis.read()) != -1) {\n              os.write(theByte);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(bis);\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        BufferedInputStream bis = new BufferedInputStream(con.getInputStream());\n        ServletOutputStream os = resp.getOutputStream();\n        try {\n          while ((theByte = bis.read()) != -1) {\n            os.write(theByte);\n          }\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);\n          IOUtils.closeQuietly(bis);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      // return exception\n      resp.getWriter().println(e.getStackTrace().toString());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"This node forword query failed: \" + coreUrl);\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bdbf39907159fb6c6ebcb07321b58b45233fb461","6784d0cc613dc1ee97030eaaa5e0754edc22d164","42718e80a64f6c041cebc3699ab91cd1c928444d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32602a1a43a5a8782a888221a5df3766ddd775aa","date":1361859686,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(true);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n        \n        int theByte;\n        if (req.getMethod().equals(\"POST\")) {\n          BufferedInputStream bis = new BufferedInputStream(\n              req.getInputStream());\n          BufferedOutputStream os = new BufferedOutputStream(\n              con.getOutputStream());\n          try {\n            while ((theByte = bis.read()) != -1) {\n              os.write(theByte);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(bis);\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        BufferedInputStream bis = new BufferedInputStream(con.getInputStream());\n        ServletOutputStream os = resp.getOutputStream();\n        try {\n          while ((theByte = bis.read()) != -1) {\n            os.write(theByte);\n          }\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);\n          IOUtils.closeQuietly(bis);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(true);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n        \n        int theByte;\n        if (req.getMethod().equals(\"POST\")) {\n          BufferedInputStream bis = new BufferedInputStream(\n              req.getInputStream());\n          BufferedOutputStream os = new BufferedOutputStream(\n              con.getOutputStream());\n          try {\n            while ((theByte = bis.read()) != -1) {\n              os.write(theByte);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(bis);\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        BufferedInputStream bis = new BufferedInputStream(con.getInputStream());\n        ServletOutputStream os = resp.getOutputStream();\n        try {\n          while ((theByte = bis.read()) != -1) {\n            os.write(theByte);\n          }\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);\n          IOUtils.closeQuietly(bis);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      // return exception\n      resp.getWriter().println(e.getStackTrace().toString());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"This node forword query failed: \" + coreUrl);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["79411f20952f22cd9b944ff6f25f051554ff8e53"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"016a6c7d38336dfae6a2460d8e31f77bfc267a5b","date":1362102642,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n        \n        int theByte;\n        if (req.getMethod().equals(\"POST\")) {\n          BufferedInputStream bis = new BufferedInputStream(\n              req.getInputStream());\n          BufferedOutputStream os = new BufferedOutputStream(\n              con.getOutputStream());\n          try {\n            while ((theByte = bis.read()) != -1) {\n              os.write(theByte);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(bis);\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        BufferedInputStream bis = new BufferedInputStream(con.getInputStream());\n        ServletOutputStream os = resp.getOutputStream();\n        try {\n          while ((theByte = bis.read()) != -1) {\n            os.write(theByte);\n          }\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);\n          IOUtils.closeQuietly(bis);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(true);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n        \n        int theByte;\n        if (req.getMethod().equals(\"POST\")) {\n          BufferedInputStream bis = new BufferedInputStream(\n              req.getInputStream());\n          BufferedOutputStream os = new BufferedOutputStream(\n              con.getOutputStream());\n          try {\n            while ((theByte = bis.read()) != -1) {\n              os.write(theByte);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(bis);\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        BufferedInputStream bis = new BufferedInputStream(con.getInputStream());\n        ServletOutputStream os = resp.getOutputStream();\n        try {\n          while ((theByte = bis.read()) != -1) {\n            os.write(theByte);\n          }\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);\n          IOUtils.closeQuietly(bis);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9a991f13add08bf2cd2fe7a41043916326c7b22f","date":1362331805,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is = req.getInputStream();\n        OutputStream os = con.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n        } finally {\n          IOUtils.closeQuietly(os);\n          IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n        \n        int theByte;\n        if (req.getMethod().equals(\"POST\")) {\n          BufferedInputStream bis = new BufferedInputStream(\n              req.getInputStream());\n          BufferedOutputStream os = new BufferedOutputStream(\n              con.getOutputStream());\n          try {\n            while ((theByte = bis.read()) != -1) {\n              os.write(theByte);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(bis);\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        BufferedInputStream bis = new BufferedInputStream(con.getInputStream());\n        ServletOutputStream os = resp.getOutputStream();\n        try {\n          while ((theByte = bis.read()) != -1) {\n            os.write(theByte);\n          }\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);\n          IOUtils.closeQuietly(bis);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","date":1362545433,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (\"POST\".equals(req.getMethod())) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is = req.getInputStream();\n        OutputStream os = con.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n        } finally {\n          IOUtils.closeQuietly(os);\n          IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["bdbf39907159fb6c6ebcb07321b58b45233fb461"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1cfa38e36fa296bb93d77df7d5556257dffa4535","date":1362635543,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (\"POST\".equals(req.getMethod())) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    \n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (\"POST\".equals(req.getMethod())) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"480bba3e18aeec829f3c7c65a764e2cb454f7c10","date":1366342235,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (\"POST\".equals(req.getMethod())) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (\"POST\".equals(req.getMethod())) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0487111b13a097388de940beb54caebd9c544e4","date":1384535732,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (\"POST\".equals(req.getMethod())) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator<Entry<String,List<String>>> i = con.getHeaderFields().entrySet().iterator(); i.hasNext();) {\n          Map.Entry<String,List<String>> mapEntry = i.next();\n          String header = mapEntry.getKey();\n          \n          // We pull out these two headers below because they can cause chunked\n          // encoding issues with Tomcat and certain clients\n          if (header != null && !header.equals(TRANSFER_ENCODING_HEADER)\n              && !header.equals(CONNECTION_HEADER)) {\n            for (String value : mapEntry.getValue()) {\n              resp.addHeader(mapEntry.getKey(), value);\n            }\n          }\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (\"POST\".equals(req.getMethod())) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bdbf39907159fb6c6ebcb07321b58b45233fb461","date":1384795117,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      boolean isPostRequest = \"POST\".equals(req.getMethod());\n      \n      if (isPostRequest) {\n        con.setDoOutput(true);\n      }\n      con.setDoInput(true);\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (isPostRequest) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator<Entry<String,List<String>>> i = con.getHeaderFields().entrySet().iterator(); i.hasNext();) {\n          Map.Entry<String,List<String>> mapEntry = i.next();\n          String header = mapEntry.getKey();\n          \n          // We pull out these two headers below because they can cause chunked\n          // encoding issues with Tomcat and certain clients\n          if (header != null && !header.equals(TRANSFER_ENCODING_HEADER)\n              && !header.equals(CONNECTION_HEADER)) {\n            for (String value : mapEntry.getValue()) {\n              resp.addHeader(mapEntry.getKey(), value);\n            }\n          }\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (\"POST\".equals(req.getMethod())) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator<Entry<String,List<String>>> i = con.getHeaderFields().entrySet().iterator(); i.hasNext();) {\n          Map.Entry<String,List<String>> mapEntry = i.next();\n          String header = mapEntry.getKey();\n          \n          // We pull out these two headers below because they can cause chunked\n          // encoding issues with Tomcat and certain clients\n          if (header != null && !header.equals(TRANSFER_ENCODING_HEADER)\n              && !header.equals(CONNECTION_HEADER)) {\n            for (String value : mapEntry.getValue()) {\n              resp.addHeader(mapEntry.getKey(), value);\n            }\n          }\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":["0713b289be914e52cc2ec942aeb7306f0593a787","054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee1ef27d4745020ed103d5f0ce07b61ce288aa21","date":1384798766,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      \n      if (isPostOrPutRequest) {\n        con.setDoOutput(true);\n      }\n      con.setDoInput(true);\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (isPostOrPutRequest) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator<Entry<String,List<String>>> i = con.getHeaderFields().entrySet().iterator(); i.hasNext();) {\n          Map.Entry<String,List<String>> mapEntry = i.next();\n          String header = mapEntry.getKey();\n          \n          // We pull out these two headers below because they can cause chunked\n          // encoding issues with Tomcat and certain clients\n          if (header != null && !header.equals(TRANSFER_ENCODING_HEADER)\n              && !header.equals(CONNECTION_HEADER)) {\n            for (String value : mapEntry.getValue()) {\n              resp.addHeader(mapEntry.getKey(), value);\n            }\n          }\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      boolean isPostRequest = \"POST\".equals(req.getMethod());\n      \n      if (isPostRequest) {\n        con.setDoOutput(true);\n      }\n      con.setDoInput(true);\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (isPostRequest) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator<Entry<String,List<String>>> i = con.getHeaderFields().entrySet().iterator(); i.hasNext();) {\n          Map.Entry<String,List<String>> mapEntry = i.next();\n          String header = mapEntry.getKey();\n          \n          // We pull out these two headers below because they can cause chunked\n          // encoding issues with Tomcat and certain clients\n          if (header != null && !header.equals(TRANSFER_ENCODING_HEADER)\n              && !header.equals(CONNECTION_HEADER)) {\n            for (String value : mapEntry.getValue()) {\n              resp.addHeader(mapEntry.getKey(), value);\n            }\n          }\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      \n      if (isPostOrPutRequest) {\n        con.setDoOutput(true);\n      }\n      con.setDoInput(true);\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (isPostOrPutRequest) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator<Entry<String,List<String>>> i = con.getHeaderFields().entrySet().iterator(); i.hasNext();) {\n          Map.Entry<String,List<String>> mapEntry = i.next();\n          String header = mapEntry.getKey();\n          \n          // We pull out these two headers below because they can cause chunked\n          // encoding issues with Tomcat and certain clients\n          if (header != null && !header.equals(TRANSFER_ENCODING_HEADER)\n              && !header.equals(CONNECTION_HEADER)) {\n            for (String value : mapEntry.getValue()) {\n              resp.addHeader(mapEntry.getKey(), value);\n            }\n          }\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      con.setDoOutput(true);\n      con.setDoInput(true);\n      for (Enumeration e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement().toString();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (\"POST\".equals(req.getMethod())) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator i = con.getHeaderFields().entrySet().iterator(); i\n            .hasNext();) {\n          Map.Entry mapEntry = (Map.Entry) i.next();\n          if (mapEntry.getKey() != null) resp.setHeader(mapEntry.getKey()\n              .toString(), ((List) mapEntry.getValue()).get(0).toString());\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0e8b6c653fa7a4e4ce7df62d16488c8876de46d","date":1391905882,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      HttpEntity httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      con.setRequestMethod(req.getMethod());\n      con.setUseCaches(false);\n      \n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      \n      if (isPostOrPutRequest) {\n        con.setDoOutput(true);\n      }\n      con.setDoInput(true);\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        con.setRequestProperty(headerName, req.getHeader(headerName));\n      }\n      try {\n        con.connect();\n\n        InputStream is;\n        OutputStream os;\n        if (isPostOrPutRequest) {\n          is = req.getInputStream();\n          os = con.getOutputStream(); // side effect: method is switched to POST\n          try {\n            IOUtils.copyLarge(is, os);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(os);\n            IOUtils.closeQuietly(is);  // TODO: I thought we weren't supposed to explicitly close servlet streams\n          }\n        }\n        \n        resp.setStatus(con.getResponseCode());\n        \n        for (Iterator<Entry<String,List<String>>> i = con.getHeaderFields().entrySet().iterator(); i.hasNext();) {\n          Map.Entry<String,List<String>> mapEntry = i.next();\n          String header = mapEntry.getKey();\n          \n          // We pull out these two headers below because they can cause chunked\n          // encoding issues with Tomcat and certain clients\n          if (header != null && !header.equals(TRANSFER_ENCODING_HEADER)\n              && !header.equals(CONNECTION_HEADER)) {\n            for (String value : mapEntry.getValue()) {\n              resp.addHeader(mapEntry.getKey(), value);\n            }\n          }\n        }\n        \n        resp.setCharacterEncoding(con.getContentEncoding());\n        resp.setContentType(con.getContentType());\n        \n        is = con.getInputStream();\n        os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      } finally {\n        con.disconnect();\n      }\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["42718e80a64f6c041cebc3699ab91cd1c928444d","26ab43e1a461b9c1d9db0739ee0eb5caed8bc521"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f0a87e3f134b6a3b6b329749e63f5b8eab5f2a21","date":1391908052,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      HttpEntity httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"afb6bf9ce227ab6aac5068547e286ecc958b8b9d","date":1394661169,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d805d691fbf3ca8aafa5397568ec761790b88622","date":1417093891,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      URL url = new URL(urlstr);\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n      \n      URL url = new URL(urlstr);\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      URL url = new URL(urlstr);\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","bugFix":["0713b289be914e52cc2ec942aeb7306f0593a787"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a760e2135dfe20a04dea360873d4de1c6a0280bb","date":1430762855,"type":5,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n\n      String queryString = req.getQueryString();\n\n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equals(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["9746d4d1a8506463e6a4647323b07467d8ed843b","42718e80a64f6c041cebc3699ab91cd1c928444d","ba4636b043a2611cc1c43bad730a78b6d5bc4a5f"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"bdbf39907159fb6c6ebcb07321b58b45233fb461":["b0487111b13a097388de940beb54caebd9c544e4"],"32602a1a43a5a8782a888221a5df3766ddd775aa":["0713b289be914e52cc2ec942aeb7306f0593a787"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["f0a87e3f134b6a3b6b329749e63f5b8eab5f2a21"],"480bba3e18aeec829f3c7c65a764e2cb454f7c10":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"0713b289be914e52cc2ec942aeb7306f0593a787":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"b0487111b13a097388de940beb54caebd9c544e4":["480bba3e18aeec829f3c7c65a764e2cb454f7c10"],"9a991f13add08bf2cd2fe7a41043916326c7b22f":["016a6c7d38336dfae6a2460d8e31f77bfc267a5b"],"d805d691fbf3ca8aafa5397568ec761790b88622":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"],"016a6c7d38336dfae6a2460d8e31f77bfc267a5b":["32602a1a43a5a8782a888221a5df3766ddd775aa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["480bba3e18aeec829f3c7c65a764e2cb454f7c10","ee1ef27d4745020ed103d5f0ce07b61ce288aa21"],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["9a991f13add08bf2cd2fe7a41043916326c7b22f"],"f0a87e3f134b6a3b6b329749e63f5b8eab5f2a21":["f0e8b6c653fa7a4e4ce7df62d16488c8876de46d"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["d805d691fbf3ca8aafa5397568ec761790b88622"],"f0e8b6c653fa7a4e4ce7df62d16488c8876de46d":["ee1ef27d4745020ed103d5f0ce07b61ce288aa21"],"ee1ef27d4745020ed103d5f0ce07b61ce288aa21":["bdbf39907159fb6c6ebcb07321b58b45233fb461"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a760e2135dfe20a04dea360873d4de1c6a0280bb"]},"commit2Childs":{"bdbf39907159fb6c6ebcb07321b58b45233fb461":["ee1ef27d4745020ed103d5f0ce07b61ce288aa21"],"32602a1a43a5a8782a888221a5df3766ddd775aa":["016a6c7d38336dfae6a2460d8e31f77bfc267a5b"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["480bba3e18aeec829f3c7c65a764e2cb454f7c10"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["d805d691fbf3ca8aafa5397568ec761790b88622"],"480bba3e18aeec829f3c7c65a764e2cb454f7c10":["b0487111b13a097388de940beb54caebd9c544e4","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"0713b289be914e52cc2ec942aeb7306f0593a787":["32602a1a43a5a8782a888221a5df3766ddd775aa"],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b0487111b13a097388de940beb54caebd9c544e4":["bdbf39907159fb6c6ebcb07321b58b45233fb461"],"9a991f13add08bf2cd2fe7a41043916326c7b22f":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"d805d691fbf3ca8aafa5397568ec761790b88622":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"016a6c7d38336dfae6a2460d8e31f77bfc267a5b":["9a991f13add08bf2cd2fe7a41043916326c7b22f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0713b289be914e52cc2ec942aeb7306f0593a787"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"f0a87e3f134b6a3b6b329749e63f5b8eab5f2a21":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"ee1ef27d4745020ed103d5f0ce07b61ce288aa21":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","f0e8b6c653fa7a4e4ce7df62d16488c8876de46d"],"f0e8b6c653fa7a4e4ce7df62d16488c8876de46d":["f0a87e3f134b6a3b6b329749e63f5b8eab5f2a21"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}