{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","commits":[{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfoPerCommit#files().mjava","sourceNew":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<String>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any field updates files\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    return files;\n  }\n\n","sourceOld":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<String>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any field updates files\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","sourceNew":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any field updates files\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    return files;\n  }\n\n","sourceOld":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<String>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any field updates files\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0567bdc5c86c94ced64201187cfcef2417d76dda","date":1400678298,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","sourceNew":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any per-gen updates files. This can go away when we\n    // get rid of genUpdatesFiles (6.0)\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    // must separately add any field updates files\n    for (Set<String> updatefiles : dvUpdatesFiles.values()) {\n      files.addAll(updatefiles);\n    }\n    \n    // must separately add fieldInfos files\n    files.addAll(fieldInfosFiles);\n    \n    return files;\n  }\n\n","sourceOld":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any field updates files\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    return files;\n  }\n\n","bugFix":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a656b32c3aa151037a8c52e9b134acc3cbf482bc","date":1400688195,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","sourceNew":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any per-gen updates files. This can go away when we\n    // get rid of genUpdatesFiles (6.0)\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    // must separately add any field updates files\n    for (Set<String> updatefiles : dvUpdatesFiles.values()) {\n      files.addAll(updatefiles);\n    }\n    \n    // must separately add fieldInfos files\n    files.addAll(fieldInfosFiles);\n    \n    return files;\n  }\n\n","sourceOld":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any field updates files\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","sourceNew":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any per-gen updates files. This can go away when we\n    // get rid of genUpdatesFiles (6.0)\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    // must separately add any field updates files\n    for (Set<String> updatefiles : dvUpdatesFiles.values()) {\n      files.addAll(updatefiles);\n    }\n    \n    // must separately add fieldInfos files\n    files.addAll(fieldInfosFiles);\n    \n    return files;\n  }\n\n","sourceOld":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any field updates files\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3","date":1417215914,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo#files().mjava","sourceNew":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n    \n    // must separately add any field updates files\n    for (Set<String> updatefiles : dvUpdatesFiles.values()) {\n      files.addAll(updatefiles);\n    }\n    \n    // must separately add fieldInfos files\n    files.addAll(fieldInfosFiles);\n    \n    return files;\n  }\n\n","sourceOld":"  /** Returns all files in use by this segment. */\n  public Collection<String> files() throws IOException {\n    // Start from the wrapped info's files:\n    Collection<String> files = new HashSet<>(info.files());\n\n    // TODO we could rely on TrackingDir.getCreatedFiles() (like we do for\n    // updates) and then maybe even be able to remove LiveDocsFormat.files().\n    \n    // Must separately add any live docs files:\n    info.getCodec().liveDocsFormat().files(this, files);\n\n    // Must separately add any per-gen updates files. This can go away when we\n    // get rid of genUpdatesFiles (6.0)\n    for (Set<String> updateFiles : genUpdatesFiles.values()) {\n      files.addAll(updateFiles);\n    }\n    \n    // must separately add any field updates files\n    for (Set<String> updatefiles : dvUpdatesFiles.values()) {\n      files.addAll(updatefiles);\n    }\n    \n    // must separately add fieldInfos files\n    files.addAll(fieldInfosFiles);\n    \n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0567bdc5c86c94ced64201187cfcef2417d76dda":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","0567bdc5c86c94ced64201187cfcef2417d76dda"],"6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3":["0567bdc5c86c94ced64201187cfcef2417d76dda"],"b7605579001505896d48b07160075a5c8b8e128e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","0567bdc5c86c94ced64201187cfcef2417d76dda"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0567bdc5c86c94ced64201187cfcef2417d76dda","a656b32c3aa151037a8c52e9b134acc3cbf482bc","b7605579001505896d48b07160075a5c8b8e128e"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"0567bdc5c86c94ced64201187cfcef2417d76dda":["a656b32c3aa151037a8c52e9b134acc3cbf482bc","6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3","b7605579001505896d48b07160075a5c8b8e128e"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":[],"6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7605579001505896d48b07160075a5c8b8e128e":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a656b32c3aa151037a8c52e9b134acc3cbf482bc","b7605579001505896d48b07160075a5c8b8e128e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}