{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 14: break;\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 16: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 19: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 20: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 21: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 14: break;\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 16: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 19: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 20: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 21: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f","date":1343307395,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 14: break;\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 10: \n          { return EMAIL_TYPE;\n          }\n        case 16: break;\n        case 9: \n          { return URL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 19: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 20: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 21: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 14: break;\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 16: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 19: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 20: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 21: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b48c161f84bef42b6b1a2efa87dc10deed2b3c06","date":1343344525,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 14: break;\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 16: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 19: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 20: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 21: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 14: break;\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 10: \n          { return EMAIL_TYPE;\n          }\n        case 16: break;\n        case 9: \n          { return URL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 19: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 20: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 21: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 14: break;\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 16: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 19: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 20: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 21: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["642482b1894f655a5d50337c3b96950676d054da"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  @Override\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  @Override\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afbb42e9134b051569d1254e7d3761828b6ce777","date":1374607937,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  @Override\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e11957f037cb0e1ec7cccb5becc3c3a53a7bd450","date":1374668463,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  @Override\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  @Override\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"481ed0d60df1f0f855349428910585954e5e1f4d","date":1386348703,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break; /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["642482b1894f655a5d50337c3b96950676d054da"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break; /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break;/* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"642482b1894f655a5d50337c3b96950676d054da","date":1389338004,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3137: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3138: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { /* Break so we don't hit fall-through warning: */ break; /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 12: break;\n        case 2: \n          { return WORD_TYPE;\n          }\n        case 13: break;\n        case 3: \n          { return NUMERIC_TYPE;\n          }\n        case 14: break;\n        case 4: \n          { return KATAKANA_TYPE;\n          }\n        case 15: break;\n        case 5: \n          { return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 16: break;\n        case 6: \n          { return IDEOGRAPHIC_TYPE;\n          }\n        case 17: break;\n        case 7: \n          { return HIRAGANA_TYPE;\n          }\n        case 18: break;\n        case 8: \n          { return HANGUL_TYPE;\n          }\n        case 19: break;\n        case 9: \n          { return EMAIL_TYPE;\n          }\n        case 20: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 21: break;\n        case 11: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { return WORD_TYPE;\n          }\n        case 22: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return StandardTokenizerInterface.YYEOF;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":["3f9c32789f4702d5cbb33bd153808068a4c43e3a","481ed0d60df1f0f855349428910585954e5e1f4d","351c452f1c3ded97338e6d3db2b585c5f89b0410","683d3f90dda2bbb999c3ce855706d74563a53680","3a5582df130621a89a150891fa2fa492fdce73e0","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"332f58fec4e90b4d935b849bea7eb88536169068","date":1392769235,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3117: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3118: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3137: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3138: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94185aeed87213a54a74b0cd88fc578ac3857038","date":1392769483,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3137: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3138: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3117: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3118: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ad5fe21659ccbd1b4b08c826dd6b7d8bb7294d9","date":1392772884,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3117: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3118: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3137: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3138: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f0c6d69031c318c402abfe2543736076e80a132","date":1404594729,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 2910: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 2911: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 6;\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3117: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 3118: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a00a330aa7b6581139157a63c90e68c7c8fc63c8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1a1d77f7d47c04c0e559ece71d63fce1d394342","date":1412834287,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return YYEOF;\n            }\n            case 2910: break;\n            case AVOID_BAD_URL: {\n              return YYEOF;\n            }\n            case 2911: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 2910: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 2911: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return YYEOF;\n            }\n            case 2910: break;\n            case AVOID_BAD_URL: {\n              return YYEOF;\n            }\n            case 2911: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 2910: break;\n            case AVOID_BAD_URL: {\n              return StandardTokenizerInterface.YYEOF;\n            }\n            case 2911: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a00a330aa7b6581139157a63c90e68c7c8fc63c8","date":1507309559,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return YYEOF;\n            }\n            case 12852: break;\n            case AVOID_BAD_URL: {\n              return YYEOF;\n            }\n            case 12853: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return YYEOF;\n            }\n            case 2910: break;\n            case AVOID_BAD_URL: {\n              return YYEOF;\n            }\n            case 2911: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":["4f0c6d69031c318c402abfe2543736076e80a132"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8c6c25f6bab8e32b731127f3516a593af8a3305","date":1546972429,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return YYEOF;\n            }  // fall though\n            case 12893: break;\n            case AVOID_BAD_URL: {\n              return YYEOF;\n            }  // fall though\n            case 12894: break;\n            default:\n        return YYEOF;\n        }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { /* Break so we don't hit fall-through warning: */ break; /* Not numeric, word, ideographic, hiragana, emoji or SE Asian -- ignore it. */\n            } \n            // fall through\n          case 16: break;\n          case 2: \n            { yybegin(YYINITIAL); return EMOJI_TYPE;\n            } \n            // fall through\n          case 17: break;\n          case 3: \n            { yybegin(YYINITIAL); return WORD_TYPE;\n            } \n            // fall through\n          case 18: break;\n          case 4: \n            { yybegin(YYINITIAL); return HANGUL_TYPE;\n            } \n            // fall through\n          case 19: break;\n          case 5: \n            { yybegin(YYINITIAL); return NUMERIC_TYPE;\n            } \n            // fall through\n          case 20: break;\n          case 6: \n            { yybegin(YYINITIAL); return KATAKANA_TYPE;\n            } \n            // fall through\n          case 21: break;\n          case 7: \n            { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n            } \n            // fall through\n          case 22: break;\n          case 8: \n            { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n            } \n            // fall through\n          case 23: break;\n          case 9: \n            { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n            } \n            // fall through\n          case 24: break;\n          case 10: \n            { yybegin(YYINITIAL); return EMAIL_TYPE;\n            } \n            // fall through\n          case 25: break;\n          case 11: \n            { return URL_TYPE;\n            } \n            // fall through\n          case 26: break;\n          case 12: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { yybegin(YYINITIAL); return URL_TYPE;\n            } \n            // fall through\n          case 27: break;\n          case 13: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { yybegin(AVOID_BAD_URL); yypushback(yylength());\n            } \n            // fall through\n          case 28: break;\n          case 14: \n            { yybegin(YYINITIAL); return URL_TYPE;\n            } \n            // fall through\n          case 29: break;\n          case 15: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n            { yybegin(YYINITIAL); return WORD_TYPE;\n            } \n            // fall through\n          case 30: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { yybegin(YYINITIAL); /* Not numeric, word, ideographic, hiragana, or SE Asian -- ignore it. */\n          }\n        case 15: break;\n        case 2: \n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 16: break;\n        case 3: \n          { yybegin(YYINITIAL); return HANGUL_TYPE;\n          }\n        case 17: break;\n        case 4: \n          { yybegin(YYINITIAL); return NUMERIC_TYPE;\n          }\n        case 18: break;\n        case 5: \n          { yybegin(YYINITIAL); return KATAKANA_TYPE;\n          }\n        case 19: break;\n        case 6: \n          { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n          }\n        case 20: break;\n        case 7: \n          { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n          }\n        case 21: break;\n        case 8: \n          { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n          }\n        case 22: break;\n        case 9: \n          { yybegin(YYINITIAL); return EMAIL_TYPE;\n          }\n        case 23: break;\n        case 10: \n          { return URL_TYPE;\n          }\n        case 24: break;\n        case 11: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 25: break;\n        case 12: \n          // lookahead expression with fixed lookahead length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n          { yybegin(AVOID_BAD_URL); yypushback(yylength());\n          }\n        case 26: break;\n        case 13: \n          { yybegin(YYINITIAL); return URL_TYPE;\n          }\n        case 27: break;\n        case 14: \n          // lookahead expression with fixed base length\n          zzMarkedPos = Character.offsetByCodePoints\n              (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n          { yybegin(YYINITIAL); return WORD_TYPE;\n          }\n        case 28: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return YYEOF;\n            }\n            case 12852: break;\n            case AVOID_BAD_URL: {\n              return YYEOF;\n            }\n            case 12853: break;\n            default:\n            return YYEOF;\n            }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"313c36388b6cae6118f75a1860ad0ba0af7e1344","date":1601279368,"type":5,"author":"Tomoko Uchida","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/email/UAX29URLEmailTokenizerImpl#getNextToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizerImpl#getNextToken().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return YYEOF;\n            }  // fall though\n            case 12893: break;\n            case AVOID_BAD_URL: {\n              return YYEOF;\n            }  // fall though\n            case 12894: break;\n            default:\n        return YYEOF;\n        }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { /* Break so we don't hit fall-through warning: */ break; /* Not numeric, word, ideographic, hiragana, emoji or SE Asian -- ignore it. */\n            } \n            // fall through\n          case 16: break;\n          case 2: \n            { yybegin(YYINITIAL); return EMOJI_TYPE;\n            } \n            // fall through\n          case 17: break;\n          case 3: \n            { yybegin(YYINITIAL); return WORD_TYPE;\n            } \n            // fall through\n          case 18: break;\n          case 4: \n            { yybegin(YYINITIAL); return HANGUL_TYPE;\n            } \n            // fall through\n          case 19: break;\n          case 5: \n            { yybegin(YYINITIAL); return NUMERIC_TYPE;\n            } \n            // fall through\n          case 20: break;\n          case 6: \n            { yybegin(YYINITIAL); return KATAKANA_TYPE;\n            } \n            // fall through\n          case 21: break;\n          case 7: \n            { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n            } \n            // fall through\n          case 22: break;\n          case 8: \n            { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n            } \n            // fall through\n          case 23: break;\n          case 9: \n            { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n            } \n            // fall through\n          case 24: break;\n          case 10: \n            { yybegin(YYINITIAL); return EMAIL_TYPE;\n            } \n            // fall through\n          case 25: break;\n          case 11: \n            { return URL_TYPE;\n            } \n            // fall through\n          case 26: break;\n          case 12: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { yybegin(YYINITIAL); return URL_TYPE;\n            } \n            // fall through\n          case 27: break;\n          case 13: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { yybegin(AVOID_BAD_URL); yypushback(yylength());\n            } \n            // fall through\n          case 28: break;\n          case 14: \n            { yybegin(YYINITIAL); return URL_TYPE;\n            } \n            // fall through\n          case 29: break;\n          case 15: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n            { yybegin(YYINITIAL); return WORD_TYPE;\n            } \n            // fall through\n          case 30: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public int getNextToken() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n            switch (zzLexicalState) {\n            case YYINITIAL: {\n              return YYEOF;\n            }  // fall though\n            case 12893: break;\n            case AVOID_BAD_URL: {\n              return YYEOF;\n            }  // fall though\n            case 12894: break;\n            default:\n        return YYEOF;\n        }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { /* Break so we don't hit fall-through warning: */ break; /* Not numeric, word, ideographic, hiragana, emoji or SE Asian -- ignore it. */\n            } \n            // fall through\n          case 16: break;\n          case 2: \n            { yybegin(YYINITIAL); return EMOJI_TYPE;\n            } \n            // fall through\n          case 17: break;\n          case 3: \n            { yybegin(YYINITIAL); return WORD_TYPE;\n            } \n            // fall through\n          case 18: break;\n          case 4: \n            { yybegin(YYINITIAL); return HANGUL_TYPE;\n            } \n            // fall through\n          case 19: break;\n          case 5: \n            { yybegin(YYINITIAL); return NUMERIC_TYPE;\n            } \n            // fall through\n          case 20: break;\n          case 6: \n            { yybegin(YYINITIAL); return KATAKANA_TYPE;\n            } \n            // fall through\n          case 21: break;\n          case 7: \n            { yybegin(YYINITIAL); return IDEOGRAPHIC_TYPE;\n            } \n            // fall through\n          case 22: break;\n          case 8: \n            { yybegin(YYINITIAL); return HIRAGANA_TYPE;\n            } \n            // fall through\n          case 23: break;\n          case 9: \n            { yybegin(YYINITIAL); return SOUTH_EAST_ASIAN_TYPE;\n            } \n            // fall through\n          case 24: break;\n          case 10: \n            { yybegin(YYINITIAL); return EMAIL_TYPE;\n            } \n            // fall through\n          case 25: break;\n          case 11: \n            { return URL_TYPE;\n            } \n            // fall through\n          case 26: break;\n          case 12: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { yybegin(YYINITIAL); return URL_TYPE;\n            } \n            // fall through\n          case 27: break;\n          case 13: \n            // lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { yybegin(AVOID_BAD_URL); yypushback(yylength());\n            } \n            // fall through\n          case 28: break;\n          case 14: \n            { yybegin(YYINITIAL); return URL_TYPE;\n            } \n            // fall through\n          case 29: break;\n          case 15: \n            // lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 6);\n            { yybegin(YYINITIAL); return WORD_TYPE;\n            } \n            // fall through\n          case 30: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376","7530de27b87b961b51f01bd1299b7004d46e8823"],"55980207f1977bd1463465de1659b821347e2fa8":["4f0c6d69031c318c402abfe2543736076e80a132","c1a1d77f7d47c04c0e559ece71d63fce1d394342"],"b8c6c25f6bab8e32b731127f3516a593af8a3305":["a00a330aa7b6581139157a63c90e68c7c8fc63c8"],"6ad5fe21659ccbd1b4b08c826dd6b7d8bb7294d9":["94185aeed87213a54a74b0cd88fc578ac3857038"],"332f58fec4e90b4d935b849bea7eb88536169068":["642482b1894f655a5d50337c3b96950676d054da"],"642482b1894f655a5d50337c3b96950676d054da":["481ed0d60df1f0f855349428910585954e5e1f4d"],"94185aeed87213a54a74b0cd88fc578ac3857038":["332f58fec4e90b4d935b849bea7eb88536169068"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b48c161f84bef42b6b1a2efa87dc10deed2b3c06":["c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f"],"afbb42e9134b051569d1254e7d3761828b6ce777":["7530de27b87b961b51f01bd1299b7004d46e8823"],"4f0c6d69031c318c402abfe2543736076e80a132":["6ad5fe21659ccbd1b4b08c826dd6b7d8bb7294d9"],"313c36388b6cae6118f75a1860ad0ba0af7e1344":["b8c6c25f6bab8e32b731127f3516a593af8a3305"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["7530de27b87b961b51f01bd1299b7004d46e8823"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["e11957f037cb0e1ec7cccb5becc3c3a53a7bd450","481ed0d60df1f0f855349428910585954e5e1f4d"],"a00a330aa7b6581139157a63c90e68c7c8fc63c8":["c1a1d77f7d47c04c0e559ece71d63fce1d394342"],"e11957f037cb0e1ec7cccb5becc3c3a53a7bd450":["7530de27b87b961b51f01bd1299b7004d46e8823","afbb42e9134b051569d1254e7d3761828b6ce777"],"481ed0d60df1f0f855349428910585954e5e1f4d":["e11957f037cb0e1ec7cccb5becc3c3a53a7bd450"],"7530de27b87b961b51f01bd1299b7004d46e8823":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"c1a1d77f7d47c04c0e559ece71d63fce1d394342":["4f0c6d69031c318c402abfe2543736076e80a132"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["313c36388b6cae6118f75a1860ad0ba0af7e1344"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["b48c161f84bef42b6b1a2efa87dc10deed2b3c06"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"55980207f1977bd1463465de1659b821347e2fa8":[],"b8c6c25f6bab8e32b731127f3516a593af8a3305":["313c36388b6cae6118f75a1860ad0ba0af7e1344"],"6ad5fe21659ccbd1b4b08c826dd6b7d8bb7294d9":["4f0c6d69031c318c402abfe2543736076e80a132"],"332f58fec4e90b4d935b849bea7eb88536169068":["94185aeed87213a54a74b0cd88fc578ac3857038"],"642482b1894f655a5d50337c3b96950676d054da":["332f58fec4e90b4d935b849bea7eb88536169068"],"94185aeed87213a54a74b0cd88fc578ac3857038":["6ad5fe21659ccbd1b4b08c826dd6b7d8bb7294d9"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f"],"c6fd7790eae69bb7d4fc5a8070a3abf015a5fb3f":["b48c161f84bef42b6b1a2efa87dc10deed2b3c06"],"b48c161f84bef42b6b1a2efa87dc10deed2b3c06":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"afbb42e9134b051569d1254e7d3761828b6ce777":["e11957f037cb0e1ec7cccb5becc3c3a53a7bd450"],"4f0c6d69031c318c402abfe2543736076e80a132":["55980207f1977bd1463465de1659b821347e2fa8","c1a1d77f7d47c04c0e559ece71d63fce1d394342"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"313c36388b6cae6118f75a1860ad0ba0af7e1344":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"a00a330aa7b6581139157a63c90e68c7c8fc63c8":["b8c6c25f6bab8e32b731127f3516a593af8a3305"],"e11957f037cb0e1ec7cccb5becc3c3a53a7bd450":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","481ed0d60df1f0f855349428910585954e5e1f4d"],"481ed0d60df1f0f855349428910585954e5e1f4d":["642482b1894f655a5d50337c3b96950676d054da","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","afbb42e9134b051569d1254e7d3761828b6ce777","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","e11957f037cb0e1ec7cccb5becc3c3a53a7bd450"],"c1a1d77f7d47c04c0e559ece71d63fce1d394342":["55980207f1977bd1463465de1659b821347e2fa8","a00a330aa7b6581139157a63c90e68c7c8fc63c8"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","55980207f1977bd1463465de1659b821347e2fa8","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}