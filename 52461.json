{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","commits":[{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores, boolean doMaxScore) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c370507e5521b2eb998530736f1c19b851ed5a","date":1531911305,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, doDocScores, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, doDocScores, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        TopFieldDocs topDocs = r.collectorResult;\n        if (doDocScores) {\n          TopFieldCollector.populateScores(topDocs.scoreDocs, searcher, query);\n        }\n        return new DrillSidewaysResult(r.facets, topDocs);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        TopFieldDocs topDocs = hitCollector.topDocs();\n        if (doDocScores) {\n          TopFieldCollector.populateScores(topDocs.scoreDocs, searcher, query);\n        }\n        return new DrillSidewaysResult(r.facets, topDocs);\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, doDocScores, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, doDocScores, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Query,FieldDoc,int,Sort,boolean).mjava","sourceNew":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, Integer.MAX_VALUE);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        TopFieldDocs topDocs = r.collectorResult;\n        if (doDocScores) {\n          TopFieldCollector.populateScores(topDocs.scoreDocs, searcher, query);\n        }\n        return new DrillSidewaysResult(r.facets, topDocs);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, Integer.MAX_VALUE);\n        DrillSidewaysResult r = search(query, hitCollector);\n        TopFieldDocs topDocs = hitCollector.topDocs();\n        if (doDocScores) {\n          TopFieldCollector.populateScores(topDocs.scoreDocs, searcher, query);\n        }\n        return new DrillSidewaysResult(r.facets, topDocs);\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by {@link Sort}, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,\n          boolean doDocScores) throws IOException {\n    if (filter != null) {\n      query = new DrillDownQuery(config, filter, query);\n    }\n    if (sort != null) {\n      int limit = searcher.getIndexReader().maxDoc();\n      if (limit == 0) {\n        limit = 1; // the collector does not alow numHits = 0\n      }\n      final int fTopN = Math.min(topN, limit);\n\n      if (executor != null) { // We have an executor, let use the multi-threaded version\n\n        final CollectorManager<TopFieldCollector, TopFieldDocs> collectorManager =\n                new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n                  @Override\n                  public TopFieldCollector newCollector() throws IOException {\n                    return TopFieldCollector.create(sort, fTopN, after, true);\n                  }\n\n                  @Override\n                  public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n                    final TopFieldDocs[] topFieldDocs = new TopFieldDocs[collectors.size()];\n                    int pos = 0;\n                    for (TopFieldCollector collector : collectors)\n                      topFieldDocs[pos++] = collector.topDocs();\n                    return TopDocs.merge(sort, topN, topFieldDocs);\n                  }\n\n                };\n        ConcurrentDrillSidewaysResult<TopFieldDocs> r = search(query, collectorManager);\n        TopFieldDocs topDocs = r.collectorResult;\n        if (doDocScores) {\n          TopFieldCollector.populateScores(topDocs.scoreDocs, searcher, query);\n        }\n        return new DrillSidewaysResult(r.facets, topDocs);\n\n      } else {\n\n        final TopFieldCollector hitCollector =\n                TopFieldCollector.create(sort, fTopN, after, true);\n        DrillSidewaysResult r = search(query, hitCollector);\n        TopFieldDocs topDocs = hitCollector.topDocs();\n        if (doDocScores) {\n          TopFieldCollector.populateScores(topDocs.scoreDocs, searcher, query);\n        }\n        return new DrillSidewaysResult(r.facets, topDocs);\n      }\n    } else {\n      return search(after, query, topN);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"04c370507e5521b2eb998530736f1c19b851ed5a":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["04c370507e5521b2eb998530736f1c19b851ed5a"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"04c370507e5521b2eb998530736f1c19b851ed5a":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","04c370507e5521b2eb998530736f1c19b851ed5a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["fe3c6364bed04a73ad0884b05401d80ce96027a9"]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}