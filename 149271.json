{"path":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","commits":[{"id":"4853751884e55469b8cc1abab8fa0788eab240c9","date":1394565067,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      long startStallTime = 0;\n      while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n        // This means merging has fallen too far behind: we\n        // have already created maxMergeCount threads, and\n        // now there's at least one more merge pending.\n        // Note that only maxThreadCount of\n        // those created merge threads will actually be\n        // running; the rest will be paused (see\n        // updateMergeThreads).  We stall this producer\n        // thread to prevent creation of new segments,\n        // until merging has caught up:\n        startStallTime = System.currentTimeMillis();\n        if (verbose()) {\n          message(\"    too many merges; stalling...\");\n        }\n        try {\n          wait();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      }\n\n      if (verbose()) {\n        if (startStallTime != 0) {\n          message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n        }\n      }\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      long startStallTime = 0;\n      while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n        // This means merging has fallen too far behind: we\n        // have already created maxMergeCount threads, and\n        // now there's at least one more merge pending.\n        // Note that only maxThreadCount of\n        // those created merge threads will actually be\n        // running; the rest will be paused (see\n        // updateMergeThreads).  We stall this producer\n        // thread to prevent creation of new segments,\n        // until merging has caught up:\n        startStallTime = System.currentTimeMillis();\n        if (verbose()) {\n          message(\"    too many merges; stalling...\");\n        }\n        try {\n          wait();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      }\n\n      if (verbose()) {\n        if (startStallTime != 0) {\n          message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n        }\n      }\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b","date":1416355396,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall();\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      long startStallTime = 0;\n      while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n        // This means merging has fallen too far behind: we\n        // have already created maxMergeCount threads, and\n        // now there's at least one more merge pending.\n        // Note that only maxThreadCount of\n        // those created merge threads will actually be\n        // running; the rest will be paused (see\n        // updateMergeThreads).  We stall this producer\n        // thread to prevent creation of new segments,\n        // until merging has caught up:\n        startStallTime = System.currentTimeMillis();\n        if (verbose()) {\n          message(\"    too many merges; stalling...\");\n        }\n        try {\n          wait();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      }\n\n      if (verbose()) {\n        if (startStallTime != 0) {\n          message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n        }\n      }\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1db7bd2068060be0b68fcca95c8270c7cb60f6c","date":1419003415,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n    initMaxMergesAndThreads();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall();\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall();\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall(writer);\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      updateIOThrottle(merge);\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n    initMaxMergesAndThreads();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall();\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["c6cc2915889370c9313ee1741da315e976bdd574"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b9ce8a999aa42f91053eec065df8a25c9c311ea4","date":1420535836,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    if (trigger == MergeTrigger.CLOSING) {\n      // Disable throttling on close:\n      targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      updateMergeThreads();\n    }\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall(writer);\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      updateIOThrottle(merge);\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall(writer);\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      updateIOThrottle(merge);\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba45a22312e230cf8c9ada0f1199670ecf767d07","date":1420626256,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    if (trigger == MergeTrigger.CLOSING) {\n      // Disable throttling on close:\n      targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      updateMergeThreads();\n    }\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall(writer);\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      updateIOThrottle(merge);\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    if (trigger == MergeTrigger.CLOSING) {\n      // Disable throttling on close:\n      targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      updateMergeThreads();\n    }\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall(writer);\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      updateIOThrottle(merge);\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6cc2915889370c9313ee1741da315e976bdd574","date":1422111819,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    if (trigger == MergeTrigger.CLOSING) {\n      // Disable throttling on close:\n      targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      updateMergeThreads();\n    }\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      if (maybeStall(writer) == false) {\n        break;\n      }\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      updateIOThrottle(merge);\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    if (trigger == MergeTrigger.CLOSING) {\n      // Disable throttling on close:\n      targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      updateMergeThreads();\n    }\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      maybeStall(writer);\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      updateIOThrottle(merge);\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    if (trigger == MergeTrigger.CLOSING) {\n      // Disable throttling on close:\n      targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      updateMergeThreads();\n    }\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      if (maybeStall(writer) == false) {\n        break;\n      }\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread newMergeThread = getMergeThread(writer, merge);\n        mergeThreads.add(newMergeThread);\n\n        updateIOThrottle(newMergeThread.merge, newMergeThread.rateLimiter);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + newMergeThread.getName() + \"]\");\n        }\n\n        newMergeThread.start();\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    if (trigger == MergeTrigger.CLOSING) {\n      // Disable throttling on close:\n      targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      updateMergeThreads();\n    }\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      if (maybeStall(writer) == false) {\n        break;\n      }\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      updateIOThrottle(merge);\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2178aefcd4690bd53785e9673e2c918cdb64165","date":1587583605,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    if (trigger == MergeTrigger.CLOSING) {\n      // Disable throttling on close:\n      targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      updateMergeThreads();\n    }\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      if (maybeStall(writer) == false) {\n        break;\n      }\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread newMergeThread = getMergeThread(writer, merge);\n        mergeThreads.add(newMergeThread);\n\n        updateIOThrottle(newMergeThread.merge, newMergeThread.rateLimiter);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + newMergeThread.getName() + \"]\");\n        }\n\n        newMergeThread.start();\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    initDynamicDefaults(writer);\n\n    if (trigger == MergeTrigger.CLOSING) {\n      // Disable throttling on close:\n      targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      updateMergeThreads();\n    }\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      if (maybeStall(writer) == false) {\n        break;\n      }\n\n      OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread newMergeThread = getMergeThread(writer, merge);\n        mergeThreads.add(newMergeThread);\n\n        updateIOThrottle(newMergeThread.merge, newMergeThread.rateLimiter);\n\n        if (verbose()) {\n          message(\"    launch new thread [\" + newMergeThread.getName() + \"]\");\n        }\n\n        newMergeThread.start();\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d2178aefcd4690bd53785e9673e2c918cdb64165":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"4853751884e55469b8cc1abab8fa0788eab240c9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c6cc2915889370c9313ee1741da315e976bdd574":["ba45a22312e230cf8c9ada0f1199670ecf767d07"],"ba45a22312e230cf8c9ada0f1199670ecf767d07":["b9ce8a999aa42f91053eec065df8a25c9c311ea4"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["c6cc2915889370c9313ee1741da315e976bdd574"],"f1db7bd2068060be0b68fcca95c8270c7cb60f6c":["7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b"],"7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b":["4853751884e55469b8cc1abab8fa0788eab240c9"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["f1db7bd2068060be0b68fcca95c8270c7cb60f6c"],"b9ce8a999aa42f91053eec065df8a25c9c311ea4":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2178aefcd4690bd53785e9673e2c918cdb64165"]},"commit2Childs":{"d2178aefcd4690bd53785e9673e2c918cdb64165":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4853751884e55469b8cc1abab8fa0788eab240c9":["7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4853751884e55469b8cc1abab8fa0788eab240c9"],"c6cc2915889370c9313ee1741da315e976bdd574":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"ba45a22312e230cf8c9ada0f1199670ecf767d07":["c6cc2915889370c9313ee1741da315e976bdd574"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["d2178aefcd4690bd53785e9673e2c918cdb64165"],"f1db7bd2068060be0b68fcca95c8270c7cb60f6c":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b":["f1db7bd2068060be0b68fcca95c8270c7cb60f6c"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["b9ce8a999aa42f91053eec065df8a25c9c311ea4"],"b9ce8a999aa42f91053eec065df8a25c9c311ea4":["ba45a22312e230cf8c9ada0f1199670ecf767d07"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}