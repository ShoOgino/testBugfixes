{"path":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","commits":[{"id":"954ae83b7dfacaa33d48ea056448ae11f7745a93","date":1571867711,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9ac35455ac6925b629dedf2c0c52c0a8d5cb55b6","d218decf811b7a0a4d86218c54c79c74a962374b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1a6448412ce640b28861f4c00f899484a9adac1","date":1573627357,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc09d7c591d6661c79bcdfd1c661da97e638804d","date":1574295916,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["9ac35455ac6925b629dedf2c0c52c0a8d5cb55b6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4a9d755535ef8154bc3ac90a6c963e91d44b71c","date":1576507807,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b945b8f5bba0303382bc69d60c0c287714f23328","date":1576586294,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60c716cf818aff6857d8490cd0fb8b5aa432408f","date":1577074826,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' },\" +\n          \" create-expressible: {name: mincopy , class: 'mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric'}\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n   /* new V2Request.Builder(\"/c/\"+COLLECTIONORALIAS+\"/config\").withMethod(SolrRequest.METHOD.POST)\n        .withPayload(\"{add-expressible: {name: mincopy , class: org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric}}\")\n    .build().process(cluster.getSolrClient());\n\n  ModifiableSolrParams _params = new ModifiableSolrParams();\n  QueryRequest query = new QueryRequest(new MapSolrParams(\"action\",\"plugins\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/stream\");\n  NamedList<Object> rsp = cluster.getSolrClient().request(query);\n  assertEquals(\"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\", rsp._getStr(\"/plugins/mincopy\", null));\n  _params = new ModifiableSolrParams();\n  query = new QueryRequest(new MapSolrParams(\"componentName\",\"mincopy\", \"meta\" ,\"true\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/config/expressible\");\n  rsp = cluster.getSolrClient().request(query);\n\n    System.out.println();*/\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["9ac35455ac6925b629dedf2c0c52c0a8d5cb55b6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","date":1577276097,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' },\" +\n          \" create-expressible: {name: mincopy , class: 'mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric'}\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n   /* new V2Request.Builder(\"/c/\"+COLLECTIONORALIAS+\"/config\").withMethod(SolrRequest.METHOD.POST)\n        .withPayload(\"{add-expressible: {name: mincopy , class: org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric}}\")\n    .build().process(cluster.getSolrClient());\n\n  ModifiableSolrParams _params = new ModifiableSolrParams();\n  QueryRequest query = new QueryRequest(new MapSolrParams(\"action\",\"plugins\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/stream\");\n  NamedList<Object> rsp = cluster.getSolrClient().request(query);\n  assertEquals(\"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\", rsp._getStr(\"/plugins/mincopy\", null));\n  _params = new ModifiableSolrParams();\n  query = new QueryRequest(new MapSolrParams(\"componentName\",\"mincopy\", \"meta\" ,\"true\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/config/expressible\");\n  rsp = cluster.getSolrClient().request(query);\n\n    System.out.println();*/\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' }\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d218decf811b7a0a4d86218c54c79c74a962374b","date":1578632144,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n//      cluster.getZkClient().makePath(\"/keys/exe\", true);\n//      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' },\" +\n          \" create-expressible: {name: mincopy , class: 'mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric'}\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n   /* new V2Request.Builder(\"/c/\"+COLLECTIONORALIAS+\"/config\").withMethod(SolrRequest.METHOD.POST)\n        .withPayload(\"{add-expressible: {name: mincopy , class: org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric}}\")\n    .build().process(cluster.getSolrClient());\n\n  ModifiableSolrParams _params = new ModifiableSolrParams();\n  QueryRequest query = new QueryRequest(new MapSolrParams(\"action\",\"plugins\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/stream\");\n  NamedList<Object> rsp = cluster.getSolrClient().request(query);\n  assertEquals(\"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\", rsp._getStr(\"/plugins/mincopy\", null));\n  _params = new ModifiableSolrParams();\n  query = new QueryRequest(new MapSolrParams(\"componentName\",\"mincopy\", \"meta\" ,\"true\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/config/expressible\");\n  rsp = cluster.getSolrClient().request(query);\n\n    System.out.println();*/\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' },\" +\n          \" create-expressible: {name: mincopy , class: 'mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric'}\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n   /* new V2Request.Builder(\"/c/\"+COLLECTIONORALIAS+\"/config\").withMethod(SolrRequest.METHOD.POST)\n        .withPayload(\"{add-expressible: {name: mincopy , class: org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric}}\")\n    .build().process(cluster.getSolrClient());\n\n  ModifiableSolrParams _params = new ModifiableSolrParams();\n  QueryRequest query = new QueryRequest(new MapSolrParams(\"action\",\"plugins\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/stream\");\n  NamedList<Object> rsp = cluster.getSolrClient().request(query);\n  assertEquals(\"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\", rsp._getStr(\"/plugins/mincopy\", null));\n  _params = new ModifiableSolrParams();\n  query = new QueryRequest(new MapSolrParams(\"componentName\",\"mincopy\", \"meta\" ,\"true\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/config/expressible\");\n  rsp = cluster.getSolrClient().request(query);\n\n    System.out.println();*/\n\n","bugFix":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8f0a7504661c8e51be5c63e87f9d79a36d9116c","date":1578657638,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n//      cluster.getZkClient().makePath(\"/keys/exe\", true);\n//      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' },\" +\n          \" create-expressible: {name: mincopy , class: 'mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric'}\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n   /* new V2Request.Builder(\"/c/\"+COLLECTIONORALIAS+\"/config\").withMethod(SolrRequest.METHOD.POST)\n        .withPayload(\"{add-expressible: {name: mincopy , class: org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric}}\")\n    .build().process(cluster.getSolrClient());\n\n  ModifiableSolrParams _params = new ModifiableSolrParams();\n  QueryRequest query = new QueryRequest(new MapSolrParams(\"action\",\"plugins\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/stream\");\n  NamedList<Object> rsp = cluster.getSolrClient().request(query);\n  assertEquals(\"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\", rsp._getStr(\"/plugins/mincopy\", null));\n  _params = new ModifiableSolrParams();\n  query = new QueryRequest(new MapSolrParams(\"componentName\",\"mincopy\", \"meta\" ,\"true\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/config/expressible\");\n  rsp = cluster.getSolrClient().request(query);\n\n    System.out.println();*/\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' },\" +\n          \" create-expressible: {name: mincopy , class: 'mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric'}\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n   /* new V2Request.Builder(\"/c/\"+COLLECTIONORALIAS+\"/config\").withMethod(SolrRequest.METHOD.POST)\n        .withPayload(\"{add-expressible: {name: mincopy , class: org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric}}\")\n    .build().process(cluster.getSolrClient());\n\n  ModifiableSolrParams _params = new ModifiableSolrParams();\n  QueryRequest query = new QueryRequest(new MapSolrParams(\"action\",\"plugins\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/stream\");\n  NamedList<Object> rsp = cluster.getSolrClient().request(query);\n  assertEquals(\"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\", rsp._getStr(\"/plugins/mincopy\", null));\n  _params = new ModifiableSolrParams();\n  query = new QueryRequest(new MapSolrParams(\"componentName\",\"mincopy\", \"meta\" ,\"true\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/config/expressible\");\n  rsp = cluster.getSolrClient().request(query);\n\n    System.out.println();*/\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7757ad4a47d8b36bb6894c5ad33f766b4ddfa389","date":1591056099,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n      Map<String,ConfigPlugin> plugins = new LinkedHashMap<>();\n      ConfigPlugin p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibReqHandler\";\n      p.name = \"/runtime\";\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibSearchComponent\";\n      p.name = \"get\";\n      plugins.put(\"create-searchcomponent\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibResponseWriter\";\n      p.name = \"json1\";\n      plugins.put(\"create-queryResponseWriter\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.update.TestVersionedURP\";\n      p.name = \"myurp\";\n      plugins.put(\"create-updateProcessor\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\";\n      p.name = \"mincopy\";\n      plugins.put(\"create-expressible\", p);\n\n\n      V2Request v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      plugins.clear();\n      p = new ConfigPlugin();\n      p.name = \"/rt_2\";\n      p.klass = \"mypkg:\"+ C.class.getName();\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.name = \"qp1\";\n      p.klass = \"mypkg:\"+ C2.class.getName();\n      plugins.put(\"create-queryparser\", p);\n\n      v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n      assertTrue(C.informCalled);\n      assertTrue(C2.informCalled);\n\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n//      cluster.getZkClient().makePath(\"/keys/exe\", true);\n//      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n\n      String payload = \"{\\n\" +\n          \"'create-requesthandler' : { 'name' : '/runtime', 'class': 'mypkg:org.apache.solr.core.RuntimeLibReqHandler' },\" +\n          \"'create-searchcomponent' : { 'name' : 'get', 'class': 'mypkg:org.apache.solr.core.RuntimeLibSearchComponent'  },\" +\n          \"'create-queryResponseWriter' : { 'name' : 'json1', 'class': 'mypkg:org.apache.solr.core.RuntimeLibResponseWriter' }\" +\n          \"'create-updateProcessor' : { 'name' : 'myurp', 'class': 'mypkg:org.apache.solr.update.TestVersionedURP' },\" +\n          \" create-expressible: {name: mincopy , class: 'mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric'}\" +\n          \"}\";\n      cluster.getSolrClient().request(new ConfigRequest(payload) {\n        @Override\n        public String getCollection() {\n          return COLLECTION_NAME;\n        }\n      });\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n   /* new V2Request.Builder(\"/c/\"+COLLECTIONORALIAS+\"/config\").withMethod(SolrRequest.METHOD.POST)\n        .withPayload(\"{add-expressible: {name: mincopy , class: org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric}}\")\n    .build().process(cluster.getSolrClient());\n\n  ModifiableSolrParams _params = new ModifiableSolrParams();\n  QueryRequest query = new QueryRequest(new MapSolrParams(\"action\",\"plugins\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/stream\");\n  NamedList<Object> rsp = cluster.getSolrClient().request(query);\n  assertEquals(\"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\", rsp._getStr(\"/plugins/mincopy\", null));\n  _params = new ModifiableSolrParams();\n  query = new QueryRequest(new MapSolrParams(\"componentName\",\"mincopy\", \"meta\" ,\"true\", \"collection\", COLLECTIONORALIAS, \"wt\", \"javabin\"));\n    query.setPath(\"/config/expressible\");\n  rsp = cluster.getSolrClient().request(query);\n\n    System.out.println();*/\n\n","bugFix":null,"bugIntro":["9ac35455ac6925b629dedf2c0c52c0a8d5cb55b6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n      Map<String,ConfigPlugin> plugins = new LinkedHashMap<>();\n      ConfigPlugin p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibReqHandler\";\n      p.name = \"/runtime\";\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibSearchComponent\";\n      p.name = \"get\";\n      plugins.put(\"create-searchcomponent\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibResponseWriter\";\n      p.name = \"json1\";\n      plugins.put(\"create-queryResponseWriter\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.update.TestVersionedURP\";\n      p.name = \"myurp\";\n      plugins.put(\"create-updateProcessor\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\";\n      p.name = \"mincopy\";\n      plugins.put(\"create-expressible\", p);\n\n\n      V2Request v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      plugins.clear();\n      p = new ConfigPlugin();\n      p.name = \"/rt_2\";\n      p.klass = \"mypkg:\"+ C.class.getName();\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.name = \"qp1\";\n      p.klass = \"mypkg:\"+ C2.class.getName();\n      plugins.put(\"create-queryparser\", p);\n\n      v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n      assertTrue(C.informCalled);\n      assertTrue(C2.informCalled);\n\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n      Map<String,ConfigPlugin> plugins = new LinkedHashMap<>();\n      ConfigPlugin p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibReqHandler\";\n      p.name = \"/runtime\";\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibSearchComponent\";\n      p.name = \"get\";\n      plugins.put(\"create-searchcomponent\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibResponseWriter\";\n      p.name = \"json1\";\n      plugins.put(\"create-queryResponseWriter\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.update.TestVersionedURP\";\n      p.name = \"myurp\";\n      plugins.put(\"create-updateProcessor\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\";\n      p.name = \"mincopy\";\n      plugins.put(\"create-expressible\", p);\n\n\n      V2Request v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      plugins.clear();\n      p = new ConfigPlugin();\n      p.name = \"/rt_2\";\n      p.klass = \"mypkg:\"+ C.class.getName();\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.name = \"qp1\";\n      p.klass = \"mypkg:\"+ C2.class.getName();\n      plugins.put(\"create-queryparser\", p);\n\n      v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n      assertTrue(C.informCalled);\n      assertTrue(C2.informCalled);\n\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n      Map<String,ConfigPlugin> plugins = new LinkedHashMap<>();\n      ConfigPlugin p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibReqHandler\";\n      p.name = \"/runtime\";\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibSearchComponent\";\n      p.name = \"get\";\n      plugins.put(\"create-searchcomponent\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibResponseWriter\";\n      p.name = \"json1\";\n      plugins.put(\"create-queryResponseWriter\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.update.TestVersionedURP\";\n      p.name = \"myurp\";\n      plugins.put(\"create-updateProcessor\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\";\n      p.name = \"mincopy\";\n      plugins.put(\"create-expressible\", p);\n\n\n      V2Request v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      plugins.clear();\n      p = new ConfigPlugin();\n      p.name = \"/rt_2\";\n      p.klass = \"mypkg:\"+ C.class.getName();\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.name = \"qp1\";\n      p.klass = \"mypkg:\"+ C2.class.getName();\n      plugins.put(\"create-queryparser\", p);\n\n      v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n      assertTrue(C.informCalled);\n      assertTrue(C2.informCalled);\n\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n      Map<String,ConfigPlugin> plugins = new LinkedHashMap<>();\n      ConfigPlugin p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibReqHandler\";\n      p.name = \"/runtime\";\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibSearchComponent\";\n      p.name = \"get\";\n      plugins.put(\"create-searchcomponent\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibResponseWriter\";\n      p.name = \"json1\";\n      plugins.put(\"create-queryResponseWriter\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.update.TestVersionedURP\";\n      p.name = \"myurp\";\n      plugins.put(\"create-updateProcessor\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\";\n      p.name = \"mincopy\";\n      plugins.put(\"create-expressible\", p);\n\n\n      V2Request v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      plugins.clear();\n      p = new ConfigPlugin();\n      p.name = \"/rt_2\";\n      p.klass = \"mypkg:\"+ C.class.getName();\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.name = \"qp1\";\n      p.klass = \"mypkg:\"+ C2.class.getName();\n      plugins.put(\"create-queryparser\", p);\n\n      v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n      assertTrue(C.informCalled);\n      assertTrue(C2.informCalled);\n\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"64ec73f19361ec6354e55c878a349735fa8bc52e","date":1596183798,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n      Map<String,ConfigPlugin> plugins = new LinkedHashMap<>();\n      ConfigPlugin p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibReqHandler\";\n      p.name = \"/runtime\";\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibSearchComponent\";\n      p.name = \"get\";\n      plugins.put(\"create-searchcomponent\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibResponseWriter\";\n      p.name = \"json1\";\n      plugins.put(\"create-queryResponseWriter\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.update.TestVersionedURP\";\n      p.name = \"myurp\";\n      plugins.put(\"create-updateProcessor\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\";\n      p.name = \"mincopy\";\n      plugins.put(\"create-expressible\", p);\n\n\n      V2Request v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      plugins.clear();\n      p = new ConfigPlugin();\n      p.name = \"/rt_2\";\n      p.klass = \"mypkg:\"+ C.class.getName();\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.name = \"qp1\";\n      p.klass = \"mypkg:\"+ C2.class.getName();\n      plugins.put(\"create-queryparser\", p);\n\n      v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n      assertTrue(C.informCalled);\n      assertTrue(C2.informCalled);\n\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      checkAllNodesForFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n      Map<String,ConfigPlugin> plugins = new LinkedHashMap<>();\n      ConfigPlugin p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibReqHandler\";\n      p.name = \"/runtime\";\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibSearchComponent\";\n      p.name = \"get\";\n      plugins.put(\"create-searchcomponent\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibResponseWriter\";\n      p.name = \"json1\";\n      plugins.put(\"create-queryResponseWriter\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.update.TestVersionedURP\";\n      p.name = \"myurp\";\n      plugins.put(\"create-updateProcessor\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\";\n      p.name = \"mincopy\";\n      plugins.put(\"create-expressible\", p);\n\n\n      V2Request v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      plugins.clear();\n      p = new ConfigPlugin();\n      p.name = \"/rt_2\";\n      p.klass = \"mypkg:\"+ C.class.getName();\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.name = \"qp1\";\n      p.klass = \"mypkg:\"+ C2.class.getName();\n      plugins.put(\"create-queryparser\", p);\n\n      v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n      assertTrue(C.informCalled);\n      assertTrue(C2.informCalled);\n\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      waitForAllNodesHaveFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n\n    } finally {\n      cluster.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ac35455ac6925b629dedf2c0c52c0a8d5cb55b6","date":1601357122,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testPluginLoading().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n      Map<String,ConfigPlugin> plugins = new LinkedHashMap<>();\n      ConfigPlugin p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibReqHandler\";\n      p.name = \"/runtime\";\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibSearchComponent\";\n      p.name = \"get\";\n      plugins.put(\"create-searchcomponent\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibResponseWriter\";\n      p.name = \"json1\";\n      plugins.put(\"create-queryResponseWriter\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.update.TestVersionedURP\";\n      p.name = \"myurp\";\n      plugins.put(\"create-updateProcessor\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\";\n      p.name = \"mincopy\";\n      plugins.put(\"create-expressible\", p);\n\n\n      V2Request v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyComponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      plugins.clear();\n      p = new ConfigPlugin();\n      p.name = \"/rt_2\";\n      p.klass = \"mypkg:\"+ C.class.getName();\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.name = \"qp1\";\n      p.klass = \"mypkg:\"+ C2.class.getName();\n      plugins.put(\"create-queryparser\", p);\n\n      v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(plugins)\n          .forceV2(true)\n          .build();\n      cluster.getSolrClient().request(v2r);\n      assertTrue(C.informCalled);\n      assertTrue(C2.informCalled);\n\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      checkAllNodesForFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testPluginLoading() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String FILE1 = \"/mypkg/runtimelibs.jar\";\n      String FILE2 = \"/mypkg/runtimelibs_v2.jar\";\n      String FILE3 = \"/mypkg/runtimelibs_v3.jar\";\n      String URP1 = \"/mypkg/testurpv1.jar\";\n      String URP2 = \"/mypkg/testurpv2.jar\";\n      String EXPR1 = \"/mypkg/expressible.jar\";\n      String COLLECTION_NAME = \"testPluginLoadingColl\";\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v1.jar.bin\", URP1,\n          \"h6UmMzuPqu4hQFGLBMJh/6kDSEXpJlgLsQDXx0KuxXWkV5giilRP57K3towiJRh2J+rqihqIghNCi3YgzgUnWQ==\");\n\n      postFileAndWait(cluster, \"runtimecode/expressible.jar.bin\", EXPR1,\n          \"ZOT11arAiPmPZYOHzqodiNnxO9pRyRozWZEBX8XGjU1/HJptFnZK+DI7eXnUtbNaMcbXE2Ze8hh4M/eGyhY8BQ==\");\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"1.0\";\n      add.pkg = \"mypkg\";\n      add.files = Arrays.asList(new String[]{FILE1, URP1, EXPR1});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      req.process(cluster.getSolrClient());\n\n\n      CollectionAdminRequest\n          .createCollection(COLLECTION_NAME, \"conf\", 2, 2)\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 4);\n\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/cluster/package\").\n              withMethod(SolrRequest.METHOD.GET)\n              .build().process(cluster.getSolrClient()),\n          Utils.makeMap(\n              \":result:packages:mypkg[0]:version\", \"1.0\",\n              \":result:packages:mypkg[0]:files[0]\", FILE1\n          ));\n      Map<String,ConfigPlugin> plugins = new LinkedHashMap<>();\n      ConfigPlugin p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibReqHandler\";\n      p.name = \"/runtime\";\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibSearchComponent\";\n      p.name = \"get\";\n      plugins.put(\"create-searchcomponent\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.core.RuntimeLibResponseWriter\";\n      p.name = \"json1\";\n      plugins.put(\"create-queryResponseWriter\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.update.TestVersionedURP\";\n      p.name = \"myurp\";\n      plugins.put(\"create-updateProcessor\", p);\n\n      p = new ConfigPlugin();\n      p.klass = \"mypkg:org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\";\n      p.name = \"mincopy\";\n      plugins.put(\"create-expressible\", p);\n\n\n      V2Request v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.0\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"expressible\", \"mincopy\",\n          \"mypkg\", \"1.0\" );\n\n      TestDistribPackageStore.assertResponseValues(10,\n          cluster.getSolrClient() ,\n          new GenericSolrRequest(SolrRequest.METHOD.GET,\n              \"/stream\", new MapSolrParams((Map) Utils.makeMap(\"collection\", COLLECTION_NAME,\n                  WT, JAVABIN,\n                  \"action\", \"plugins\"\n                  ))), Utils.makeMap(\n              \":plugins:mincopy\", \"org.apache.solr.client.solrj.io.stream.metrics.MinCopyMetric\"\n          ));\n\n      UpdateRequest ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"1\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      QueryResponse result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:1\"));\n\n      assertEquals(\"Version 1\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=javabin\", cluster.getRandomJetty(random()),\n          Utils.JAVABINCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibReqHandler\"));\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"class\", \"org.apache.solr.core.RuntimeLibSearchComponent\",\n              \"Version\",\"1\"));\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json1\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"wt\", \"org.apache.solr.core.RuntimeLibResponseWriter\"));\n\n      //now upload the second jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE2,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n      postFileAndWait(cluster, \"runtimecode/testurp_v2.jar.bin\", URP2,\n          \"P/ptFXRvQMd4oKPvadSpd+A9ffwY3gcex5GVFVRy3df0/OF8XT5my8rQz7FZva+2ORbWxdXS8NKwNrbPVHLGXw==\");\n      //add the version using package API\n      add.version = \"1.1\";\n      add.files = Arrays.asList(new String[]{FILE2,URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"updateProcessor\", \"myurp\",\n          \"mypkg\", \"1.1\" );\n\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/get?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(  \"Version\",\"2\"));\n\n\n      //now upload the third jar\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v3.jar.bin\", FILE3,\n          \"a400n4T7FT+2gM0SC6+MfSOExjud8MkhTSFylhvwNjtWwUgKdPFn434Wv7Qc4QEqDVLhQoL3WqYtQmLPti0G4Q==\");\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //now let's verify that the classes are updated\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      executeReq( \"/\" + COLLECTION_NAME + \"/runtime?wt=json\", cluster.getRandomJetty(random()),\n          Utils.JSONCONSUMER,\n          Utils.makeMap(\"Version\",\"2\"));\n\n      //insert a doc with urp\n      ur = new UpdateRequest();\n      ur.add(new SolrInputDocument(\"id\", \"2\"));\n      ur.setParam(\"processor\", \"myurp\");\n      ur.process(cluster.getSolrClient(), COLLECTION_NAME);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      result = cluster.getSolrClient()\n          .query(COLLECTION_NAME, new SolrQuery( \"id:2\"));\n\n      assertEquals(\"Version 2\", result.getResults().get(0).getFieldValue(\"TestVersionedURP.Ver_s\"));\n\n\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.pkg = \"mypkg\";\n      delVersion.version = \"1.0\";\n      V2Request delete = new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .forceV2(true)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      // now remove the hughest version. So, it will roll back to the next highest one\n      delVersion.version = \"2.1\";\n      delete.process(cluster.getSolrClient());\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"collection\", COLLECTION_NAME);\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '1.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      add.version = \"2.1\";\n      add.files = Arrays.asList(new String[]{FILE3, URP2, EXPR1});\n      req.process(cluster.getSolrClient());\n\n      //the collections mypkg is set to use version 1.1\n      //so no upgrade\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"1.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"1.1\" );\n\n      new GenericSolrRequest(SolrRequest.METHOD.POST, \"/config/params\", params ){\n        @Override\n        public RequestWriter.ContentWriter getContentWriter(String expectedType) {\n          return new RequestWriter.StringPayloadContentWriter(\"{set:{PKG_VERSIONS:{mypkg : '2.1'}}}\",\n              ClientUtils.TEXT_JSON);\n        }\n      }.process(cluster.getSolrClient()) ;\n\n      //now, let's force every collection using 'mypkg' to refresh\n      //so that it uses version 2.1\n      new V2Request.Builder(\"/cluster/package\")\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(\"{refresh : mypkg}\")\n          .forceV2(true)\n          .build()\n          .process(cluster.getSolrClient());\n\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"queryResponseWriter\", \"json1\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"searchComponent\", \"get\",\n          \"mypkg\", \"2.1\" );\n\n      verifyCmponent(cluster.getSolrClient(),\n          COLLECTION_NAME, \"requestHandler\", \"/runtime\",\n          \"mypkg\", \"2.1\" );\n\n      plugins.clear();\n      p = new ConfigPlugin();\n      p.name = \"/rt_2\";\n      p.klass = \"mypkg:\"+ C.class.getName();\n      plugins.put(\"create-requesthandler\", p);\n\n      p = new ConfigPlugin();\n      p.name = \"qp1\";\n      p.klass = \"mypkg:\"+ C2.class.getName();\n      plugins.put(\"create-queryparser\", p);\n\n      v2r = new V2Request.Builder( \"/c/\"+COLLECTION_NAME+ \"/config\")\n              .withMethod(SolrRequest.METHOD.POST)\n              .withPayload(plugins)\n              .forceV2(true)\n              .build();\n      cluster.getSolrClient().request(v2r);\n      assertTrue(C.informCalled);\n      assertTrue(C2.informCalled);\n\n      //we create a new node. This node does not have the packages. But it should download it from another node\n      JettySolrRunner jetty = cluster.startJettySolrRunner();\n      //create a new replica for this collection. it should end up\n      CollectionAdminRequest.addReplicaToShard(COLLECTION_NAME, \"shard1\")\n          .setNrtReplicas(1)\n          .setNode(jetty.getNodeName())\n          .process(cluster.getSolrClient());\n      cluster.waitForActiveCollection(COLLECTION_NAME, 2, 5);\n      checkAllNodesForFile(cluster,FILE3,\n          Utils.makeMap(\":files:\" + FILE3 + \":name\", \"runtimelibs_v3.jar\"),\n          false);\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","bugFix":["60c716cf818aff6857d8490cd0fb8b5aa432408f","7757ad4a47d8b36bb6894c5ad33f766b4ddfa389","954ae83b7dfacaa33d48ea056448ae11f7745a93","fc09d7c591d6661c79bcdfd1c661da97e638804d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8f0a7504661c8e51be5c63e87f9d79a36d9116c":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","d218decf811b7a0a4d86218c54c79c74a962374b"],"60c716cf818aff6857d8490cd0fb8b5aa432408f":["a4a9d755535ef8154bc3ac90a6c963e91d44b71c"],"64ec73f19361ec6354e55c878a349735fa8bc52e":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a4a9d755535ef8154bc3ac90a6c963e91d44b71c":["fc09d7c591d6661c79bcdfd1c661da97e638804d"],"9ac35455ac6925b629dedf2c0c52c0a8d5cb55b6":["64ec73f19361ec6354e55c878a349735fa8bc52e"],"d218decf811b7a0a4d86218c54c79c74a962374b":["60c716cf818aff6857d8490cd0fb8b5aa432408f"],"fc09d7c591d6661c79bcdfd1c661da97e638804d":["d1a6448412ce640b28861f4c00f899484a9adac1"],"d1a6448412ce640b28861f4c00f899484a9adac1":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"b945b8f5bba0303382bc69d60c0c287714f23328":["fc09d7c591d6661c79bcdfd1c661da97e638804d","a4a9d755535ef8154bc3ac90a6c963e91d44b71c"],"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a":["b945b8f5bba0303382bc69d60c0c287714f23328","60c716cf818aff6857d8490cd0fb8b5aa432408f"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["7757ad4a47d8b36bb6894c5ad33f766b4ddfa389"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7757ad4a47d8b36bb6894c5ad33f766b4ddfa389":["d218decf811b7a0a4d86218c54c79c74a962374b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ac35455ac6925b629dedf2c0c52c0a8d5cb55b6"]},"commit2Childs":{"b8f0a7504661c8e51be5c63e87f9d79a36d9116c":[],"60c716cf818aff6857d8490cd0fb8b5aa432408f":["d218decf811b7a0a4d86218c54c79c74a962374b","96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a"],"64ec73f19361ec6354e55c878a349735fa8bc52e":["9ac35455ac6925b629dedf2c0c52c0a8d5cb55b6"],"a4a9d755535ef8154bc3ac90a6c963e91d44b71c":["60c716cf818aff6857d8490cd0fb8b5aa432408f","b945b8f5bba0303382bc69d60c0c287714f23328"],"9ac35455ac6925b629dedf2c0c52c0a8d5cb55b6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d218decf811b7a0a4d86218c54c79c74a962374b":["b8f0a7504661c8e51be5c63e87f9d79a36d9116c","7757ad4a47d8b36bb6894c5ad33f766b4ddfa389"],"fc09d7c591d6661c79bcdfd1c661da97e638804d":["a4a9d755535ef8154bc3ac90a6c963e91d44b71c","b945b8f5bba0303382bc69d60c0c287714f23328"],"d1a6448412ce640b28861f4c00f899484a9adac1":["fc09d7c591d6661c79bcdfd1c661da97e638804d"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["64ec73f19361ec6354e55c878a349735fa8bc52e"],"b945b8f5bba0303382bc69d60c0c287714f23328":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a"],"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a":["b8f0a7504661c8e51be5c63e87f9d79a36d9116c"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["d1a6448412ce640b28861f4c00f899484a9adac1"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"7757ad4a47d8b36bb6894c5ad33f766b4ddfa389":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b8f0a7504661c8e51be5c63e87f9d79a36d9116c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}