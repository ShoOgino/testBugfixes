{"path":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","commits":[{"id":"e91746d568843981a68fb96dcecc7f383eb55701","date":1347520198,"type":0,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"/dev/null","sourceNew":"  public String assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    Double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef t = termsEnum.next();\n    while (t != null) {\n      String classValue = t.utf8ToString();\n      // TODO : turn it to be in log scale\n      Double clVal = calculatePrior(classValue) * calculateLikelihood(inputDocument, classValue);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = classValue;\n      }\n      t = termsEnum.next();\n    }\n    return foundClass;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b046c3e04315940a761d69bb348c761c11d995d4","date":1347605712,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  public String assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    while((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(inputDocument, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return foundClass;\n  }\n\n","sourceOld":"  public String assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    Double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef t = termsEnum.next();\n    while (t != null) {\n      String classValue = t.utf8ToString();\n      // TODO : turn it to be in log scale\n      Double clVal = calculatePrior(classValue) * calculateLikelihood(inputDocument, classValue);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = classValue;\n      }\n      t = termsEnum.next();\n    }\n    return foundClass;\n  }\n\n","bugFix":null,"bugIntro":["ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db318054409ed0abffd7a36b3f0ac61693f45684","date":1351009122,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    while((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(inputDocument, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","sourceOld":"  public String assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    while((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(inputDocument, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return foundClass;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    while((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(inputDocument, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","sourceOld":"  public String assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    while((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(inputDocument, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return foundClass;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea256c5290971ea9db5a3dab42c4b8d9662e513a","date":1354022529,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(inputDocument, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","sourceOld":"  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    while((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(inputDocument, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bebf668d6a706a90e62718d210f354e26b2b4d23","date":1354174257,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(inputDocument, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","bugFix":null,"bugIntro":["ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","sourceOld":"  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    while((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(inputDocument, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d70dbb6b688e5d00fdf510da452291910f5efa4","date":1357228093,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.clone();\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","bugFix":null,"bugIntro":["f943af95e5f861862ba175e931d53f5c53060cb3","ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.clone();\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    String foundClass = null;\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.utf8ToString();\n      }\n    }\n    return new ClassificationResult(foundClass, max);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6965197f9fe6d03eb332e2bd4e44e905f83f83d","date":1365412474,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train first\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.clone();\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new RuntimeException(\"need to train the classifier first\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.clone();\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f943af95e5f861862ba175e931d53f5c53060cb3","date":1367086170,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train first\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train first\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = next.clone();\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","bugFix":["1d70dbb6b688e5d00fdf510da452291910f5efa4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45ae8f6354b0826d27014deff71fe330604a9783","date":1378195819,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train first\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca","date":1385108956,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train\");\n    }\n    double max = - Double.MAX_VALUE;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      double clVal = calculateLogPrior(next) + calculateLogLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    double score = 10 / Math.abs(max);\n    return new ClassificationResult<BytesRef>(foundClass, score);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","bugFix":["bebf668d6a706a90e62718d210f354e26b2b4d23","e91746d568843981a68fb96dcecc7f383eb55701","1d70dbb6b688e5d00fdf510da452291910f5efa4","b046c3e04315940a761d69bb348c761c11d995d4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train\");\n    }\n    double max = - Double.MAX_VALUE;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      double clVal = calculateLogPrior(next) + calculateLogLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    double score = 10 / Math.abs(max);\n    return new ClassificationResult<BytesRef>(foundClass, score);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train\");\n    }\n    double max = 0d;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      // TODO : turn it to be in log scale\n      double clVal = calculatePrior(next) * calculateLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    return new ClassificationResult<BytesRef>(foundClass, max);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train\");\n    }\n    double max = - Double.MAX_VALUE;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      double clVal = calculateLogPrior(next) + calculateLogLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    double score = 10 / Math.abs(max);\n    return new ClassificationResult<>(foundClass, score);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train\");\n    }\n    double max = - Double.MAX_VALUE;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      double clVal = calculateLogPrior(next) + calculateLogLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    double score = 10 / Math.abs(max);\n    return new ClassificationResult<BytesRef>(foundClass, score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7533828cbcc5f498a44cca5d9bce92692663778","date":1408525002,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> doclist = assignClassNormalizedList(inputDocument);\n    ClassificationResult<BytesRef> retval = null;\n    double maxscore = -Double.MAX_VALUE;\n    for (ClassificationResult<BytesRef> element : doclist) {\n      if (element.getScore() > maxscore) {\n        retval = element;\n        maxscore = element.getScore();\n      }\n    }\n    return retval;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    if (atomicReader == null) {\n      throw new IOException(\"You must first call Classifier#train\");\n    }\n    double max = - Double.MAX_VALUE;\n    BytesRef foundClass = new BytesRef();\n\n    Terms terms = MultiFields.getTerms(atomicReader, classFieldName);\n    TermsEnum termsEnum = terms.iterator(null);\n    BytesRef next;\n    String[] tokenizedDoc = tokenizeDoc(inputDocument);\n    while ((next = termsEnum.next()) != null) {\n      double clVal = calculateLogPrior(next) + calculateLogLikelihood(tokenizedDoc, next);\n      if (clVal > max) {\n        max = clVal;\n        foundClass = BytesRef.deepCopyOf(next);\n      }\n    }\n    double score = 10 / Math.abs(max);\n    return new ClassificationResult<>(foundClass, score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"134a24d0cb66520908d88384f1a559875704ed25","date":1445326601,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = assignClassNormalizedList(inputDocument);\n    ClassificationResult<BytesRef> assignedClass = null;\n    double maxscore = -Double.MAX_VALUE;\n    for (ClassificationResult<BytesRef> c : assignedClasses) {\n      if (c.getScore() > maxscore) {\n        assignedClass = c;\n        maxscore = c.getScore();\n      }\n    }\n    return assignedClass;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> doclist = assignClassNormalizedList(inputDocument);\n    ClassificationResult<BytesRef> retval = null;\n    double maxscore = -Double.MAX_VALUE;\n    for (ClassificationResult<BytesRef> element : doclist) {\n      if (element.getScore() > maxscore) {\n        retval = element;\n        maxscore = element.getScore();\n      }\n    }\n    return retval;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a80a37ae73034270b57bfd57a44f8fcadc952fa0","date":1515440719,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = assignClassNormalizedList(inputDocument);\n    ClassificationResult<BytesRef> assignedClass = null;\n    double maxscore = -Double.MAX_VALUE;\n    for (ClassificationResult<BytesRef> c : assignedClasses) {\n      if (c.getScore() > maxscore) {\n        assignedClass = c;\n        maxscore = c.getScore();\n      }\n    }\n    return assignedClass;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = assignClassNormalizedList(inputDocument);\n    ClassificationResult<BytesRef> assignedClass = null;\n    double maxscore = -Double.MAX_VALUE;\n    for (ClassificationResult<BytesRef> c : assignedClasses) {\n      if (c.getScore() > maxscore) {\n        assignedClass = c;\n        maxscore = c.getScore();\n      }\n    }\n    return assignedClass;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/SimpleNaiveBayesClassifier#assignClass(String).mjava","sourceNew":"  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = assignClassNormalizedList(inputDocument);\n    ClassificationResult<BytesRef> assignedClass = null;\n    double maxscore = -Double.MAX_VALUE;\n    for (ClassificationResult<BytesRef> c : assignedClasses) {\n      if (c.getScore() > maxscore) {\n        assignedClass = c;\n        maxscore = c.getScore();\n      }\n    }\n    return assignedClass;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public ClassificationResult<BytesRef> assignClass(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = assignClassNormalizedList(inputDocument);\n    ClassificationResult<BytesRef> assignedClass = null;\n    double maxscore = -Double.MAX_VALUE;\n    for (ClassificationResult<BytesRef> c : assignedClasses) {\n      if (c.getScore() > maxscore) {\n        assignedClass = c;\n        maxscore = c.getScore();\n      }\n    }\n    return assignedClass;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","1d70dbb6b688e5d00fdf510da452291910f5efa4"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca"],"b94236357aaa22b76c10629851fe4e376e0cea82":["134a24d0cb66520908d88384f1a559875704ed25","a80a37ae73034270b57bfd57a44f8fcadc952fa0"],"ea256c5290971ea9db5a3dab42c4b8d9662e513a":["db318054409ed0abffd7a36b3f0ac61693f45684"],"f943af95e5f861862ba175e931d53f5c53060cb3":["d6965197f9fe6d03eb332e2bd4e44e905f83f83d"],"a80a37ae73034270b57bfd57a44f8fcadc952fa0":["134a24d0cb66520908d88384f1a559875704ed25"],"407687e67faf6e1f02a211ca078d8e3eed631027":["db318054409ed0abffd7a36b3f0ac61693f45684","bebf668d6a706a90e62718d210f354e26b2b4d23"],"b046c3e04315940a761d69bb348c761c11d995d4":["e91746d568843981a68fb96dcecc7f383eb55701"],"db318054409ed0abffd7a36b3f0ac61693f45684":["b046c3e04315940a761d69bb348c761c11d995d4"],"ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca":["45ae8f6354b0826d27014deff71fe330604a9783"],"134a24d0cb66520908d88384f1a559875704ed25":["e7533828cbcc5f498a44cca5d9bce92692663778"],"e91746d568843981a68fb96dcecc7f383eb55701":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"45ae8f6354b0826d27014deff71fe330604a9783":["f943af95e5f861862ba175e931d53f5c53060cb3"],"d6965197f9fe6d03eb332e2bd4e44e905f83f83d":["1d70dbb6b688e5d00fdf510da452291910f5efa4"],"bebf668d6a706a90e62718d210f354e26b2b4d23":["ea256c5290971ea9db5a3dab42c4b8d9662e513a"],"62e52115b56781006682fd92c6938efaf174304d":["b046c3e04315940a761d69bb348c761c11d995d4","db318054409ed0abffd7a36b3f0ac61693f45684"],"e7533828cbcc5f498a44cca5d9bce92692663778":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["45ae8f6354b0826d27014deff71fe330604a9783","ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca"],"1d70dbb6b688e5d00fdf510da452291910f5efa4":["bebf668d6a706a90e62718d210f354e26b2b4d23"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["e7533828cbcc5f498a44cca5d9bce92692663778"],"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ea256c5290971ea9db5a3dab42c4b8d9662e513a":["bebf668d6a706a90e62718d210f354e26b2b4d23"],"a80a37ae73034270b57bfd57a44f8fcadc952fa0":["b94236357aaa22b76c10629851fe4e376e0cea82"],"f943af95e5f861862ba175e931d53f5c53060cb3":["45ae8f6354b0826d27014deff71fe330604a9783"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"b046c3e04315940a761d69bb348c761c11d995d4":["db318054409ed0abffd7a36b3f0ac61693f45684","62e52115b56781006682fd92c6938efaf174304d"],"db318054409ed0abffd7a36b3f0ac61693f45684":["ea256c5290971ea9db5a3dab42c4b8d9662e513a","407687e67faf6e1f02a211ca078d8e3eed631027","62e52115b56781006682fd92c6938efaf174304d"],"ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"134a24d0cb66520908d88384f1a559875704ed25":["b94236357aaa22b76c10629851fe4e376e0cea82","a80a37ae73034270b57bfd57a44f8fcadc952fa0"],"e91746d568843981a68fb96dcecc7f383eb55701":["b046c3e04315940a761d69bb348c761c11d995d4"],"45ae8f6354b0826d27014deff71fe330604a9783":["ad37b818aab34fe3bfb45adc5b9910ddf4fec2ca","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"d6965197f9fe6d03eb332e2bd4e44e905f83f83d":["f943af95e5f861862ba175e931d53f5c53060cb3"],"bebf668d6a706a90e62718d210f354e26b2b4d23":["407687e67faf6e1f02a211ca078d8e3eed631027","1d70dbb6b688e5d00fdf510da452291910f5efa4"],"62e52115b56781006682fd92c6938efaf174304d":[],"e7533828cbcc5f498a44cca5d9bce92692663778":["134a24d0cb66520908d88384f1a559875704ed25"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e91746d568843981a68fb96dcecc7f383eb55701"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"1d70dbb6b688e5d00fdf510da452291910f5efa4":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d6965197f9fe6d03eb332e2bd4e44e905f83f83d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","62e52115b56781006682fd92c6938efaf174304d","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}