{"path":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","commits":[{"id":"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705","date":1294747166,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher.MultiSearcherCallableNoSort#call().mjava","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searchable.search (weight, filter, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","sourceOld":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searchable.search (weight, filter, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += docBase; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"/dev/null","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searchable.search (weight, filter, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30da203d7de68a87a16025523a483a96c24f4291","date":1296686055,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","sourceOld":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searchable.search (weight, filter, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"/dev/null","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","sourceOld":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searchable.search (weight, filter, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15","date":1316561169,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, after, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","sourceOld":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"576017a3864f5d8d12be8dc6b7b47dd9c41cc08d","date":1317143951,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, after, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      lock.lock();\n      try {\n        for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n          final ScoreDoc scoreDoc = scoreDocs[j];\n          //it would be so nice if we had a thread-safe insert \n          if (scoreDoc == hq.insertWithOverflow(scoreDoc)) {\n            break;\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return docs;\n    }\n\n","sourceOld":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, after, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n        final ScoreDoc scoreDoc = scoreDocs[j];\n        //it would be so nice if we had a thread-safe insert \n        lock.lock();\n        try {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } finally {\n          lock.unlock();\n        }\n      }\n      return docs;\n    }\n\n","bugFix":null,"bugIntro":["14cf30e66909759d35f27ffa18e7d9b76a285caf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14cf30e66909759d35f27ffa18e7d9b76a285caf","date":1317144114,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, after, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      //it would be so nice if we had a thread-safe insert \n      lock.lock();\n      try {\n        for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n          final ScoreDoc scoreDoc = scoreDocs[j];\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc)) {\n            break;\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return docs;\n    }\n\n","sourceOld":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, after, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      lock.lock();\n      try {\n        for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n          final ScoreDoc scoreDoc = scoreDocs[j];\n          //it would be so nice if we had a thread-safe insert \n          if (scoreDoc == hq.insertWithOverflow(scoreDoc)) {\n            break;\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return docs;\n    }\n\n","bugFix":["576017a3864f5d8d12be8dc6b7b47dd9c41cc08d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6620df8541b174097b1133a4fc370adb2e570524","date":1319544675,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, after, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      //it would be so nice if we had a thread-safe insert \n      lock.lock();\n      try {\n        for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n          final ScoreDoc scoreDoc = scoreDocs[j];\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc)) {\n            break;\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return docs;\n    }\n\n","sourceOld":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, filter, after, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      //it would be so nice if we had a thread-safe insert \n      lock.lock();\n      try {\n        for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n          final ScoreDoc scoreDoc = scoreDocs[j];\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc)) {\n            break;\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return docs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher.SearcherCallableNoSort#call().mjava","sourceNew":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, after, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      //it would be so nice if we had a thread-safe insert \n      lock.lock();\n      try {\n        for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n          final ScoreDoc scoreDoc = scoreDocs[j];\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc)) {\n            break;\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return docs;\n    }\n\n","sourceOld":"    public TopDocs call() throws IOException {\n      final TopDocs docs = searcher.search (slice.leaves, weight, after, nDocs);\n      final ScoreDoc[] scoreDocs = docs.scoreDocs;\n      //it would be so nice if we had a thread-safe insert \n      lock.lock();\n      try {\n        for (int j = 0; j < scoreDocs.length; j++) { // merge scoreDocs into hq\n          final ScoreDoc scoreDoc = scoreDocs[j];\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc)) {\n            break;\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return docs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15":["30da203d7de68a87a16025523a483a96c24f4291"],"6620df8541b174097b1133a4fc370adb2e570524":["14cf30e66909759d35f27ffa18e7d9b76a285caf"],"576017a3864f5d8d12be8dc6b7b47dd9c41cc08d":["c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["6620df8541b174097b1133a4fc370adb2e570524"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","30da203d7de68a87a16025523a483a96c24f4291"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"30da203d7de68a87a16025523a483a96c24f4291":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"14cf30e66909759d35f27ffa18e7d9b76a285caf":["576017a3864f5d8d12be8dc6b7b47dd9c41cc08d"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["868da859b43505d9d2a023bfeae6dd0c795f5295","30da203d7de68a87a16025523a483a96c24f4291"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15":["576017a3864f5d8d12be8dc6b7b47dd9c41cc08d"],"6620df8541b174097b1133a4fc370adb2e570524":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"576017a3864f5d8d12be8dc6b7b47dd9c41cc08d":["14cf30e66909759d35f27ffa18e7d9b76a285caf"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["29ef99d61cda9641b6250bf9567329a6e65f901d","a10b98ef1ef4bf9e38d2e07a9e425a916afa8705","868da859b43505d9d2a023bfeae6dd0c795f5295"],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["30da203d7de68a87a16025523a483a96c24f4291","868da859b43505d9d2a023bfeae6dd0c795f5295"],"30da203d7de68a87a16025523a483a96c24f4291":["c36f7a2dc9a2d9c7cff5a1e07a7e7f5ef93e6d15","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"14cf30e66909759d35f27ffa18e7d9b76a285caf":["6620df8541b174097b1133a4fc370adb2e570524"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}