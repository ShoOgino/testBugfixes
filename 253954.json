{"path":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","commits":[{"id":"ca70fffb953aae4d27efbfc28758033a317f39b1","date":1396371342,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    for (List<CloudJettyRunner> listOfReplicas : shardToJetty.values()) {\n      for (CloudJettyRunner replicaRunner : listOfReplicas) {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\",\"indexversion\");\n        params.set(\"_trace\",\"getIndexVersion\");\n        params.set(\"qt\",\"/replication\");\n        QueryRequest req = new QueryRequest(params);\n    \n        NamedList<Object> res = replicaRunner.client.solrClient.request(req);\n        assertNotNull(\"null response from server: \" + replicaRunner.coreNodeName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + replicaRunner.coreNodeName, version);\n        assertTrue(\"version isn't a long: \"+replicaRunner.coreNodeName, \n                   version instanceof Long);\n        results.put(replicaRunner.coreNodeName, (Long)version);\n\n        long numDocs = replicaRunner.client.solrClient.query\n          (params(\"q\",\"*:*\",\"distrib\",\"false\",\"rows\",\"0\",\"_trace\",\"counting_docs\"))\n          .getResults().getNumFound();\n        log.info(\"core=\" + replicaRunner.coreNodeName + \"; ver=\" + version + \n                 \"; numDocs=\" + numDocs); \n\n      }\n    }\n\n    return results;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    for (List<CloudJettyRunner> listOfReplicas : shardToJetty.values()) {\n      for (CloudJettyRunner replicaRunner : listOfReplicas) {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\",\"indexversion\");\n        params.set(\"_trace\",\"getIndexVersion\");\n        params.set(\"qt\",\"/replication\");\n        QueryRequest req = new QueryRequest(params);\n    \n        NamedList<Object> res = replicaRunner.client.solrClient.request(req);\n        assertNotNull(\"null response from server: \" + replicaRunner.coreNodeName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + replicaRunner.coreNodeName, version);\n        assertTrue(\"version isn't a long: \"+replicaRunner.coreNodeName, \n                   version instanceof Long);\n        results.put(replicaRunner.coreNodeName, (Long)version);\n\n        long numDocs = replicaRunner.client.solrClient.query\n          (params(\"q\",\"*:*\",\"distrib\",\"false\",\"rows\",\"0\",\"_trace\",\"counting_docs\"))\n          .getResults().getNumFound();\n        log.info(\"core=\" + replicaRunner.coreNodeName + \"; ver=\" + version + \n                 \"; numDocs=\" + numDocs); \n\n      }\n    }\n\n    return results;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71475d88ea48a7d9a847f209667255318b3ea4c7","date":1461758968,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","sourceNew":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    for (List<CloudJettyRunner> listOfReplicas : shardToJetty.values()) {\n      for (CloudJettyRunner replicaRunner : listOfReplicas) {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\",\"indexversion\");\n        params.set(\"_trace\",\"getIndexVersion\");\n        params.set(\"qt\",ReplicationHandler.PATH);\n        QueryRequest req = new QueryRequest(params);\n    \n        NamedList<Object> res = replicaRunner.client.solrClient.request(req);\n        assertNotNull(\"null response from server: \" + replicaRunner.coreNodeName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + replicaRunner.coreNodeName, version);\n        assertTrue(\"version isn't a long: \"+replicaRunner.coreNodeName, \n                   version instanceof Long);\n        results.put(replicaRunner.coreNodeName, (Long)version);\n\n        long numDocs = replicaRunner.client.solrClient.query\n          (params(\"q\",\"*:*\",\"distrib\",\"false\",\"rows\",\"0\",\"_trace\",\"counting_docs\"))\n          .getResults().getNumFound();\n        log.info(\"core=\" + replicaRunner.coreNodeName + \"; ver=\" + version + \n                 \"; numDocs=\" + numDocs); \n\n      }\n    }\n\n    return results;\n  }\n\n","sourceOld":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    for (List<CloudJettyRunner> listOfReplicas : shardToJetty.values()) {\n      for (CloudJettyRunner replicaRunner : listOfReplicas) {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\",\"indexversion\");\n        params.set(\"_trace\",\"getIndexVersion\");\n        params.set(\"qt\",\"/replication\");\n        QueryRequest req = new QueryRequest(params);\n    \n        NamedList<Object> res = replicaRunner.client.solrClient.request(req);\n        assertNotNull(\"null response from server: \" + replicaRunner.coreNodeName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + replicaRunner.coreNodeName, version);\n        assertTrue(\"version isn't a long: \"+replicaRunner.coreNodeName, \n                   version instanceof Long);\n        results.put(replicaRunner.coreNodeName, (Long)version);\n\n        long numDocs = replicaRunner.client.solrClient.query\n          (params(\"q\",\"*:*\",\"distrib\",\"false\",\"rows\",\"0\",\"_trace\",\"counting_docs\"))\n          .getResults().getNumFound();\n        log.info(\"core=\" + replicaRunner.coreNodeName + \"; ver=\" + version + \n                 \"; numDocs=\" + numDocs); \n\n      }\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ebf70dabe6279454c5ff460bdea3f0dc2814a86","date":1463672611,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","sourceNew":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    DocCollection collectionState = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n\n    for (Replica replica : collectionState.getReplicas()) {\n\n      String coreName = replica.getCoreName();\n      try (HttpSolrClient client = getHttpSolrClient(replica.getCoreUrl())) {\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\", \"indexversion\");\n        params.set(\"_trace\", \"getIndexVersion\");\n        params.set(\"qt\", ReplicationHandler.PATH);\n        QueryRequest req = new QueryRequest(params);\n\n        NamedList<Object> res = client.request(req);\n        assertNotNull(\"null response from server: \" + coreName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + coreName, version);\n        assertTrue(\"version isn't a long: \" + coreName, version instanceof Long);\n        results.put(coreName, (Long) version);\n\n        long numDocs = client.query(params(\"q\", \"*:*\", \"distrib\", \"false\", \"rows\", \"0\", \"_trace\", \"counting_docs\"))\n            .getResults().getNumFound();\n        log.info(\"core=\" + coreName + \"; ver=\" + version +\n            \"; numDocs=\" + numDocs);\n\n      }\n    }\n\n\n    return results;\n  }\n\n","sourceOld":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    for (List<CloudJettyRunner> listOfReplicas : shardToJetty.values()) {\n      for (CloudJettyRunner replicaRunner : listOfReplicas) {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\",\"indexversion\");\n        params.set(\"_trace\",\"getIndexVersion\");\n        params.set(\"qt\",ReplicationHandler.PATH);\n        QueryRequest req = new QueryRequest(params);\n    \n        NamedList<Object> res = replicaRunner.client.solrClient.request(req);\n        assertNotNull(\"null response from server: \" + replicaRunner.coreNodeName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + replicaRunner.coreNodeName, version);\n        assertTrue(\"version isn't a long: \"+replicaRunner.coreNodeName, \n                   version instanceof Long);\n        results.put(replicaRunner.coreNodeName, (Long)version);\n\n        long numDocs = replicaRunner.client.solrClient.query\n          (params(\"q\",\"*:*\",\"distrib\",\"false\",\"rows\",\"0\",\"_trace\",\"counting_docs\"))\n          .getResults().getNumFound();\n        log.info(\"core=\" + replicaRunner.coreNodeName + \"; ver=\" + version + \n                 \"; numDocs=\" + numDocs); \n\n      }\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","sourceNew":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    DocCollection collectionState = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n\n    for (Replica replica : collectionState.getReplicas()) {\n\n      String coreName = replica.getCoreName();\n      try (HttpSolrClient client = getHttpSolrClient(replica.getCoreUrl())) {\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\", \"indexversion\");\n        params.set(\"_trace\", \"getIndexVersion\");\n        params.set(\"qt\", ReplicationHandler.PATH);\n        QueryRequest req = new QueryRequest(params);\n\n        NamedList<Object> res = client.request(req);\n        assertNotNull(\"null response from server: \" + coreName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + coreName, version);\n        assertTrue(\"version isn't a long: \" + coreName, version instanceof Long);\n        results.put(coreName, (Long) version);\n\n        long numDocs = client.query(params(\"q\", \"*:*\", \"distrib\", \"false\", \"rows\", \"0\", \"_trace\", \"counting_docs\"))\n            .getResults().getNumFound();\n        log.info(\"core=\" + coreName + \"; ver=\" + version +\n            \"; numDocs=\" + numDocs);\n\n      }\n    }\n\n\n    return results;\n  }\n\n","sourceOld":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    for (List<CloudJettyRunner> listOfReplicas : shardToJetty.values()) {\n      for (CloudJettyRunner replicaRunner : listOfReplicas) {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\",\"indexversion\");\n        params.set(\"_trace\",\"getIndexVersion\");\n        params.set(\"qt\",ReplicationHandler.PATH);\n        QueryRequest req = new QueryRequest(params);\n    \n        NamedList<Object> res = replicaRunner.client.solrClient.request(req);\n        assertNotNull(\"null response from server: \" + replicaRunner.coreNodeName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + replicaRunner.coreNodeName, version);\n        assertTrue(\"version isn't a long: \"+replicaRunner.coreNodeName, \n                   version instanceof Long);\n        results.put(replicaRunner.coreNodeName, (Long)version);\n\n        long numDocs = replicaRunner.client.solrClient.query\n          (params(\"q\",\"*:*\",\"distrib\",\"false\",\"rows\",\"0\",\"_trace\",\"counting_docs\"))\n          .getResults().getNumFound();\n        log.info(\"core=\" + replicaRunner.coreNodeName + \"; ver=\" + version + \n                 \"; numDocs=\" + numDocs); \n\n      }\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","sourceNew":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    DocCollection collectionState = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n\n    for (Replica replica : collectionState.getReplicas()) {\n\n      String coreName = replica.getCoreName();\n      try (HttpSolrClient client = getHttpSolrClient(replica.getCoreUrl())) {\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\", \"indexversion\");\n        params.set(\"_trace\", \"getIndexVersion\");\n        params.set(\"qt\", ReplicationHandler.PATH);\n        QueryRequest req = new QueryRequest(params);\n\n        NamedList<Object> res = client.request(req);\n        assertNotNull(\"null response from server: \" + coreName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + coreName, version);\n        assertTrue(\"version isn't a long: \" + coreName, version instanceof Long);\n        results.put(coreName, (Long) version);\n\n        long numDocs = client.query(params(\"q\", \"*:*\", \"distrib\", \"false\", \"rows\", \"0\", \"_trace\", \"counting_docs\"))\n            .getResults().getNumFound();\n        log.info(\"core=\" + coreName + \"; ver=\" + version +\n            \"; numDocs=\" + numDocs);\n\n      }\n    }\n\n\n    return results;\n  }\n\n","sourceOld":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    for (List<CloudJettyRunner> listOfReplicas : shardToJetty.values()) {\n      for (CloudJettyRunner replicaRunner : listOfReplicas) {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\",\"indexversion\");\n        params.set(\"_trace\",\"getIndexVersion\");\n        params.set(\"qt\",ReplicationHandler.PATH);\n        QueryRequest req = new QueryRequest(params);\n    \n        NamedList<Object> res = replicaRunner.client.solrClient.request(req);\n        assertNotNull(\"null response from server: \" + replicaRunner.coreNodeName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + replicaRunner.coreNodeName, version);\n        assertTrue(\"version isn't a long: \"+replicaRunner.coreNodeName, \n                   version instanceof Long);\n        results.put(replicaRunner.coreNodeName, (Long)version);\n\n        long numDocs = replicaRunner.client.solrClient.query\n          (params(\"q\",\"*:*\",\"distrib\",\"false\",\"rows\",\"0\",\"_trace\",\"counting_docs\"))\n          .getResults().getNumFound();\n        log.info(\"core=\" + replicaRunner.coreNodeName + \"; ver=\" + version + \n                 \"; numDocs=\" + numDocs); \n\n      }\n    }\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c92ac83d1c2f8811300bb0df797465cca0aa8e92","date":1579710745,"type":5,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getTestDataForAllReplicas().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistribDocExpirationUpdateProcessorTest#getIndexVersionOfAllReplicas().mjava","sourceNew":"  /**\n   * returns a map whose key is the coreNodeName and whose value is data about that core needed for the test\n   */\n  private Map<String,ReplicaData> getTestDataForAllReplicas() throws IOException, SolrServerException {\n    Map<String,ReplicaData> results = new HashMap<>();\n\n    DocCollection collectionState = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n\n    for (Replica replica : collectionState.getReplicas()) {\n\n      String coreName = replica.getCoreName();\n      try (HttpSolrClient client = getHttpSolrClient(replica.getCoreUrl())) {\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\", \"indexversion\");\n        params.set(\"_trace\", \"getIndexVersion\");\n        params.set(\"qt\", ReplicationHandler.PATH);\n        QueryRequest req = setAuthIfNeeded(new QueryRequest(params));\n\n        NamedList<Object> res = client.request(req);\n        assertNotNull(\"null response from server: \" + coreName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + coreName, version);\n        assertTrue(\"version isn't a long: \" + coreName, version instanceof Long);\n\n        long numDocs = \n          setAuthIfNeeded(new QueryRequest\n                          (params(\"q\", \"*:*\",\n                                  \"distrib\", \"false\",\n                                  \"rows\", \"0\",\n                                  \"_trace\", \"counting_docs\"))).process(client).getResults().getNumFound();\n\n        final ReplicaData data = new ReplicaData(replica.getSlice(),coreName,(Long)version,numDocs);\n        log.info(\"{}\", data);\n        results.put(coreName, data);\n\n      }\n    }\n\n    return results;\n  }\n\n","sourceOld":"  /**\n   * returns a map whose key is the coreNodeName and whose value is what the replication\n   * handler returns for the indexversion\n   */\n  private Map<String,Long> getIndexVersionOfAllReplicas() throws IOException, SolrServerException {\n    Map<String,Long> results = new HashMap<String,Long>();\n\n    DocCollection collectionState = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n\n    for (Replica replica : collectionState.getReplicas()) {\n\n      String coreName = replica.getCoreName();\n      try (HttpSolrClient client = getHttpSolrClient(replica.getCoreUrl())) {\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(\"command\", \"indexversion\");\n        params.set(\"_trace\", \"getIndexVersion\");\n        params.set(\"qt\", ReplicationHandler.PATH);\n        QueryRequest req = new QueryRequest(params);\n\n        NamedList<Object> res = client.request(req);\n        assertNotNull(\"null response from server: \" + coreName, res);\n\n        Object version = res.get(\"indexversion\");\n        assertNotNull(\"null version from server: \" + coreName, version);\n        assertTrue(\"version isn't a long: \" + coreName, version instanceof Long);\n        results.put(coreName, (Long) version);\n\n        long numDocs = client.query(params(\"q\", \"*:*\", \"distrib\", \"false\", \"rows\", \"0\", \"_trace\", \"counting_docs\"))\n            .getResults().getNumFound();\n        log.info(\"core=\" + coreName + \"; ver=\" + version +\n            \"; numDocs=\" + numDocs);\n\n      }\n    }\n\n\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ca70fffb953aae4d27efbfc28758033a317f39b1"],"c92ac83d1c2f8811300bb0df797465cca0aa8e92":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ca70fffb953aae4d27efbfc28758033a317f39b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5ebf70dabe6279454c5ff460bdea3f0dc2814a86":["71475d88ea48a7d9a847f209667255318b3ea4c7"],"71475d88ea48a7d9a847f209667255318b3ea4c7":["ca70fffb953aae4d27efbfc28758033a317f39b1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["71475d88ea48a7d9a847f209667255318b3ea4c7","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c92ac83d1c2f8811300bb0df797465cca0aa8e92"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["71475d88ea48a7d9a847f209667255318b3ea4c7","5ebf70dabe6279454c5ff460bdea3f0dc2814a86"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"c92ac83d1c2f8811300bb0df797465cca0aa8e92":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5eb2511ababf862ea11e10761c70ee560cd84510","ca70fffb953aae4d27efbfc28758033a317f39b1"],"ca70fffb953aae4d27efbfc28758033a317f39b1":["5eb2511ababf862ea11e10761c70ee560cd84510","71475d88ea48a7d9a847f209667255318b3ea4c7"],"5ebf70dabe6279454c5ff460bdea3f0dc2814a86":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"71475d88ea48a7d9a847f209667255318b3ea4c7":["5ebf70dabe6279454c5ff460bdea3f0dc2814a86","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["c92ac83d1c2f8811300bb0df797465cca0aa8e92","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}