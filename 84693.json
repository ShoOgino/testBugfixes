{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    if (multiToken) {\n      return new FacetFieldProcessorUIF(fcontext, this, sf);\n    } else {\n      // single valued string\n      return new FacetFieldProcessorFC(fcontext, this, sf);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["dd0759e8803a09424422a329163d5900f6b10c42"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    if (multiToken) {\n      return new FacetFieldProcessorUIF(fcontext, this, sf);\n    } else {\n      // single valued string\n      return new FacetFieldProcessorFC(fcontext, this, sf);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"694c4ae1a6fef9d2740471ec0f3a8db6367817c8","date":1428290189,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    if (!multiToken || sf.hasDocValues()) {\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (multiToken) {\n      return new FacetFieldProcessorUIF(fcontext, this, sf);\n    } else {\n      // single valued string\n      return new FacetFieldProcessorFC(fcontext, this, sf);\n    }\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    if (multiToken) {\n      return new FacetFieldProcessorUIF(fcontext, this, sf);\n    } else {\n      // single valued string\n      return new FacetFieldProcessorFC(fcontext, this, sf);\n    }\n  }\n\n","bugFix":null,"bugIntro":["da82ad4c841d491f277436297bc692dcda1b01a2","dd0759e8803a09424422a329163d5900f6b10c42"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd0759e8803a09424422a329163d5900f6b10c42","date":1431227616,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.NumericType ntype = ft.getNumericType();\n\n    if (sf.hasDocValues() && ntype==null) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (!multiToken) {\n      if (sf.getType().getNumericType() != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n        // what about FacetFieldProcessorFC?\n      }\n    }\n\n    // Multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    if (!multiToken || sf.hasDocValues()) {\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (multiToken) {\n      return new FacetFieldProcessorUIF(fcontext, this, sf);\n    } else {\n      // single valued string\n      return new FacetFieldProcessorFC(fcontext, this, sf);\n    }\n  }\n\n","bugFix":["694c4ae1a6fef9d2740471ec0f3a8db6367817c8","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"bugIntro":["da82ad4c841d491f277436297bc692dcda1b01a2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9e13d0d4d8b6dc352cb304974502b9a36c153f78","date":1436492687,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.NumericType ntype = ft.getNumericType();\n\n    if (sf.hasDocValues() && ntype==null) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (!multiToken) {\n      if (sf.getType().getNumericType() != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n//        return new FacetFieldProcessorDV(fcontext, this, sf);\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n        // what about FacetFieldProcessorFC?\n      }\n    }\n\n    // Multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.NumericType ntype = ft.getNumericType();\n\n    if (sf.hasDocValues() && ntype==null) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (!multiToken) {\n      if (sf.getType().getNumericType() != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n        // what about FacetFieldProcessorFC?\n      }\n    }\n\n    // Multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82240bc1acbd51dd0fb06c0cbc5056991bba8d2e","date":1445972879,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.NumericType ntype = ft.getNumericType();\n\n    if (sf.hasDocValues() && ntype==null) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (!multiToken) {\n      if (sf.getType().getNumericType() != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n      }\n    }\n\n    // multivalued but field doesn't have docValues\n    if (method == FacetMethod.DV) {\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.NumericType ntype = ft.getNumericType();\n\n    if (sf.hasDocValues() && ntype==null) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (!multiToken) {\n      if (sf.getType().getNumericType() != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n//        return new FacetFieldProcessorDV(fcontext, this, sf);\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n        // what about FacetFieldProcessorFC?\n      }\n    }\n\n    // Multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":["da82ad4c841d491f277436297bc692dcda1b01a2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.LegacyNumericType ntype = ft.getNumericType();\n\n    if (sf.hasDocValues() && ntype==null) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (!multiToken) {\n      if (sf.getType().getNumericType() != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n      }\n    }\n\n    // multivalued but field doesn't have docValues\n    if (method == FacetMethod.DV) {\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.NumericType ntype = ft.getNumericType();\n\n    if (sf.hasDocValues() && ntype==null) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (!multiToken) {\n      if (sf.getType().getNumericType() != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n      }\n    }\n\n    // multivalued but field doesn't have docValues\n    if (method == FacetMethod.DV) {\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da82ad4c841d491f277436297bc692dcda1b01a2","date":1457969596,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.LegacyNumericType ntype = ft.getNumericType();\n\n    if (sf.hasDocValues() && ntype==null) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    if (!multiToken) {\n      if (sf.getType().getNumericType() != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n      }\n    }\n\n    // multivalued but field doesn't have docValues\n    if (method == FacetMethod.DV) {\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","bugFix":["82240bc1acbd51dd0fb06c0cbc5056991bba8d2e","dd0759e8803a09424422a329163d5900f6b10c42","694c4ae1a6fef9d2740471ec0f3a8db6367817c8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79759974460bc59933cd169acc94f5c6b16368d5","date":1471318443,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5af5ba0166322092193d4c29880b0f7670fc7ca0","date":1471440525,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3661d6742eed69ff6cc30ea2538d572624a7cdf8","date":1472676864,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    LegacyNumericType ntype = ft.getNumericType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"602cca3f75af03832471d8324bbc5b977a02969c","date":1472676981,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    LegacyNumericType ntype = ft.getNumericType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    LegacyNumericType ntype = ft.getNumericType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    LegacyNumericType ntype = ft.getNumericType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    LegacyNumericType ntype = ft.getNumericType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorByHashNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    LegacyNumericType ntype = ft.getNumericType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (method == FacetMethod.ENUM && sf.indexed()) {\n      throw new UnsupportedOperationException();\n    } else if (method == FacetMethod.STREAM && sf.indexed()) {\n      return new FacetFieldProcessorStream(fcontext, this, sf);\n    }\n\n    org.apache.lucene.document.FieldType.LegacyNumericType ntype = ft.getNumericType();\n\n    if (!multiToken) {\n      if (ntype != null) {\n        // single valued numeric (docvalues or fieldcache)\n        return new FacetFieldProcessorNumeric(fcontext, this, sf);\n      } else {\n        // single valued string...\n        return new FacetFieldProcessorDV(fcontext, this, sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    LegacyNumericType ntype = ft.getNumericType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5831ab7ea325668b9202bd682fac80e97cd4330c","date":1496621613,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0138536655ed6adafa2e07c09cd3c9572112922f","date":1497930179,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc && !ft.isPointField()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc && !ft.isPointField()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc && !ft.isPointField()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ecd422396c4a9414f67cb8eeaa8a0f7317f82dc","date":1510853281,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      if (multiToken && !sf.hasDocValues() && method!=FacetMethod.DV) {\n        // Match the access method from the first phase.\n        // It won't always matter, but does currently for an all-values bucket\n        return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n      }\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc && !ft.isPointField()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc && !ft.isPointField()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e","date":1541777404,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      if (multiToken && !sf.hasDocValues() && method!=FacetMethod.DV && sf.isUninvertible()) {\n        // Match the access method from the first phase.\n        // It won't always matter, but does currently for an all-values bucket\n        return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n      }\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc && !ft.isPointField()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV || !sf.isUninvertible()) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      if (multiToken && !sf.hasDocValues() && method!=FacetMethod.DV) {\n        // Match the access method from the first phase.\n        // It won't always matter, but does currently for an all-values bucket\n        return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n      }\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n      NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc && !ft.isPointField()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ce69d020f939568b84a1dbbfbd11bfd9907b73","date":1543618146,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      if (multiToken && !sf.hasDocValues() && method!=FacetMethod.DV && sf.isUninvertible()) {\n        // Match the access method from the first phase.\n        // It won't always matter, but does currently for an all-values bucket\n        return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n      }\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() && !ft.isPointField() &&\n        // wether we can use stream processing depends on wether this is a shard request, wether\n        // re-sorting has been requested, and if the effective sort during collection is \"index asc\"\n        ( fcontext.isShard()\n          // for a shard request, the effective per-shard sort must be index asc\n          ? FacetSort.INDEX_ASC.equals(null == prelim_sort ? sort : prelim_sort)\n          // for a non-shard request, we can only use streaming if there is no pre-sorting\n          : (null == prelim_sort && FacetSort.INDEX_ASC.equals( sort ) ) ) ) {\n          \n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV || !sf.isUninvertible()) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      if (multiToken && !sf.hasDocValues() && method!=FacetMethod.DV && sf.isUninvertible()) {\n        // Match the access method from the first phase.\n        // It won't always matter, but does currently for an all-values bucket\n        return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n      }\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() &&\n        \"index\".equals(sortVariable) && sortDirection == SortDirection.asc && !ft.isPointField()) {\n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV || !sf.isUninvertible()) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetField#createFacetProcessor(FacetContext).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      if (multiToken && !sf.hasDocValues() && method!=FacetMethod.DV && sf.isUninvertible()) {\n        // Match the access method from the first phase.\n        // It won't always matter, but does currently for an all-values bucket\n        return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n      }\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() && !ft.isPointField() &&\n        // wether we can use stream processing depends on wether this is a shard request, wether\n        // re-sorting has been requested, and if the effective sort during collection is \"index asc\"\n        ( fcontext.isShard()\n          // for a shard request, the effective per-shard sort must be index asc\n          ? FacetSort.INDEX_ASC.equals(null == prelim_sort ? sort : prelim_sort)\n          // for a non-shard request, we can only use streaming if there is no pre-sorting\n          : (null == prelim_sort && FacetSort.INDEX_ASC.equals( sort ) ) ) ) {\n          \n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV || !sf.isUninvertible()) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","sourceOld":"  @Override\n  public FacetProcessor createFacetProcessor(FacetContext fcontext) {\n    SchemaField sf = fcontext.searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (fcontext.facetInfo != null) {\n      // refinement... we will end up either skipping the entire facet, or doing calculating only specific facet buckets\n      if (multiToken && !sf.hasDocValues() && method!=FacetMethod.DV && sf.isUninvertible()) {\n        // Match the access method from the first phase.\n        // It won't always matter, but does currently for an all-values bucket\n        return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n      }\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    NumberType ntype = ft.getNumberType();\n    // ensure we can support the requested options for numeric faceting:\n    if (ntype != null) {\n      if (prefix != null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Doesn't make sense to set facet prefix on a numeric field\");\n      }\n      if (mincount == 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Numeric fields do not support facet mincount=0; try indexing as terms\");\n        // TODO if indexed=true then we could add support\n      }\n    }\n\n    // TODO auto-pick ENUM/STREAM SOLR-9351 when index asc and DocSet cardinality is *not* much smaller than term cardinality\n    if (method == FacetMethod.ENUM) {// at the moment these two are the same\n      method = FacetMethod.STREAM;\n    }\n    if (method == FacetMethod.STREAM && sf.indexed() && !ft.isPointField() &&\n        // wether we can use stream processing depends on wether this is a shard request, wether\n        // re-sorting has been requested, and if the effective sort during collection is \"index asc\"\n        ( fcontext.isShard()\n          // for a shard request, the effective per-shard sort must be index asc\n          ? FacetSort.INDEX_ASC.equals(null == prelim_sort ? sort : prelim_sort)\n          // for a non-shard request, we can only use streaming if there is no pre-sorting\n          : (null == prelim_sort && FacetSort.INDEX_ASC.equals( sort ) ) ) ) {\n          \n      return new FacetFieldProcessorByEnumTermsStream(fcontext, this, sf);\n    }\n\n    // TODO if method=UIF and not single-valued numerics then simply choose that now? TODO add FieldType.getDocValuesType()\n\n    if (!multiToken) {\n      if (mincount > 0 && prefix == null && (ntype != null || method == FacetMethod.DVHASH)) {\n        // TODO can we auto-pick for strings when term cardinality is much greater than DocSet cardinality?\n        //   or if we don't know cardinality but DocSet size is very small\n        return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n      } else if (ntype == null) {\n        // single valued string...\n        return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Couldn't pick facet algorithm for field \" + sf);\n      }\n    }\n\n    if (sf.hasDocValues() && sf.getType().isPointField()) {\n      return new FacetFieldProcessorByHashDV(fcontext, this, sf);\n    }\n\n    // multi-valued after this point\n\n    if (sf.hasDocValues() || method == FacetMethod.DV || !sf.isUninvertible()) {\n      // single and multi-valued string docValues\n      return new FacetFieldProcessorByArrayDV(fcontext, this, sf);\n    }\n\n    // Top-level multi-valued field cache (UIF)\n    return new FacetFieldProcessorByArrayUIF(fcontext, this, sf);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"694c4ae1a6fef9d2740471ec0f3a8db6367817c8":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"0138536655ed6adafa2e07c09cd3c9572112922f":["5831ab7ea325668b9202bd682fac80e97cd4330c"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["da82ad4c841d491f277436297bc692dcda1b01a2","5af5ba0166322092193d4c29880b0f7670fc7ca0"],"dd0759e8803a09424422a329163d5900f6b10c42":["694c4ae1a6fef9d2740471ec0f3a8db6367817c8"],"bc8f206328a706450934717bec7ccc22ad166fc0":["403d05f7f8d69b65659157eff1bc1d2717f04c66","602cca3f75af03832471d8324bbc5b977a02969c"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["0ecd422396c4a9414f67cb8eeaa8a0f7317f82dc"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["3d81baa64023bbb9b43f6d929ee168b105940d30","5831ab7ea325668b9202bd682fac80e97cd4330c"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"da82ad4c841d491f277436297bc692dcda1b01a2":["770342641f7b505eaa8dccdc666158bff2419109"],"0ecd422396c4a9414f67cb8eeaa8a0f7317f82dc":["28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["403d05f7f8d69b65659157eff1bc1d2717f04c66","602cca3f75af03832471d8324bbc5b977a02969c"],"3661d6742eed69ff6cc30ea2538d572624a7cdf8":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"5831ab7ea325668b9202bd682fac80e97cd4330c":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["da82ad4c841d491f277436297bc692dcda1b01a2","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"5af5ba0166322092193d4c29880b0f7670fc7ca0":["79759974460bc59933cd169acc94f5c6b16368d5"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"770342641f7b505eaa8dccdc666158bff2419109":["82240bc1acbd51dd0fb06c0cbc5056991bba8d2e"],"28288370235ed02234a64753cdbf0c6ec096304a":["3d81baa64023bbb9b43f6d929ee168b105940d30","0138536655ed6adafa2e07c09cd3c9572112922f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["da82ad4c841d491f277436297bc692dcda1b01a2","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"602cca3f75af03832471d8324bbc5b977a02969c":["3661d6742eed69ff6cc30ea2538d572624a7cdf8"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["dd0759e8803a09424422a329163d5900f6b10c42"],"82240bc1acbd51dd0fb06c0cbc5056991bba8d2e":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"79759974460bc59933cd169acc94f5c6b16368d5":["da82ad4c841d491f277436297bc692dcda1b01a2"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","0138536655ed6adafa2e07c09cd3c9572112922f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"]},"commit2Childs":{"694c4ae1a6fef9d2740471ec0f3a8db6367817c8":["dd0759e8803a09424422a329163d5900f6b10c42"],"0138536655ed6adafa2e07c09cd3c9572112922f":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"dd0759e8803a09424422a329163d5900f6b10c42":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"da82ad4c841d491f277436297bc692dcda1b01a2":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","403d05f7f8d69b65659157eff1bc1d2717f04c66","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","79759974460bc59933cd169acc94f5c6b16368d5"],"0ecd422396c4a9414f67cb8eeaa8a0f7317f82dc":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3d81baa64023bbb9b43f6d929ee168b105940d30"],"3661d6742eed69ff6cc30ea2538d572624a7cdf8":["602cca3f75af03832471d8324bbc5b977a02969c"],"5831ab7ea325668b9202bd682fac80e97cd4330c":["0138536655ed6adafa2e07c09cd3c9572112922f","e9017cf144952056066919f1ebc7897ff9bd71b1"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","3661d6742eed69ff6cc30ea2538d572624a7cdf8"],"5af5ba0166322092193d4c29880b0f7670fc7ca0":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"770342641f7b505eaa8dccdc666158bff2419109":["da82ad4c841d491f277436297bc692dcda1b01a2"],"28288370235ed02234a64753cdbf0c6ec096304a":["0ecd422396c4a9414f67cb8eeaa8a0f7317f82dc"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"602cca3f75af03832471d8324bbc5b977a02969c":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["e9017cf144952056066919f1ebc7897ff9bd71b1","5831ab7ea325668b9202bd682fac80e97cd4330c","28288370235ed02234a64753cdbf0c6ec096304a"],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["82240bc1acbd51dd0fb06c0cbc5056991bba8d2e"],"82240bc1acbd51dd0fb06c0cbc5056991bba8d2e":["770342641f7b505eaa8dccdc666158bff2419109"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["694c4ae1a6fef9d2740471ec0f3a8db6367817c8","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"79759974460bc59933cd169acc94f5c6b16368d5":["5af5ba0166322092193d4c29880b0f7670fc7ca0"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bc8f206328a706450934717bec7ccc22ad166fc0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}