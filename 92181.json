{"path":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","commits":[{"id":"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd","date":1361836936,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    int baseDocID = baseScorer.nextDoc();\n\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    int maxFreq = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      maxFreq = Math.max(maxFreq, dims[dim].freq);\n    }\n\n    // TODO: if we add cost API to Scorer, switch to that!\n    int estBaseHitCount = context.reader().maxDoc() / (1+baseDocID);\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseDocID + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxFreq=\" + maxFreq);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (estBaseHitCount < maxFreq/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].freq < estBaseHitCount/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["416910ae9ffe752ba5b6334f75d6c36e019626cc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76d37531298cae83f8dd7adcb73f3d0ceff83aa0","date":1366839837,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxFreq=\" + maxFreq);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxFreq < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    int baseDocID = baseScorer.nextDoc();\n\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    int maxFreq = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      maxFreq = Math.max(maxFreq, dims[dim].freq);\n    }\n\n    // TODO: if we add cost API to Scorer, switch to that!\n    int estBaseHitCount = context.reader().maxDoc() / (1+baseDocID);\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseDocID + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxFreq=\" + maxFreq);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (estBaseHitCount < maxFreq/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].freq < estBaseHitCount/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e2f479a58780f0a2a9c1c6f7202207a75d094cd9","date":1366841689,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxFreq=\" + maxFreq);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    //System.out.println(\"DS score \" + scoreSubDocsAtOnce);\n    if (!scoreSubDocsAtOnce) {\n      if (baseQueryCost < drillDownCost/10) {\n        //System.out.println(\"baseAdvance\");\n        doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n      } else if (numDims > 1 && (dims[1].maxFreq < baseQueryCost/10)) {\n        //System.out.println(\"drillDownAdvance\");\n        doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n      } else {\n        //System.out.println(\"union\");\n        doUnionScoring(collector, docsEnums, sidewaysCollectors);\n      }\n    } else {\n      // TODO: we should fallback to BS2 ReqOptSum scorer here\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxFreq=\" + maxFreq);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxFreq < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c56659f13067bffb93329ae60b4c25dccf9f87cc","date":1366842020,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    //System.out.println(\"DS score \" + scoreSubDocsAtOnce);\n    if (!scoreSubDocsAtOnce) {\n      if (baseQueryCost < drillDownCost/10) {\n        //System.out.println(\"baseAdvance\");\n        doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n      } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n        //System.out.println(\"drillDownAdvance\");\n        doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n      } else {\n        //System.out.println(\"union\");\n        doUnionScoring(collector, docsEnums, sidewaysCollectors);\n      }\n    } else {\n      // TODO: we should fallback to BS2 ReqOptSum scorer here\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxFreq=\" + maxFreq);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    //System.out.println(\"DS score \" + scoreSubDocsAtOnce);\n    if (!scoreSubDocsAtOnce) {\n      if (baseQueryCost < drillDownCost/10) {\n        //System.out.println(\"baseAdvance\");\n        doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n      } else if (numDims > 1 && (dims[1].maxFreq < baseQueryCost/10)) {\n        //System.out.println(\"drillDownAdvance\");\n        doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n      } else {\n        //System.out.println(\"union\");\n        doUnionScoring(collector, docsEnums, sidewaysCollectors);\n      }\n    } else {\n      // TODO: we should fallback to BS2 ReqOptSum scorer here\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"378fbd2626d3f584f8146e25acf62ee817361580","date":1367266329,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    //System.out.println(\"DS score \" + scoreSubDocsAtOnce);\n    if (!scoreSubDocsAtOnce) {\n      if (baseQueryCost < drillDownCost/10) {\n        //System.out.println(\"baseAdvance\");\n        doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n      } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n        //System.out.println(\"drillDownAdvance\");\n        doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n      } else {\n        //System.out.println(\"union\");\n        doUnionScoring(collector, docsEnums, sidewaysCollectors);\n      }\n    } else {\n      // TODO: we should fallback to BS2 ReqOptSum scorer here\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"416910ae9ffe752ba5b6334f75d6c36e019626cc","date":1367953778,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    drillDownCollector.setScorer(this);\n    drillDownCollector.setNextReader(context);\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70a110e2251baf0475c11d6e8621d4511ec7e5d4","date":1370960472,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      if (dim.docsEnums != null) {\n        for (DocsEnum docsEnum : dim.docsEnums) {\n          if (docsEnum != null) {\n            docsEnum.nextDoc();\n          }\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      if (dims[dim].docsEnums != null) {\n        for (DocsEnum de : dims[dim].docsEnums) {\n          if (de != null) {\n            drillDownCost += de.cost();\n          }\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for(DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for(DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"288adb8faeade0b0023dd7d85b86bf5f631a694a","date":1371310695,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for (DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for (DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      if (dim.docsEnums != null) {\n        for (DocsEnum docsEnum : dim.docsEnums) {\n          if (docsEnum != null) {\n            docsEnum.nextDoc();\n          }\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      if (dims[dim].docsEnums != null) {\n        for (DocsEnum de : dims[dim].docsEnums) {\n          if (de != null) {\n            drillDownCost += de.cost();\n          }\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee834e58357f79a6fc8770119cbf9d614da67c90","date":1371379780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for (DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for (DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      if (dim.docsEnums != null) {\n        for (DocsEnum docsEnum : dim.docsEnums) {\n          if (docsEnum != null) {\n            docsEnum.nextDoc();\n          }\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      if (dims[dim].docsEnums != null) {\n        for (DocsEnum de : dims[dim].docsEnums) {\n          if (de != null) {\n            drillDownCost += de.cost();\n          }\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33e19a97046248623a7591aeaa6547233fd15e2","date":1385424777,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for (DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for (DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#score(Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#score(Collector).mjava","sourceNew":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for (DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for (DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void score(Collector collector) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"\\nscore: reader=\" + context.reader());\n    //}\n    //System.out.println(\"score r=\" + context.reader());\n    collector.setScorer(this);\n    if (drillDownCollector != null) {\n      drillDownCollector.setScorer(this);\n      drillDownCollector.setNextReader(context);\n    }\n    for(DocsEnumsAndFreq dim : dims) {\n      dim.sidewaysCollector.setScorer(this);\n      dim.sidewaysCollector.setNextReader(context);\n    }\n\n    // TODO: if we ever allow null baseScorer ... it will\n    // mean we DO score docs out of order ... hmm, or if we\n    // change up the order of the conjuntions below\n    assert baseScorer != null;\n\n    // Position all scorers to their first matching doc:\n    baseScorer.nextDoc();\n    for(DocsEnumsAndFreq dim : dims) {\n      for (DocsEnum docsEnum : dim.docsEnums) {\n        if (docsEnum != null) {\n          docsEnum.nextDoc();\n        }\n      }\n    }\n\n    final int numDims = dims.length;\n\n    DocsEnum[][] docsEnums = new DocsEnum[numDims][];\n    Collector[] sidewaysCollectors = new Collector[numDims];\n    long drillDownCost = 0;\n    for(int dim=0;dim<numDims;dim++) {\n      docsEnums[dim] = dims[dim].docsEnums;\n      sidewaysCollectors[dim] = dims[dim].sidewaysCollector;\n      for (DocsEnum de : dims[dim].docsEnums) {\n        if (de != null) {\n          drillDownCost += de.cost();\n        }\n      }\n    }\n\n    long baseQueryCost = baseScorer.cost();\n\n    /*\n    System.out.println(\"\\nbaseDocID=\" + baseScorer.docID() + \" est=\" + estBaseHitCount);\n    System.out.println(\"  maxDoc=\" + context.reader().maxDoc());\n    System.out.println(\"  maxCost=\" + maxCost);\n    System.out.println(\"  dims[0].freq=\" + dims[0].freq);\n    if (numDims > 1) {\n      System.out.println(\"  dims[1].freq=\" + dims[1].freq);\n    }\n    */\n\n    if (baseQueryCost < drillDownCost/10) {\n      //System.out.println(\"baseAdvance\");\n      doBaseAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else if (numDims > 1 && (dims[1].maxCost < baseQueryCost/10)) {\n      //System.out.println(\"drillDownAdvance\");\n      doDrillDownAdvanceScoring(collector, docsEnums, sidewaysCollectors);\n    } else {\n      //System.out.println(\"union\");\n      doUnionScoring(collector, docsEnums, sidewaysCollectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d33e19a97046248623a7591aeaa6547233fd15e2":["288adb8faeade0b0023dd7d85b86bf5f631a694a"],"ee834e58357f79a6fc8770119cbf9d614da67c90":["70a110e2251baf0475c11d6e8621d4511ec7e5d4","288adb8faeade0b0023dd7d85b86bf5f631a694a"],"c56659f13067bffb93329ae60b4c25dccf9f87cc":["e2f479a58780f0a2a9c1c6f7202207a75d094cd9"],"70a110e2251baf0475c11d6e8621d4511ec7e5d4":["416910ae9ffe752ba5b6334f75d6c36e019626cc"],"416910ae9ffe752ba5b6334f75d6c36e019626cc":["378fbd2626d3f584f8146e25acf62ee817361580"],"378fbd2626d3f584f8146e25acf62ee817361580":["c56659f13067bffb93329ae60b4c25dccf9f87cc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2f479a58780f0a2a9c1c6f7202207a75d094cd9":["76d37531298cae83f8dd7adcb73f3d0ceff83aa0"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["288adb8faeade0b0023dd7d85b86bf5f631a694a","d33e19a97046248623a7591aeaa6547233fd15e2"],"76d37531298cae83f8dd7adcb73f3d0ceff83aa0":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"288adb8faeade0b0023dd7d85b86bf5f631a694a":["70a110e2251baf0475c11d6e8621d4511ec7e5d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["76d37531298cae83f8dd7adcb73f3d0ceff83aa0"],"d33e19a97046248623a7591aeaa6547233fd15e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"ee834e58357f79a6fc8770119cbf9d614da67c90":[],"c56659f13067bffb93329ae60b4c25dccf9f87cc":["378fbd2626d3f584f8146e25acf62ee817361580"],"70a110e2251baf0475c11d6e8621d4511ec7e5d4":["ee834e58357f79a6fc8770119cbf9d614da67c90","288adb8faeade0b0023dd7d85b86bf5f631a694a"],"416910ae9ffe752ba5b6334f75d6c36e019626cc":["70a110e2251baf0475c11d6e8621d4511ec7e5d4"],"378fbd2626d3f584f8146e25acf62ee817361580":["416910ae9ffe752ba5b6334f75d6c36e019626cc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"e2f479a58780f0a2a9c1c6f7202207a75d094cd9":["c56659f13067bffb93329ae60b4c25dccf9f87cc"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"76d37531298cae83f8dd7adcb73f3d0ceff83aa0":["e2f479a58780f0a2a9c1c6f7202207a75d094cd9"],"288adb8faeade0b0023dd7d85b86bf5f631a694a":["d33e19a97046248623a7591aeaa6547233fd15e2","ee834e58357f79a6fc8770119cbf9d614da67c90","3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ee834e58357f79a6fc8770119cbf9d614da67c90","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}