{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","commits":[{"id":"59db5e5f780185e0155d296a323e440a6ecfd3b6","date":1435089559,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","pathOld":"/dev/null","sourceNew":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock;\n\n    if (useAutoPrefixTerm) {\n      // If the current term was an auto-prefix term, we have to skip past it:\n      isSubBlock = skipPastLastAutoPrefixTerm();\n      assert useAutoPrefixTerm == false;\n    } else {\n      isSubBlock = popPushNext();\n    }\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          if (useAutoPrefixTerm) {\n            // All suffixes of this auto-prefix term are accepted by the automaton, so we can use it:\n            copyTerm();\n            currentFrame.termState.isRealTerm = false;\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","date":1466407389,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","sourceNew":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock;\n\n    if (useAutoPrefixTerm) {\n      // If the current term was an auto-prefix term, we have to skip past it:\n      isSubBlock = skipPastLastAutoPrefixTerm();\n      assert useAutoPrefixTerm == false;\n    } else {\n      isSubBlock = popPushNext();\n    }\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          if (useAutoPrefixTerm) {\n            // All suffixes of this auto-prefix term are accepted by the automaton, so we can use it:\n            copyTerm();\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","sourceOld":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock;\n\n    if (useAutoPrefixTerm) {\n      // If the current term was an auto-prefix term, we have to skip past it:\n      isSubBlock = skipPastLastAutoPrefixTerm();\n      assert useAutoPrefixTerm == false;\n    } else {\n      isSubBlock = popPushNext();\n    }\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          if (useAutoPrefixTerm) {\n            // All suffixes of this auto-prefix term are accepted by the automaton, so we can use it:\n            copyTerm();\n            currentFrame.termState.isRealTerm = false;\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","sourceNew":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock;\n\n    if (useAutoPrefixTerm) {\n      // If the current term was an auto-prefix term, we have to skip past it:\n      isSubBlock = skipPastLastAutoPrefixTerm();\n      assert useAutoPrefixTerm == false;\n    } else {\n      isSubBlock = popPushNext();\n    }\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          if (useAutoPrefixTerm) {\n            // All suffixes of this auto-prefix term are accepted by the automaton, so we can use it:\n            copyTerm();\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","sourceOld":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock;\n\n    if (useAutoPrefixTerm) {\n      // If the current term was an auto-prefix term, we have to skip past it:\n      isSubBlock = skipPastLastAutoPrefixTerm();\n      assert useAutoPrefixTerm == false;\n    } else {\n      isSubBlock = popPushNext();\n    }\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          if (useAutoPrefixTerm) {\n            // All suffixes of this auto-prefix term are accepted by the automaton, so we can use it:\n            copyTerm();\n            currentFrame.termState.isRealTerm = false;\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","sourceNew":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock;\n\n    if (useAutoPrefixTerm) {\n      // If the current term was an auto-prefix term, we have to skip past it:\n      isSubBlock = skipPastLastAutoPrefixTerm();\n      assert useAutoPrefixTerm == false;\n    } else {\n      isSubBlock = popPushNext();\n    }\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          if (useAutoPrefixTerm) {\n            // All suffixes of this auto-prefix term are accepted by the automaton, so we can use it:\n            copyTerm();\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","sourceOld":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock;\n\n    if (useAutoPrefixTerm) {\n      // If the current term was an auto-prefix term, we have to skip past it:\n      isSubBlock = skipPastLastAutoPrefixTerm();\n      assert useAutoPrefixTerm == false;\n    } else {\n      isSubBlock = popPushNext();\n    }\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          if (useAutoPrefixTerm) {\n            // All suffixes of this auto-prefix term are accepted by the automaton, so we can use it:\n            copyTerm();\n            currentFrame.termState.isRealTerm = false;\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd96a930cc08d72beee719cc11ce465b9d9861c3","date":1535640296,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","sourceNew":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock = popPushNext();\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","sourceOld":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock;\n\n    if (useAutoPrefixTerm) {\n      // If the current term was an auto-prefix term, we have to skip past it:\n      isSubBlock = skipPastLastAutoPrefixTerm();\n      assert useAutoPrefixTerm == false;\n    } else {\n      isSubBlock = popPushNext();\n    }\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          if (useAutoPrefixTerm) {\n            // All suffixes of this auto-prefix term are accepted by the automaton, so we can use it:\n            copyTerm();\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2af44fa9bd43d5df330d6438c1af390323f7d567","date":1574847240,"type":3,"author":"Benedict Jin","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#_next().mjava","sourceNew":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock = popPushNext();\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself accepted\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","sourceOld":"  private BytesRef _next() throws IOException {\n\n    boolean isSubBlock = popPushNext();\n\n    nextTerm:\n\n    while (true) {\n      assert currentFrame.transition == currentTransition;\n\n      int state;\n      int lastState;\n\n      // NOTE: suffix == 0 can only happen on the first term in a block, when\n      // there is a term exactly matching a prefix in the index.  If we\n      // could somehow re-org the code so we only checked this case immediately\n      // after pushing a frame...\n      if (currentFrame.suffix != 0) {\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n\n        // This is the first byte of the suffix of the term we are now on:\n        final int label = suffixBytes[currentFrame.startBytePos] & 0xff;\n\n        if (label < currentTransition.min) {\n          // Common case: we are scanning terms in this block to \"catch up\" to\n          // current transition in the automaton:\n          int minTrans = currentTransition.min;\n          while (currentFrame.nextEnt < currentFrame.entCount) {\n            isSubBlock = currentFrame.next();\n            if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n              continue nextTerm;\n            }\n          }\n\n          // End of frame:\n          isSubBlock = popPushNext();\n          continue nextTerm;\n        }\n\n        // Advance where we are in the automaton to match this label:\n\n        while (label > currentTransition.max) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            if (currentFrame.ord == 0) {\n              // Provoke NPE if we are (illegally!) called again:\n              currentFrame = null;\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentTransition);\n\n          if (label < currentTransition.min) {\n            int minTrans = currentTransition.min;\n            while (currentFrame.nextEnt < currentFrame.entCount) {\n              isSubBlock = currentFrame.next();\n              if ((suffixBytes[currentFrame.startBytePos] & 0xff) >= minTrans) {\n                continue nextTerm;\n              }\n            }\n\n            // End of frame:\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n\n        if (commonSuffix != null && !isSubBlock) {\n          final int termLen = currentFrame.prefix + currentFrame.suffix;\n          if (termLen < commonSuffix.length) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n\n          final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n          final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n          assert commonSuffix.offset == 0;\n          int suffixBytesPos;\n          int commonSuffixBytesPos = 0;\n\n          if (lenInPrefix > 0) {\n            // A prefix of the common suffix overlaps with\n            // the suffix of the block prefix so we first\n            // test whether the prefix part matches:\n            final byte[] termBytes = term.bytes;\n            int termBytesPos = currentFrame.prefix - lenInPrefix;\n            assert termBytesPos >= 0;\n            final int termBytesPosEnd = currentFrame.prefix;\n            while (termBytesPos < termBytesPosEnd) {\n              if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n                isSubBlock = popPushNext();\n                continue nextTerm;\n              }\n            }\n            suffixBytesPos = currentFrame.startBytePos;\n          } else {\n            suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n          }\n\n          // Test overlapping suffix part:\n          final int commonSuffixBytesPosEnd = commonSuffix.length;\n          while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n            if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              isSubBlock = popPushNext();\n              continue nextTerm;\n            }\n          }\n        }\n\n        // TODO: maybe we should do the same linear test\n        // that AutomatonTermsEnum does, so that if we\n        // reach a part of the automaton where .* is\n        // \"temporarily\" accepted, we just blindly .next()\n        // until the limit\n\n        // See if the term suffix matches the automaton:\n\n        // We know from above that the first byte in our suffix (label) matches\n        // the current transition, so we step from the 2nd byte\n        // in the suffix:\n        lastState = currentFrame.state;\n        state = currentTransition.dest;\n\n        int end = currentFrame.startBytePos + currentFrame.suffix;\n        for (int idx=currentFrame.startBytePos+1;idx<end;idx++) {\n          lastState = state;\n          state = runAutomaton.step(state, suffixBytes[idx] & 0xff);\n          if (state == -1) {\n            // No match\n            isSubBlock = popPushNext();\n            continue nextTerm;\n          }\n        }\n      } else {\n        state = currentFrame.state;\n        lastState = currentFrame.lastState;\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentTransition = currentFrame.transition;\n        currentFrame.lastState = lastState;\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        // This term is a prefix of a term accepted by the automaton, but is not itself acceptd\n      }\n\n      isSubBlock = popPushNext();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"59db5e5f780185e0155d296a323e440a6ecfd3b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["59db5e5f780185e0155d296a323e440a6ecfd3b6","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["59db5e5f780185e0155d296a323e440a6ecfd3b6"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2af44fa9bd43d5df330d6438c1af390323f7d567":["dd96a930cc08d72beee719cc11ce465b9d9861c3"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["59db5e5f780185e0155d296a323e440a6ecfd3b6","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2af44fa9bd43d5df330d6438c1af390323f7d567"]},"commit2Childs":{"59db5e5f780185e0155d296a323e440a6ecfd3b6":["6aaba221b22442bdf0ef28770c25fe259dfb3f55","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["dd96a930cc08d72beee719cc11ce465b9d9861c3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["2af44fa9bd43d5df330d6438c1af390323f7d567"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["59db5e5f780185e0155d296a323e440a6ecfd3b6"],"2af44fa9bd43d5df330d6438c1af390323f7d567":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}