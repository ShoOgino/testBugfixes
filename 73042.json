{"path":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroupHeads) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0]);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroupHeads) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0]);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85d41890f2bad879e6a04c6dd7d2cf276f973994","date":1338488367,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroupHeads) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroupHeads) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0]);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","bugFix":["3ec363f8022f02e8aca0cc8dfc2cdd6bc5d87e29"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4d7ac4188c98a500b3ecca495071d74ccd9cbc7","date":1354368601,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroupHeads) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","bugFix":["3ec363f8022f02e8aca0cc8dfc2cdd6bc5d87e29"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroupHeads) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","bugFix":["3ec363f8022f02e8aca0cc8dfc2cdd6bc5d87e29"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97d4692d0c601ff773f0a2231967312428a904e4","date":1366026608,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Query,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, cachedCollector);\n    } else {\n      searcher.search(query, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<>();\n      collectors.add(firstPassCollector);\n      if (allGroups) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0], Float.NaN);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"85d41890f2bad879e6a04c6dd7d2cf276f973994":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["c4d7ac4188c98a500b3ecca495071d74ccd9cbc7","0837ab0472feecb3a54260729d845f839e1cbd72"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["97d4692d0c601ff773f0a2231967312428a904e4"],"97d4692d0c601ff773f0a2231967312428a904e4":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"c4d7ac4188c98a500b3ecca495071d74ccd9cbc7":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["85d41890f2bad879e6a04c6dd7d2cf276f973994","c4d7ac4188c98a500b3ecca495071d74ccd9cbc7"],"0837ab0472feecb3a54260729d845f839e1cbd72":["407687e67faf6e1f02a211ca078d8e3eed631027"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"]},"commit2Childs":{"85d41890f2bad879e6a04c6dd7d2cf276f973994":["c4d7ac4188c98a500b3ecca495071d74ccd9cbc7","407687e67faf6e1f02a211ca078d8e3eed631027"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["97d4692d0c601ff773f0a2231967312428a904e4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"c4d7ac4188c98a500b3ecca495071d74ccd9cbc7":["d4d69c535930b5cce125cff868d40f6373dc27d4","407687e67faf6e1f02a211ca078d8e3eed631027"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"97d4692d0c601ff773f0a2231967312428a904e4":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"407687e67faf6e1f02a211ca078d8e3eed631027":["0837ab0472feecb3a54260729d845f839e1cbd72"],"0837ab0472feecb3a54260729d845f839e1cbd72":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}