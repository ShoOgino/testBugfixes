{"path":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String).mjava","commits":[{"id":"e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0","date":1433439403,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, new Callable<FileSystem>() {\n        @Override\n        public FileSystem call() throws IOException {\n          return FileSystem.get(dataDirPath.toUri(), conf);\n        }\n      });\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Set<String> livePaths = getLivePaths();\n    for (FileStatus oldDir : oldIndexDirs) {\n      Path oldDirPath = oldDir.getPath();\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["60788e79302b77255f71a4bcfc58a2424a205d9c","add53de9835b2cd1a7a80b4e0036afee171c9fdf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String).mjava","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, () -> FileSystem.get(dataDirPath.toUri(), conf));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Set<String> livePaths = getLivePaths();\n    for (FileStatus oldDir : oldIndexDirs) {\n      Path oldDirPath = oldDir.getPath();\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, new Callable<FileSystem>() {\n        @Override\n        public FileSystem call() throws IOException {\n          return FileSystem.get(dataDirPath.toUri(), conf);\n        }\n      });\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Set<String> livePaths = getLivePaths();\n    for (FileStatus oldDir : oldIndexDirs) {\n      Path oldDirPath = oldDir.getPath();\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["60788e79302b77255f71a4bcfc58a2424a205d9c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String).mjava","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, () -> FileSystem.get(dataDirPath.toUri(), conf));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Set<String> livePaths = getLivePaths();\n    for (FileStatus oldDir : oldIndexDirs) {\n      Path oldDirPath = oldDir.getPath();\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, new Callable<FileSystem>() {\n        @Override\n        public FileSystem call() throws IOException {\n          return FileSystem.get(dataDirPath.toUri(), conf);\n        }\n      });\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Set<String> livePaths = getLivePaths();\n    for (FileStatus oldDir : oldIndexDirs) {\n      Path oldDirPath = oldDir.getPath();\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad28156288ac00b91352582904d97e6653205757","date":1486850922,"type":5,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String).mjava","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, () -> FileSystem.get(dataDirPath.toUri(), conf));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n    \n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      LOG.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    LOG.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, () -> FileSystem.get(dataDirPath.toUri(), conf));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Set<String> livePaths = getLivePaths();\n    for (FileStatus oldDir : oldIndexDirs) {\n      Path oldDirPath = oldDir.getPath();\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ad28156288ac00b91352582904d97e6653205757":["b6284684320a9808c41a5e43de958b2da22f89bd"],"043df2e9a841864922c32756a44c939ed768cb89":["e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0"],"e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b6284684320a9808c41a5e43de958b2da22f89bd":["e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0","043df2e9a841864922c32756a44c939ed768cb89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad28156288ac00b91352582904d97e6653205757"]},"commit2Childs":{"ad28156288ac00b91352582904d97e6653205757":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"b6284684320a9808c41a5e43de958b2da22f89bd":["ad28156288ac00b91352582904d97e6653205757"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}