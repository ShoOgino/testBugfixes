{"path":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","commits":[{"id":"5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392","date":1286023472,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are > 2 +\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b50bea3a34f005728e10c71d596cbf10b31d0e59","date":1286112171,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are > 2 +\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01f60198ece724a6e96cd0b45f289cf42ff83d4f","date":1286864103,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef,int).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef} with a pre-calculated hash code.\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @param code\n   *          the bytes hash code\n   * \n   *          <p>\n   *          Hashcode is defined as:\n   * \n   *          <pre>\n   * int hash = 0;\n   * for (int i = offset; i &lt; offset + length; i++) {\n   *   hash = 31 * hash + bytes[i];\n   * }\n   * </pre>\n   * \n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are >\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE} - 2\n   */\n  public int add(BytesRef bytes, int code) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    int hashPos = code & hashMask;\n    int e = ords[hashPos];\n    if (e != -1 && !equals(e, bytes)) {\n      // Conflict: keep searching different locations in\n      // the hash table.\n      final int inc = ((code >> 8) + code) | 1;\n      do {\n        code += inc;\n        hashPos = code & hashMask;\n        e = ords[hashPos];\n      } while (e != -1 && !equals(e, bytes));\n    }\n\n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ords[hashPos] == -1;\n      ords[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["b50bea3a34f005728e10c71d596cbf10b31d0e59","2e8d7ba2175f47e280231533f7d3016249cea88b"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["b50bea3a34f005728e10c71d596cbf10b31d0e59","01f60198ece724a6e96cd0b45f289cf42ff83d4f"],"5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b50bea3a34f005728e10c71d596cbf10b31d0e59":["5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b50bea3a34f005728e10c71d596cbf10b31d0e59"],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["b50bea3a34f005728e10c71d596cbf10b31d0e59"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392":["b50bea3a34f005728e10c71d596cbf10b31d0e59"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"b50bea3a34f005728e10c71d596cbf10b31d0e59":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","2e8d7ba2175f47e280231533f7d3016249cea88b","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","01f60198ece724a6e96cd0b45f289cf42ff83d4f"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}