{"path":"lucene/core/src/java/org/apache/lucene/document/LongDistanceFeatureQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","commits":[{"id":"d0dc52d2a83be9420989b1976a8e9d937160e1e5","date":1536062604,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LongDistanceFeatureQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    return new Weight(this) {\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return false;\n      }\n\n      @Override\n      public void extractTerms(Set<Term> terms) {}\n\n      @Override\n      public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n        SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        if (multiDocValues.advanceExact(doc) == false) {\n          return Explanation.noMatch(\"Document \" + doc + \" doesn't have a value for field \" + field);\n        }\n        long value = selectValue(multiDocValues);\n        long distance = Math.max(value, origin) - Math.min(value, origin);\n        if (distance < 0) {\n          // underflow, treat as MAX_VALUE\n          distance = Long.MAX_VALUE;\n        }\n        float score = (float) (boost * (pivotDistance / (pivotDistance + (double) distance)));\n        return Explanation.match(score, \"Distance score, computed as weight * pivotDistance / (pivotDistance + abs(value - origin)) from:\",\n            Explanation.match(boost, \"weight\"),\n            Explanation.match(pivotDistance, \"pivotDistance\"),\n            Explanation.match(origin, \"origin\"),\n            Explanation.match(value, \"current value\"));\n      }\n\n      private long selectValue(SortedNumericDocValues multiDocValues) throws IOException {\n        int count = multiDocValues.docValueCount();\n\n        long next = multiDocValues.nextValue();\n        if (count == 1 || next >= origin) {\n          return next;\n        }\n        long previous = next;\n        for (int i = 1; i < count; ++i) {\n          next = multiDocValues.nextValue();\n          if (next >= origin) {\n            // Unsigned comparison because of underflows\n            if (Long.compareUnsigned(origin - previous, next - origin) < 0) {\n              return previous;\n            } else {\n              return next;\n            }\n          }\n          previous = next;\n        }\n\n        assert next < origin;\n        return next;\n      }\n\n      private NumericDocValues selectValues(SortedNumericDocValues multiDocValues) {\n        final NumericDocValues singleton = DocValues.unwrapSingleton(multiDocValues);\n        if (singleton != null) {\n          return singleton;\n        }\n        return  new NumericDocValues() {\n\n          long value;\n\n          @Override\n          public long longValue() throws IOException {\n            return value;\n          }\n\n          @Override\n          public boolean advanceExact(int target) throws IOException {\n            if (multiDocValues.advanceExact(target)) {\n              value = selectValue(multiDocValues);\n              return true;\n            } else {\n              return false;\n            }\n          }\n\n          @Override\n          public int docID() {\n            return multiDocValues.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return multiDocValues.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return multiDocValues.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return multiDocValues.cost();\n          }\n\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        PointValues pointValues = context.reader().getPointValues(field);\n        if (pointValues == null) {\n          // No data on this segment\n          return null;\n        }\n        final SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        final NumericDocValues docValues = selectValues(multiDocValues);\n\n        final Weight weight = this;\n        return new ScorerSupplier() {\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return new DistanceScorer(weight, context.reader().maxDoc(), leadCost, boost, pointValues, docValues);\n          }\n\n          @Override\n          public long cost() {\n            return docValues.cost();\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7","date":1552575873,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LongDistanceFeatureQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LongDistanceFeatureQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    return new Weight(this) {\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return false;\n      }\n\n      @Override\n      public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n        SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        if (multiDocValues.advanceExact(doc) == false) {\n          return Explanation.noMatch(\"Document \" + doc + \" doesn't have a value for field \" + field);\n        }\n        long value = selectValue(multiDocValues);\n        long distance = Math.max(value, origin) - Math.min(value, origin);\n        if (distance < 0) {\n          // underflow, treat as MAX_VALUE\n          distance = Long.MAX_VALUE;\n        }\n        float score = (float) (boost * (pivotDistance / (pivotDistance + (double) distance)));\n        return Explanation.match(score, \"Distance score, computed as weight * pivotDistance / (pivotDistance + abs(value - origin)) from:\",\n            Explanation.match(boost, \"weight\"),\n            Explanation.match(pivotDistance, \"pivotDistance\"),\n            Explanation.match(origin, \"origin\"),\n            Explanation.match(value, \"current value\"));\n      }\n\n      private long selectValue(SortedNumericDocValues multiDocValues) throws IOException {\n        int count = multiDocValues.docValueCount();\n\n        long next = multiDocValues.nextValue();\n        if (count == 1 || next >= origin) {\n          return next;\n        }\n        long previous = next;\n        for (int i = 1; i < count; ++i) {\n          next = multiDocValues.nextValue();\n          if (next >= origin) {\n            // Unsigned comparison because of underflows\n            if (Long.compareUnsigned(origin - previous, next - origin) < 0) {\n              return previous;\n            } else {\n              return next;\n            }\n          }\n          previous = next;\n        }\n\n        assert next < origin;\n        return next;\n      }\n\n      private NumericDocValues selectValues(SortedNumericDocValues multiDocValues) {\n        final NumericDocValues singleton = DocValues.unwrapSingleton(multiDocValues);\n        if (singleton != null) {\n          return singleton;\n        }\n        return  new NumericDocValues() {\n\n          long value;\n\n          @Override\n          public long longValue() throws IOException {\n            return value;\n          }\n\n          @Override\n          public boolean advanceExact(int target) throws IOException {\n            if (multiDocValues.advanceExact(target)) {\n              value = selectValue(multiDocValues);\n              return true;\n            } else {\n              return false;\n            }\n          }\n\n          @Override\n          public int docID() {\n            return multiDocValues.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return multiDocValues.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return multiDocValues.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return multiDocValues.cost();\n          }\n\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        PointValues pointValues = context.reader().getPointValues(field);\n        if (pointValues == null) {\n          // No data on this segment\n          return null;\n        }\n        final SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        final NumericDocValues docValues = selectValues(multiDocValues);\n\n        final Weight weight = this;\n        return new ScorerSupplier() {\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return new DistanceScorer(weight, context.reader().maxDoc(), leadCost, boost, pointValues, docValues);\n          }\n\n          @Override\n          public long cost() {\n            return docValues.cost();\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    return new Weight(this) {\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return false;\n      }\n\n      @Override\n      public void extractTerms(Set<Term> terms) {}\n\n      @Override\n      public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n        SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        if (multiDocValues.advanceExact(doc) == false) {\n          return Explanation.noMatch(\"Document \" + doc + \" doesn't have a value for field \" + field);\n        }\n        long value = selectValue(multiDocValues);\n        long distance = Math.max(value, origin) - Math.min(value, origin);\n        if (distance < 0) {\n          // underflow, treat as MAX_VALUE\n          distance = Long.MAX_VALUE;\n        }\n        float score = (float) (boost * (pivotDistance / (pivotDistance + (double) distance)));\n        return Explanation.match(score, \"Distance score, computed as weight * pivotDistance / (pivotDistance + abs(value - origin)) from:\",\n            Explanation.match(boost, \"weight\"),\n            Explanation.match(pivotDistance, \"pivotDistance\"),\n            Explanation.match(origin, \"origin\"),\n            Explanation.match(value, \"current value\"));\n      }\n\n      private long selectValue(SortedNumericDocValues multiDocValues) throws IOException {\n        int count = multiDocValues.docValueCount();\n\n        long next = multiDocValues.nextValue();\n        if (count == 1 || next >= origin) {\n          return next;\n        }\n        long previous = next;\n        for (int i = 1; i < count; ++i) {\n          next = multiDocValues.nextValue();\n          if (next >= origin) {\n            // Unsigned comparison because of underflows\n            if (Long.compareUnsigned(origin - previous, next - origin) < 0) {\n              return previous;\n            } else {\n              return next;\n            }\n          }\n          previous = next;\n        }\n\n        assert next < origin;\n        return next;\n      }\n\n      private NumericDocValues selectValues(SortedNumericDocValues multiDocValues) {\n        final NumericDocValues singleton = DocValues.unwrapSingleton(multiDocValues);\n        if (singleton != null) {\n          return singleton;\n        }\n        return  new NumericDocValues() {\n\n          long value;\n\n          @Override\n          public long longValue() throws IOException {\n            return value;\n          }\n\n          @Override\n          public boolean advanceExact(int target) throws IOException {\n            if (multiDocValues.advanceExact(target)) {\n              value = selectValue(multiDocValues);\n              return true;\n            } else {\n              return false;\n            }\n          }\n\n          @Override\n          public int docID() {\n            return multiDocValues.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return multiDocValues.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return multiDocValues.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return multiDocValues.cost();\n          }\n\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        PointValues pointValues = context.reader().getPointValues(field);\n        if (pointValues == null) {\n          // No data on this segment\n          return null;\n        }\n        final SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        final NumericDocValues docValues = selectValues(multiDocValues);\n\n        final Weight weight = this;\n        return new ScorerSupplier() {\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return new DistanceScorer(weight, context.reader().maxDoc(), leadCost, boost, pointValues, docValues);\n          }\n\n          @Override\n          public long cost() {\n            return docValues.cost();\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d0dc52d2a83be9420989b1976a8e9d937160e1e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["d0dc52d2a83be9420989b1976a8e9d937160e1e5"]},"commit2Childs":{"d0dc52d2a83be9420989b1976a8e9d937160e1e5":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d0dc52d2a83be9420989b1976a8e9d937160e1e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}