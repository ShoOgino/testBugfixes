{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      is = new FileInputStream(path);\n    }\n    File file = new File(path);\n    long size;\n    if (file.exists()) {\n      size = file.length();\n    } else {\n      size = is.available();\n    }\n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n\n    reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"), BUFFER_SIZE);\n\n    // Override sizes for currently \"known\" line files:\n    if (path.equals(\"europarl.lines.txt.gz\")) {\n      size = 15129506L;\n    } else if (path.equals(\"/home/hudson/lucene-data/enwiki.random.lines.txt.gz\")) {\n      size = 3038178822L;\n    }\n\n    // Randomly seek to starting point:\n    if (random != null && size > 3) {\n      final long seekTo = (random.nextLong()&Long.MAX_VALUE) % (size/3);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: seek to fp=\" + seekTo + \" on open\");\n      }\n      reader.skip(seekTo);\n      reader.readLine();\n    }\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      is = new FileInputStream(path);\n    }\n    File file = new File(path);\n    long size;\n    if (file.exists()) {\n      size = file.length();\n    } else {\n      size = is.available();\n    }\n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n\n    reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"), BUFFER_SIZE);\n\n    // Override sizes for currently \"known\" line files:\n    if (path.equals(\"europarl.lines.txt.gz\")) {\n      size = 15129506L;\n    } else if (path.equals(\"/home/hudson/lucene-data/enwiki.random.lines.txt.gz\")) {\n      size = 3038178822L;\n    }\n\n    // Randomly seek to starting point:\n    if (random != null && size > 3) {\n      final long seekTo = (random.nextLong()&Long.MAX_VALUE) % (size/3);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: seek to fp=\" + seekTo + \" on open\");\n      }\n      reader.skip(seekTo);\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bec980e97bb70b407220acaab91a516063e4adb9","date":1336685173,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      is = new FileInputStream(path);\n    }\n    File file = new File(path);\n    long size;\n    if (file.exists()) {\n      size = file.length();\n    } else {\n      size = is.available();\n    }\n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n\n    // Override sizes for currently \"known\" line files:\n    if (path.equals(\"europarl.lines.txt.gz\")) {\n      size = 15129506L;\n    } else if (path.equals(\"/home/hudson/lucene-data/enwiki.random.lines.txt.gz\")) {\n      size = 3038178822L;\n    }\n\n    // Randomly seek to starting point:\n    if (random != null && size > 3) {\n      final long seekTo = (random.nextLong()&Long.MAX_VALUE) % (size/3);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: seek to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n      CharsetDecoder decoder = Charset.forName(\"UTF-8\").newDecoder()\n          .onMalformedInput(CodingErrorAction.IGNORE)\n          .onUnmappableCharacter(CodingErrorAction.IGNORE);\n      reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n      reader.readLine();\n    }\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      is = new FileInputStream(path);\n    }\n    File file = new File(path);\n    long size;\n    if (file.exists()) {\n      size = file.length();\n    } else {\n      size = is.available();\n    }\n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n\n    reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"), BUFFER_SIZE);\n\n    // Override sizes for currently \"known\" line files:\n    if (path.equals(\"europarl.lines.txt.gz\")) {\n      size = 15129506L;\n    } else if (path.equals(\"/home/hudson/lucene-data/enwiki.random.lines.txt.gz\")) {\n      size = 3038178822L;\n    }\n\n    // Randomly seek to starting point:\n    if (random != null && size > 3) {\n      final long seekTo = (random.nextLong()&Long.MAX_VALUE) % (size/3);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: seek to fp=\" + seekTo + \" on open\");\n      }\n      reader.skip(seekTo);\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bcdad5ed59ddef632dd7c1ea71358a18c35e167","date":1336691418,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      File file = new File(path);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = new FileInputStream(file);\n      } else {\n        // optimized seek using RandomAccessFile:\n        size = file.length();\n        final long seekTo = randomSeekPos(random, size);\n        final FileChannel channel = new RandomAccessFile(path, \"r\").getChannel();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      final long skipTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + skipTo + \" on open\");\n      }\n      is.skip(skipTo);\n    }\n    \n    int b;\n    do {\n      b = is.read();\n    } while (b >= 0 && b != 13 && b != 10);\n    CharsetDecoder decoder = Charset.forName(\"UTF-8\").newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n    reader.readLine();\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      is = new FileInputStream(path);\n    }\n    File file = new File(path);\n    long size;\n    if (file.exists()) {\n      size = file.length();\n    } else {\n      size = is.available();\n    }\n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n\n    // Override sizes for currently \"known\" line files:\n    if (path.equals(\"europarl.lines.txt.gz\")) {\n      size = 15129506L;\n    } else if (path.equals(\"/home/hudson/lucene-data/enwiki.random.lines.txt.gz\")) {\n      size = 3038178822L;\n    }\n\n    // Randomly seek to starting point:\n    if (random != null && size > 3) {\n      final long seekTo = (random.nextLong()&Long.MAX_VALUE) % (size/3);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: seek to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n      CharsetDecoder decoder = Charset.forName(\"UTF-8\").newDecoder()\n          .onMalformedInput(CodingErrorAction.IGNORE)\n          .onUnmappableCharacter(CodingErrorAction.IGNORE);\n      reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"26c5e07e414b7d1aeed5448cbd713ba76fc5e7ed","date":1336703505,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      File file = new File(path);\n      size = file.length();\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = new FileInputStream(file);\n      } else {\n        // optimized seek using RandomAccessFile:\n        seekTo = randomSeekPos(random, size);\n        final FileChannel channel = new RandomAccessFile(path, \"r\").getChannel();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      File file = new File(path);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = new FileInputStream(file);\n      } else {\n        // optimized seek using RandomAccessFile:\n        size = file.length();\n        final long seekTo = randomSeekPos(random, size);\n        final FileChannel channel = new RandomAccessFile(path, \"r\").getChannel();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      final long skipTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + skipTo + \" on open\");\n      }\n      is.skip(skipTo);\n    }\n    \n    int b;\n    do {\n      b = is.read();\n    } while (b >= 0 && b != 13 && b != 10);\n    CharsetDecoder decoder = Charset.forName(\"UTF-8\").newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n    reader.readLine();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      File file = new File(path);\n      size = file.length();\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = new FileInputStream(file);\n      } else {\n        // optimized seek using RandomAccessFile:\n        seekTo = randomSeekPos(random, size);\n        final FileChannel channel = new RandomAccessFile(path, \"r\").getChannel();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      File file = new File(path);\n      size = file.length();\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = new FileInputStream(file);\n      } else {\n        // optimized seek using RandomAccessFile:\n        seekTo = randomSeekPos(random, size);\n        final FileChannel channel = new RandomAccessFile(path, \"r\").getChannel();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      File file = new File(path);\n      size = file.length();\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = new FileInputStream(file);\n      } else {\n        // optimized seek using RandomAccessFile:\n        seekTo = randomSeekPos(random, size);\n        final FileChannel channel = new RandomAccessFile(path, \"r\").getChannel();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      File file = new File(path);\n      size = file.length();\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = new FileInputStream(file);\n      } else {\n        // optimized seek using RandomAccessFile:\n        seekTo = randomSeekPos(random, size);\n        final FileChannel channel = new RandomAccessFile(path, \"r\").getChannel();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      Path file = Paths.get(path);\n      size = Files.size(file);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = Files.newInputStream(file);\n      } else {\n        // optimized seek using SeekableByteChannel\n        seekTo = randomSeekPos(random, size);\n        final SeekableByteChannel channel = Files.newByteChannel(file);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      File file = new File(path);\n      size = file.length();\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = new FileInputStream(file);\n      } else {\n        // optimized seek using RandomAccessFile:\n        seekTo = randomSeekPos(random, size);\n        final FileChannel channel = new RandomAccessFile(path, \"r\").getChannel();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if it's not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      Path file = Paths.get(path);\n      size = Files.size(file);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = Files.newInputStream(file);\n      } else {\n        // optimized seek using SeekableByteChannel\n        seekTo = randomSeekPos(random, size);\n        final SeekableByteChannel channel = Files.newByteChannel(file);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if its not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      Path file = Paths.get(path);\n      size = Files.size(file);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = Files.newInputStream(file);\n      } else {\n        // optimized seek using SeekableByteChannel\n        seekTo = randomSeekPos(random, size);\n        final SeekableByteChannel channel = Files.newByteChannel(file);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"261bc548c130304500988d5439455607f5cc79be","date":1587485357,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#open(Random).mjava","sourceNew":"  private synchronized void open() throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n\n    // true if the InputStream is not already randomly seek'd after the if/else block below:\n    boolean needSkip;\n    boolean skipFirstLineFragment = false;\n    \n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if it's not in classpath, we load it as absolute filesystem path (e.g. Jenkins' home dir)\n      Path file = Paths.get(path);\n      size = Files.size(file);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and seek to one of the pre-computed skip points:\n        is = Files.newInputStream(file);\n        needSkip = true;\n      } else {\n        // file is not compressed: optimized seek using SeekableByteChannel\n        seekTo = randomSeekPos(random, size);\n        final SeekableByteChannel channel = Files.newByteChannel(file);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n\n        // we (likely) seeked to the middle of a line:\n        skipFirstLineFragment = true;\n\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n      needSkip = true;\n    }\n\n    if (needSkip) {\n\n      // LUCENE-9191: use the optimized (pre-computed, using dev-tools/scripts/create_line_file_docs.py)\n      // seek file, so we can seek in a gzip'd file\n\n      int index = path.lastIndexOf('.');\n      if (index == -1) {\n        throw new IllegalArgumentException(\"could not determine extension for path \\\"\" + path + \"\\\"\");\n      }\n\n      // e.g. foo.txt --> foo.seek, foo.txt.gz --> foo.txt.seek\n      String seekFilePath = path.substring(0, index) + \".seek\";\n      InputStream seekIS = getClass().getResourceAsStream(seekFilePath);\n      if (seekIS == null) {\n        seekIS = Files.newInputStream(Paths.get(seekFilePath));\n      }\n\n      try (BufferedReader reader = new BufferedReader(new InputStreamReader(seekIS,\n                                                                    StandardCharsets.UTF_8))) {\n        List<Long> skipPoints = new ArrayList<>();\n\n        // explicitly insert implicit 0 as the first skip point:\n        skipPoints.add(0L);\n        \n        while (true) {\n          String line = reader.readLine();\n          if (line == null) {\n            break;\n          }\n          skipPoints.add(Long.parseLong(line.trim()));\n        }\n\n        seekTo = skipPoints.get(random.nextInt(skipPoints.size()));\n\n        // dev-tools/scripts/create_line_file_docs.py ensures this is a \"safe\" skip point, and we\n        // can begin gunziping from here:\n        is.skip(seekTo);\n        is = new GZIPInputStream(is);\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n        }\n      }\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (skipFirstLineFragment) {\n      // read until end of line:\n      reader.readLine();\n    }\n  }\n\n","sourceOld":"  private synchronized void open(Random random) throws IOException {\n    InputStream is = getClass().getResourceAsStream(path);\n    boolean needSkip = true;\n    long size = 0L, seekTo = 0L;\n    if (is == null) {\n      // if it's not in classpath, we load it as absolute filesystem path (e.g. Hudson's home dir)\n      Path file = Paths.get(path);\n      size = Files.size(file);\n      if (path.endsWith(\".gz\")) {\n        // if it is a gzip file, we need to use InputStream and slowly skipTo:\n        is = Files.newInputStream(file);\n      } else {\n        // optimized seek using SeekableByteChannel\n        seekTo = randomSeekPos(random, size);\n        final SeekableByteChannel channel = Files.newByteChannel(file);\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: file seek to fp=\" + seekTo + \" on open\");\n        }\n        channel.position(seekTo);\n        is = Channels.newInputStream(channel);\n        needSkip = false;\n      }\n    } else {\n      // if the file comes from Classpath:\n      size = is.available();\n    }\n    \n    if (path.endsWith(\".gz\")) {\n      is = new GZIPInputStream(is);\n      // guestimate:\n      size *= 2.8;\n    }\n    \n    // If we only have an InputStream, we need to seek now,\n    // but this seek is a scan, so very inefficient!!!\n    if (needSkip) {\n      seekTo = randomSeekPos(random, size);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: LineFileDocs: stream skip to fp=\" + seekTo + \" on open\");\n      }\n      is.skip(seekTo);\n    }\n    \n    // if we seeked somewhere, read until newline char\n    if (seekTo > 0L) {\n      int b;\n      do {\n        b = is.read();\n      } while (b >= 0 && b != 13 && b != 10);\n    }\n    \n    CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n        .onMalformedInput(CodingErrorAction.REPORT)\n        .onUnmappableCharacter(CodingErrorAction.REPORT);\n    reader = new BufferedReader(new InputStreamReader(is, decoder), BUFFER_SIZE);\n    \n    if (seekTo > 0L) {\n      // read one more line, to make sure we are not inside a Windows linebreak (\\r\\n):\n      reader.readLine();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["26c5e07e414b7d1aeed5448cbd713ba76fc5e7ed","7d89d7e4e5101347833eea558851bf4209218619"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["f4abec28b874149a7223e32cc7a01704c27790de"],"bec980e97bb70b407220acaab91a516063e4adb9":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"26c5e07e414b7d1aeed5448cbd713ba76fc5e7ed":["1bcdad5ed59ddef632dd7c1ea71358a18c35e167"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"261bc548c130304500988d5439455607f5cc79be":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"f4abec28b874149a7223e32cc7a01704c27790de":["7d89d7e4e5101347833eea558851bf4209218619"],"7d89d7e4e5101347833eea558851bf4209218619":["26c5e07e414b7d1aeed5448cbd713ba76fc5e7ed"],"1bcdad5ed59ddef632dd7c1ea71358a18c35e167":["bec980e97bb70b407220acaab91a516063e4adb9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["261bc548c130304500988d5439455607f5cc79be"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["261bc548c130304500988d5439455607f5cc79be"],"bec980e97bb70b407220acaab91a516063e4adb9":["1bcdad5ed59ddef632dd7c1ea71358a18c35e167"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["bec980e97bb70b407220acaab91a516063e4adb9"],"26c5e07e414b7d1aeed5448cbd713ba76fc5e7ed":["5eb2511ababf862ea11e10761c70ee560cd84510","7d89d7e4e5101347833eea558851bf4209218619"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"261bc548c130304500988d5439455607f5cc79be":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7d89d7e4e5101347833eea558851bf4209218619":["5eb2511ababf862ea11e10761c70ee560cd84510","f4abec28b874149a7223e32cc7a01704c27790de"],"f4abec28b874149a7223e32cc7a01704c27790de":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"1bcdad5ed59ddef632dd7c1ea71358a18c35e167":["26c5e07e414b7d1aeed5448cbd713ba76fc5e7ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}