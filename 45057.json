{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/Node#toTuple(String,String,int,Traversal).mjava","commits":[{"id":"afdf6ff5b1319d8ae254212f1203a6233ed3e1dc","date":1461010196,"type":0,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/Node#toTuple(String,String,int,Traversal).mjava","pathOld":"/dev/null","sourceNew":"  public Tuple toTuple(String collection, String field, int level, Traversal traversal) {\n    Map map = new HashMap();\n\n    map.put(\"node\", id);\n    map.put(\"collection\", collection);\n    map.put(\"field\", field);\n    map.put(\"level\", level);\n\n    boolean prependCollection = traversal.isMultiCollection();\n    List<String> cols = traversal.getCollections();\n\n    if(ancestors != null) {\n      List<String> l = new ArrayList();\n      for(String ancestor : ancestors) {\n        String[] ancestorParts = ancestor.split(\"\\\\^\");\n\n        if(prependCollection) {\n          //prepend the collection\n          int colIndex = Integer.parseInt(ancestorParts[0]);\n          l.add(cols.get(colIndex)+\"/\"+ancestorParts[1]);\n        } else {\n          // Use only the ancestor id.\n          l.add(ancestorParts[1]);\n        }\n      }\n\n      map.put(\"ancestors\", l);\n    }\n\n    if(metrics != null) {\n      for(Metric metric : metrics) {\n        map.put(metric.getIdentifier(), metric.getValue());\n      }\n    }\n\n    return new Tuple(map);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e15955b4980562a0c1c81d08654904f3fadb83b","date":1461068916,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/Node#toTuple(String,String,int,Traversal).mjava","pathOld":"/dev/null","sourceNew":"  public Tuple toTuple(String collection, String field, int level, Traversal traversal) {\n    Map map = new HashMap();\n\n    map.put(\"node\", id);\n    map.put(\"collection\", collection);\n    map.put(\"field\", field);\n    map.put(\"level\", level);\n\n    boolean prependCollection = traversal.isMultiCollection();\n    List<String> cols = traversal.getCollections();\n\n    if(ancestors != null) {\n      List<String> l = new ArrayList();\n      for(String ancestor : ancestors) {\n        String[] ancestorParts = ancestor.split(\"\\\\^\");\n\n        if(prependCollection) {\n          //prepend the collection\n          int colIndex = Integer.parseInt(ancestorParts[0]);\n          l.add(cols.get(colIndex)+\"/\"+ancestorParts[1]);\n        } else {\n          // Use only the ancestor id.\n          l.add(ancestorParts[1]);\n        }\n      }\n\n      map.put(\"ancestors\", l);\n    }\n\n    if(metrics != null) {\n      for(Metric metric : metrics) {\n        map.put(metric.getIdentifier(), metric.getValue());\n      }\n    }\n\n    return new Tuple(map);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/Node#toTuple(String,String,int,Traversal).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/Node#toTuple(String,String,int,Traversal).mjava","sourceNew":"  public Tuple toTuple(String collection, String field, int level, Traversal traversal) {\n    Tuple tuple = new Tuple();\n\n    tuple.put(\"node\", id);\n    tuple.put(\"collection\", collection);\n    tuple.put(\"field\", field);\n    tuple.put(\"level\", level);\n\n    boolean prependCollection = traversal.isMultiCollection();\n    List<String> cols = traversal.getCollections();\n\n    if(ancestors != null) {\n      List<String> l = new ArrayList();\n      for(String ancestor : ancestors) {\n        String[] ancestorParts = ancestor.split(\"\\\\^\");\n\n        if(prependCollection) {\n          //prepend the collection\n          int colIndex = Integer.parseInt(ancestorParts[0]);\n          l.add(cols.get(colIndex)+\"/\"+ancestorParts[1]);\n        } else {\n          // Use only the ancestor id.\n          l.add(ancestorParts[1]);\n        }\n      }\n\n      tuple.put(\"ancestors\", l);\n    }\n\n    if(metrics != null) {\n      for(Metric metric : metrics) {\n        tuple.put(metric.getIdentifier(), metric.getValue());\n      }\n    }\n\n    return tuple;\n  }\n\n","sourceOld":"  public Tuple toTuple(String collection, String field, int level, Traversal traversal) {\n    Map map = new HashMap();\n\n    map.put(\"node\", id);\n    map.put(\"collection\", collection);\n    map.put(\"field\", field);\n    map.put(\"level\", level);\n\n    boolean prependCollection = traversal.isMultiCollection();\n    List<String> cols = traversal.getCollections();\n\n    if(ancestors != null) {\n      List<String> l = new ArrayList();\n      for(String ancestor : ancestors) {\n        String[] ancestorParts = ancestor.split(\"\\\\^\");\n\n        if(prependCollection) {\n          //prepend the collection\n          int colIndex = Integer.parseInt(ancestorParts[0]);\n          l.add(cols.get(colIndex)+\"/\"+ancestorParts[1]);\n        } else {\n          // Use only the ancestor id.\n          l.add(ancestorParts[1]);\n        }\n      }\n\n      map.put(\"ancestors\", l);\n    }\n\n    if(metrics != null) {\n      for(Metric metric : metrics) {\n        map.put(metric.getIdentifier(), metric.getValue());\n      }\n    }\n\n    return new Tuple(map);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d","date":1592006776,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/Node#toTuple(String,String,int,Traversal).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/Node#toTuple(String,String,int,Traversal).mjava","sourceNew":"  public Tuple toTuple(String collection, String field, int level, Traversal traversal) {\n    Tuple tuple = new Tuple();\n\n    tuple.put(\"node\", id);\n    tuple.put(\"collection\", collection);\n    tuple.put(\"field\", field);\n    tuple.put(\"level\", level);\n\n    boolean prependCollection = traversal.isMultiCollection();\n    List<String> cols = traversal.getCollections();\n\n    if(ancestors != null) {\n      List<String> l = new ArrayList<>();\n      for(String ancestor : ancestors) {\n        String[] ancestorParts = ancestor.split(\"\\\\^\");\n\n        if(prependCollection) {\n          //prepend the collection\n          int colIndex = Integer.parseInt(ancestorParts[0]);\n          l.add(cols.get(colIndex)+\"/\"+ancestorParts[1]);\n        } else {\n          // Use only the ancestor id.\n          l.add(ancestorParts[1]);\n        }\n      }\n\n      tuple.put(\"ancestors\", l);\n    }\n\n    if(metrics != null) {\n      for(Metric metric : metrics) {\n        tuple.put(metric.getIdentifier(), metric.getValue());\n      }\n    }\n\n    return tuple;\n  }\n\n","sourceOld":"  public Tuple toTuple(String collection, String field, int level, Traversal traversal) {\n    Tuple tuple = new Tuple();\n\n    tuple.put(\"node\", id);\n    tuple.put(\"collection\", collection);\n    tuple.put(\"field\", field);\n    tuple.put(\"level\", level);\n\n    boolean prependCollection = traversal.isMultiCollection();\n    List<String> cols = traversal.getCollections();\n\n    if(ancestors != null) {\n      List<String> l = new ArrayList();\n      for(String ancestor : ancestors) {\n        String[] ancestorParts = ancestor.split(\"\\\\^\");\n\n        if(prependCollection) {\n          //prepend the collection\n          int colIndex = Integer.parseInt(ancestorParts[0]);\n          l.add(cols.get(colIndex)+\"/\"+ancestorParts[1]);\n        } else {\n          // Use only the ancestor id.\n          l.add(ancestorParts[1]);\n        }\n      }\n\n      tuple.put(\"ancestors\", l);\n    }\n\n    if(metrics != null) {\n      for(Metric metric : metrics) {\n        tuple.put(metric.getIdentifier(), metric.getValue());\n      }\n    }\n\n    return tuple;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"afdf6ff5b1319d8ae254212f1203a6233ed3e1dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["804a8d5358fe7b7563b85ee7838714d720b89272"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0e15955b4980562a0c1c81d08654904f3fadb83b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","afdf6ff5b1319d8ae254212f1203a6233ed3e1dc"],"804a8d5358fe7b7563b85ee7838714d720b89272":["0e15955b4980562a0c1c81d08654904f3fadb83b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"]},"commit2Childs":{"afdf6ff5b1319d8ae254212f1203a6233ed3e1dc":["0e15955b4980562a0c1c81d08654904f3fadb83b"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["afdf6ff5b1319d8ae254212f1203a6233ed3e1dc","0e15955b4980562a0c1c81d08654904f3fadb83b"],"0e15955b4980562a0c1c81d08654904f3fadb83b":["804a8d5358fe7b7563b85ee7838714d720b89272"],"804a8d5358fe7b7563b85ee7838714d720b89272":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}