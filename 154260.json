{"path":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","commits":[{"id":"eeeea2295d6355a29e259130a5c48ace73022d7c","date":1426569216,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9d62f72d1c60d2be239222de52d5e7b516da5f6f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a7a7509102c58cf4f57c425a621aaa20575804b2","date":1427264724,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","sourceNew":"  @Override\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","sourceOld":"  @Override\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d62f72d1c60d2be239222de52d5e7b516da5f6f","date":1428554550,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","sourceNew":"  @Override\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","sourceOld":"  @Override\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","bugFix":["eeeea2295d6355a29e259130a5c48ace73022d7c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","sourceNew":"  @Override\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"{} contains default value: {}\", replacementField.getName(), replacementField.getDefaultValue());\n            }\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"{} is required in this schema\", replacementField.getName());\n            }\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","sourceOld":"  @Override\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#replaceFieldType(String,String,Map[String,Object]).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"{} contains default value: {}\", replacementField.getName(), replacementField.getDefaultValue());\n            }\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"{} is required in this schema\", replacementField.getName());\n            }\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","sourceOld":"  @Override\n  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      // clone data structures before modifying them\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      // Rebuild fields of the type being replaced\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          // Drop the old field\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          // Add the replacement field\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); // Save the new field to be added after iteration is finished\n          if (null != replacementField.getDefaultValue()) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"{} contains default value: {}\", replacementField.getName(), replacementField.getDefaultValue());\n            }\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"{} is required in this schema\", replacementField.getName());\n            }\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      // Remove copy fields where the target is of the type being replaced; remember them to rebuild\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); // zero out target count\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      // Rebuild dynamic fields of the type being replaced\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      // Find dynamic copy fields where the destination field's type is being replaced\n      // or the source dynamic base's type is being replaced; remember them to rebuild\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          // don't add this dynamic copy field to newDynamicCopyFields - effectively removing it\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      // Rebuild affected dynamic copy fields\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a7a7509102c58cf4f57c425a621aaa20575804b2"],"9d62f72d1c60d2be239222de52d5e7b516da5f6f":["a7a7509102c58cf4f57c425a621aaa20575804b2"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["9df8125ba9193a2e2e285ed92157810b1952a244"],"a7a7509102c58cf4f57c425a621aaa20575804b2":["eeeea2295d6355a29e259130a5c48ace73022d7c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"9df8125ba9193a2e2e285ed92157810b1952a244":["9d62f72d1c60d2be239222de52d5e7b516da5f6f"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"9d62f72d1c60d2be239222de52d5e7b516da5f6f":["9df8125ba9193a2e2e285ed92157810b1952a244"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["a7a7509102c58cf4f57c425a621aaa20575804b2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","eeeea2295d6355a29e259130a5c48ace73022d7c"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a7a7509102c58cf4f57c425a621aaa20575804b2":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9d62f72d1c60d2be239222de52d5e7b516da5f6f"],"9df8125ba9193a2e2e285ed92157810b1952a244":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}