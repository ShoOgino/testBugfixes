{"path":"lucene/core/src/java/org/apache/lucene/util/packed/PagedGrowableWriter#resize(long).mjava","commits":[{"id":"f375a9203c9124207e176f4dc59bd8e832b239a0","date":1370270173,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PagedGrowableWriter#resize(long).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a new {@link PagedGrowableWriter} of size <code>newSize</code>\n   *  based on the content of this buffer. This method is much more efficient\n   *  than creating a new {@link PagedGrowableWriter} and copying values one by\n   *  one. */\n  public PagedGrowableWriter resize(long newSize) {\n    final PagedGrowableWriter newWriter = new PagedGrowableWriter(newSize, pageSize(), startBitsPerValue, acceptableOverheadRatio, false);\n    final int numCommonPages = Math.min(newWriter.subWriters.length, subWriters.length);\n    final long[] copyBuffer = new long[1024];\n    for (int i = 0; i < newWriter.subWriters.length; ++i) {\n      final int valueCount = i == newWriter.subWriters.length - 1 ? lastPageSize(newSize) : pageSize();\n      final int bpv = i < numCommonPages ? subWriters[i].getBitsPerValue() : startBitsPerValue;\n      newWriter.subWriters[i] = new GrowableWriter(bpv, valueCount, acceptableOverheadRatio);\n      if (i < numCommonPages) {\n        final int copyLength = Math.min(valueCount, subWriters[i].size());\n        PackedInts.copy(subWriters[i], 0, newWriter.subWriters[i].getMutable(), 0, copyLength, copyBuffer);\n      }\n    }\n    return newWriter;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8ee441d3e61e4669e10566a8d028a41333642b7","date":1371579547,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PagedGrowableWriter#resize(long).mjava","sourceNew":null,"sourceOld":"  /** Create a new {@link PagedGrowableWriter} of size <code>newSize</code>\n   *  based on the content of this buffer. This method is much more efficient\n   *  than creating a new {@link PagedGrowableWriter} and copying values one by\n   *  one. */\n  public PagedGrowableWriter resize(long newSize) {\n    final PagedGrowableWriter newWriter = new PagedGrowableWriter(newSize, pageSize(), startBitsPerValue, acceptableOverheadRatio, false);\n    final int numCommonPages = Math.min(newWriter.subWriters.length, subWriters.length);\n    final long[] copyBuffer = new long[1024];\n    for (int i = 0; i < newWriter.subWriters.length; ++i) {\n      final int valueCount = i == newWriter.subWriters.length - 1 ? lastPageSize(newSize) : pageSize();\n      final int bpv = i < numCommonPages ? subWriters[i].getBitsPerValue() : startBitsPerValue;\n      newWriter.subWriters[i] = new GrowableWriter(bpv, valueCount, acceptableOverheadRatio);\n      if (i < numCommonPages) {\n        final int copyLength = Math.min(valueCount, subWriters[i].size());\n        PackedInts.copy(subWriters[i], 0, newWriter.subWriters[i].getMutable(), 0, copyLength, copyBuffer);\n      }\n    }\n    return newWriter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":4,"author":"Han Jiang","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PagedGrowableWriter#resize(long).mjava","sourceNew":null,"sourceOld":"  /** Create a new {@link PagedGrowableWriter} of size <code>newSize</code>\n   *  based on the content of this buffer. This method is much more efficient\n   *  than creating a new {@link PagedGrowableWriter} and copying values one by\n   *  one. */\n  public PagedGrowableWriter resize(long newSize) {\n    final PagedGrowableWriter newWriter = new PagedGrowableWriter(newSize, pageSize(), startBitsPerValue, acceptableOverheadRatio, false);\n    final int numCommonPages = Math.min(newWriter.subWriters.length, subWriters.length);\n    final long[] copyBuffer = new long[1024];\n    for (int i = 0; i < newWriter.subWriters.length; ++i) {\n      final int valueCount = i == newWriter.subWriters.length - 1 ? lastPageSize(newSize) : pageSize();\n      final int bpv = i < numCommonPages ? subWriters[i].getBitsPerValue() : startBitsPerValue;\n      newWriter.subWriters[i] = new GrowableWriter(bpv, valueCount, acceptableOverheadRatio);\n      if (i < numCommonPages) {\n        final int copyLength = Math.min(valueCount, subWriters[i].size());\n        PackedInts.copy(subWriters[i], 0, newWriter.subWriters[i].getMutable(), 0, copyLength, copyBuffer);\n      }\n    }\n    return newWriter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":["f375a9203c9124207e176f4dc59bd8e832b239a0","c8ee441d3e61e4669e10566a8d028a41333642b7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c8ee441d3e61e4669e10566a8d028a41333642b7":["f375a9203c9124207e176f4dc59bd8e832b239a0"],"f375a9203c9124207e176f4dc59bd8e832b239a0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c8ee441d3e61e4669e10566a8d028a41333642b7"]},"commit2Childs":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f375a9203c9124207e176f4dc59bd8e832b239a0"],"f375a9203c9124207e176f4dc59bd8e832b239a0":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c8ee441d3e61e4669e10566a8d028a41333642b7"],"c8ee441d3e61e4669e10566a8d028a41333642b7":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}