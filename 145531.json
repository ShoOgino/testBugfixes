{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","commits":[{"id":"1d0561cea94adff1867218e77bb763c7583be279","date":1324334341,"type":1,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/ElevationComparatorSource[QueryElevationComponent]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return docVal(doc) - bottomVal;\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader.fields();\n        Terms terms = fields.terms(fieldname);\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(null, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      \n      FieldCache.DocTermsIndex idIndex;\n      private final int[] values = new int[numHits];\n      int bottomVal;\n      private final BytesRef tempBR = new BytesRef();\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        BytesRef id = idIndex.getTerm(doc, tempBR);\n        Integer prio = priority.get(id);\n        return prio == null ? 0 : prio.intValue();\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return docVal(doc) - bottomVal;\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader, fieldname);\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5fe6ef04a47e9838def5339eb5d567e5a404554d","date":1324490752,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return docVal(doc) - bottomVal;\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader.fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(fieldname);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader.getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return docVal(doc) - bottomVal;\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader.fields();\n        Terms terms = fields.terms(fieldname);\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(null, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["02331260bb246364779cb6f04919ca47900d01bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return docVal(doc) - bottomVal;\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(fieldname);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return docVal(doc) - bottomVal;\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader.fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(fieldname);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader.getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return docVal(doc) - bottomVal;\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(fieldname);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return docVal(doc) - bottomVal;\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader.fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(fieldname);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader.getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe","date":1332176888,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return docVal(doc) - bottomVal;\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(fieldname);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        InvertedFields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        InvertedFields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb02351ae2b114dd41585916d1e35fb2cff98fb0","date":1337171337,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) throws IOException {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) throws IOException {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) throws IOException {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":["1d0561cea94adff1867218e77bb763c7583be279","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) throws IOException {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) throws IOException {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, 0);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":["5fe6ef04a47e9838def5339eb5d567e5a404554d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, 0);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, 0);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, 0);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, 0);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7615b855702e008d91a95a2578bf05d27372f599","date":1389802891,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27ab7b234eab0cbc020836989b96ed430e1065bb","date":1389894025,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareDocToValue(int doc, Integer valueObj) {\n        final int value = valueObj.intValue();\n        final int docValue = docVal(doc);\n        return docValue - value;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<String>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRef term = new BytesRef();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term)) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":["1d0561cea94adff1867218e77bb763c7583be279","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new FieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      public FieldComparator setNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return this;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return this;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            if (postingsEnum != null) {\n              int docId = postingsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private DocsEnum docsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);\n            if (docsEnum != null) {\n              int docId = docsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            if (postingsEnum != null) {\n              int docId = postingsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            if (postingsEnum != null) {\n              int docId = postingsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5311f0bff57ce15a23909f4cfb953773630534","date":1424827033,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            // nocommit: check, maybe just remove null check?\n            if (postingsEnum != null) {\n              int docId = postingsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            if (postingsEnum != null) {\n              int docId = postingsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb77aeaebb451427f825381042f68a6916417d1d","date":1427819930,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            // nocommit: check, maybe just remove null check?\n            if (postingsEnum != null) {\n              int docId = postingsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b4e3cd382d0d075a0f1725649c084bb6510c483","date":1428096423,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            if (postingsEnum != null) {\n              int docId = postingsEnum.nextDoc();\n              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n              termValues[ordSet.put(docId)] = term.toBytesRef();\n              seen.add(id);\n              assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n            }\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private TermsEnum termsEnum;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        termsEnum = terms.iterator(termsEnum);\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(liveDocs, postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03e38c6374c23083c93e212a9498ff0a9c255476","date":1484767039,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","date":1497408244,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Terms terms = context.reader().terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Terms terms = context.reader().terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Terms terms = context.reader().terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Fields fields = context.reader().fields();\n        if (fields == null) return;\n        Terms terms = fields.terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ad458affd82a1d762eb506003907d9363a333cb","date":1528558344,"type":3,"author":"broustant","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"    @Override\n    public FieldComparator<Integer> newComparator(String fieldName, final int numHits, int sortPos, boolean reversed) {\n      return new SimpleFieldComparator<Integer>() {\n        final int[] values = new int[numHits];\n        int bottomVal;\n        int topVal;\n\n        int docBase;\n        boolean hasElevatedDocsThisSegment;\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          docBase = context.docBase;\n          // ascertain if hasElevatedDocsThisSegment\n          final int idx = Arrays.binarySearch(sortedElevatedDocIds, docBase);\n          if (idx < 0) {\n            //first doc in segment isn't elevated (typical).  Maybe another is?\n            int nextIdx = -idx - 1;\n            if (nextIdx < sortedElevatedDocIds.length) {\n              int nextElevatedDocId = sortedElevatedDocIds[nextIdx];\n              if (nextElevatedDocId > docBase + context.reader().maxDoc()) {\n                hasElevatedDocsThisSegment = false;\n                return;\n              }\n            }\n          }\n          hasElevatedDocsThisSegment = true;\n        }\n\n        @Override\n        public int compare(int slot1, int slot2) {\n          return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n        }\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public void setTopValue(Integer value) {\n          topVal = value;\n        }\n\n        private int docVal(int doc) {\n          if (!hasElevatedDocsThisSegment) {\n            assert elevatedWithPriority.containsKey(docBase + doc) == false;\n            return -1;\n          } else if (useConfiguredElevatedOrder) {\n            return elevatedWithPriority.getOrDefault(docBase + doc, -1);\n          } else {\n            return elevatedWithPriority.containsKey(docBase + doc) ? 1 : -1;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return bottomVal - docVal(doc);\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public Integer value(int slot) {\n          return values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          final int docValue = docVal(doc);\n          return topVal - docValue;  // values will be small enough that there is no overflow concern\n        }\n      };\n    }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Terms terms = context.reader().terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"    @Override\n    public FieldComparator<Integer> newComparator(String fieldName, final int numHits, int sortPos, boolean reversed) {\n      return new SimpleFieldComparator<Integer>() {\n        final int[] values = new int[numHits];\n        int bottomVal;\n        int topVal;\n\n        int docBase;\n        boolean hasElevatedDocsThisSegment;\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          docBase = context.docBase;\n          // ascertain if hasElevatedDocsThisSegment\n          final int idx = Arrays.binarySearch(sortedElevatedDocIds, docBase);\n          if (idx < 0) {\n            //first doc in segment isn't elevated (typical).  Maybe another is?\n            int nextIdx = -idx - 1;\n            if (nextIdx < sortedElevatedDocIds.length) {\n              int nextElevatedDocId = sortedElevatedDocIds[nextIdx];\n              if (nextElevatedDocId > docBase + context.reader().maxDoc()) {\n                hasElevatedDocsThisSegment = false;\n                return;\n              }\n            }\n          }\n          hasElevatedDocsThisSegment = true;\n        }\n\n        @Override\n        public int compare(int slot1, int slot2) {\n          return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n        }\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public void setTopValue(Integer value) {\n          topVal = value;\n        }\n\n        private int docVal(int doc) {\n          if (!hasElevatedDocsThisSegment) {\n            assert elevatedWithPriority.containsKey(docBase + doc) == false;\n            return -1;\n          } else if (useConfiguredElevatedOrder) {\n            return elevatedWithPriority.getOrDefault(docBase + doc, -1);\n          } else {\n            return elevatedWithPriority.containsKey(docBase + doc) ? 1 : -1;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return bottomVal - docVal(doc);\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public Integer value(int slot) {\n          return values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          final int docValue = docVal(doc);\n          return topVal - docValue;  // values will be small enough that there is no overflow concern\n        }\n      };\n    }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Terms terms = context.reader().terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"    @Override\n    public FieldComparator<Integer> newComparator(String fieldName, final int numHits, int sortPos, boolean reversed) {\n      return new SimpleFieldComparator<Integer>() {\n        final int[] values = new int[numHits];\n        int bottomVal;\n        int topVal;\n\n        int docBase;\n        boolean hasElevatedDocsThisSegment;\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          docBase = context.docBase;\n          // ascertain if hasElevatedDocsThisSegment\n          final int idx = Arrays.binarySearch(sortedElevatedDocIds, docBase);\n          if (idx < 0) {\n            //first doc in segment isn't elevated (typical).  Maybe another is?\n            int nextIdx = -idx - 1;\n            if (nextIdx < sortedElevatedDocIds.length) {\n              int nextElevatedDocId = sortedElevatedDocIds[nextIdx];\n              if (nextElevatedDocId > docBase + context.reader().maxDoc()) {\n                hasElevatedDocsThisSegment = false;\n                return;\n              }\n            }\n          }\n          hasElevatedDocsThisSegment = true;\n        }\n\n        @Override\n        public int compare(int slot1, int slot2) {\n          return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n        }\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public void setTopValue(Integer value) {\n          topVal = value;\n        }\n\n        private int docVal(int doc) {\n          if (!hasElevatedDocsThisSegment) {\n            assert elevatedWithPriority.containsKey(docBase + doc) == false;\n            return -1;\n          } else if (useConfiguredElevatedOrder) {\n            return elevatedWithPriority.getOrDefault(docBase + doc, -1);\n          } else {\n            return elevatedWithPriority.containsKey(docBase + doc) ? 1 : -1;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return bottomVal - docVal(doc);\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public Integer value(int slot) {\n          return values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          final int docValue = docVal(doc);\n          return topVal - docValue;  // values will be small enough that there is no overflow concern\n        }\n      };\n    }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, final int numHits, int sortPos, boolean reversed) {\n    return new SimpleFieldComparator<Integer>() {\n      private final int[] values = new int[numHits];\n      private int bottomVal;\n      private int topVal;\n      private PostingsEnum postingsEnum;\n      Set<String> seen = new HashSet<>(elevations.ids.size());\n\n      @Override\n      public int compare(int slot1, int slot2) {\n        return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomVal = values[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        topVal = value.intValue();\n      }\n\n      private int docVal(int doc) {\n        if (ordSet.size() > 0) {\n          int slot = ordSet.find(doc);\n          if (slot >= 0) {\n            BytesRef id = termValues[slot];\n            Integer prio = elevations.priority.get(id);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n        return 0;\n      }\n\n      @Override\n      public int compareBottom(int doc) {\n        return bottomVal - docVal(doc);\n      }\n\n      @Override\n      public void copy(int slot, int doc) {\n        values[slot] = docVal(doc);\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have\n        ordSet.clear();\n        Terms terms = context.reader().terms(idField);\n        if (terms == null) return;\n        TermsEnum termsEnum = terms.iterator();\n        BytesRefBuilder term = new BytesRefBuilder();\n        Bits liveDocs = context.reader().getLiveDocs();\n\n        for (String id : elevations.ids) {\n          term.copyChars(id);\n          if (seen.contains(id) == false  && termsEnum.seekExact(term.get())) {\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int docId = postingsEnum.nextDoc();\n            while (docId != DocIdSetIterator.NO_MORE_DOCS && liveDocs != null && liveDocs.get(docId) == false) {\n              docId = postingsEnum.nextDoc();\n            }\n            if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted\n            termValues[ordSet.put(docId)] = term.toBytesRef();\n            seen.add(id);\n            assert postingsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n          }\n        }\n      }\n\n      @Override\n      public Integer value(int slot) {\n        return values[slot];\n      }\n\n      @Override\n      public int compareTop(int doc) {\n        final int docValue = docVal(doc);\n        return topVal - docValue;  // values will be small enough that there is no overflow concern\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6046c615b67e878b7c0ab9257d01dd759493f06","date":1564997027,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"    @Override\n    public FieldComparator<Integer> newComparator(String fieldName, final int numHits, int sortPos, boolean reversed) {\n      return new SimpleFieldComparator<>() {\n        final int[] values = new int[numHits];\n        int bottomVal;\n        int topVal;\n\n        int docBase;\n        boolean hasElevatedDocsThisSegment;\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) {\n          docBase = context.docBase;\n          // ascertain if hasElevatedDocsThisSegment\n          final int idx = Arrays.binarySearch(sortedElevatedDocIds, docBase);\n          if (idx < 0) {\n            //first doc in segment isn't elevated (typical).  Maybe another is?\n            int nextIdx = -idx - 1;\n            if (nextIdx < sortedElevatedDocIds.length) {\n              int nextElevatedDocId = sortedElevatedDocIds[nextIdx];\n              if (nextElevatedDocId > docBase + context.reader().maxDoc()) {\n                hasElevatedDocsThisSegment = false;\n                return;\n              }\n            }\n          }\n          hasElevatedDocsThisSegment = true;\n        }\n\n        @Override\n        public int compare(int slot1, int slot2) {\n          return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n        }\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public void setTopValue(Integer value) {\n          topVal = value;\n        }\n\n        private int docVal(int doc) {\n          if (!hasElevatedDocsThisSegment) {\n            assert elevatedWithPriority.containsKey(docBase + doc) == false;\n            return -1;\n          } else if (useConfiguredElevatedOrder) {\n            return elevatedWithPriority.getOrDefault(docBase + doc, -1);\n          } else {\n            return elevatedWithPriority.containsKey(docBase + doc) ? 1 : -1;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return bottomVal - docVal(doc);\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public Integer value(int slot) {\n          return values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          final int docValue = docVal(doc);\n          return topVal - docValue;  // values will be small enough that there is no overflow concern\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator<Integer> newComparator(String fieldName, final int numHits, int sortPos, boolean reversed) {\n      return new SimpleFieldComparator<Integer>() {\n        final int[] values = new int[numHits];\n        int bottomVal;\n        int topVal;\n\n        int docBase;\n        boolean hasElevatedDocsThisSegment;\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          docBase = context.docBase;\n          // ascertain if hasElevatedDocsThisSegment\n          final int idx = Arrays.binarySearch(sortedElevatedDocIds, docBase);\n          if (idx < 0) {\n            //first doc in segment isn't elevated (typical).  Maybe another is?\n            int nextIdx = -idx - 1;\n            if (nextIdx < sortedElevatedDocIds.length) {\n              int nextElevatedDocId = sortedElevatedDocIds[nextIdx];\n              if (nextElevatedDocId > docBase + context.reader().maxDoc()) {\n                hasElevatedDocsThisSegment = false;\n                return;\n              }\n            }\n          }\n          hasElevatedDocsThisSegment = true;\n        }\n\n        @Override\n        public int compare(int slot1, int slot2) {\n          return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n        }\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public void setTopValue(Integer value) {\n          topVal = value;\n        }\n\n        private int docVal(int doc) {\n          if (!hasElevatedDocsThisSegment) {\n            assert elevatedWithPriority.containsKey(docBase + doc) == false;\n            return -1;\n          } else if (useConfiguredElevatedOrder) {\n            return elevatedWithPriority.getOrDefault(docBase + doc, -1);\n          } else {\n            return elevatedWithPriority.containsKey(docBase + doc) ? 1 : -1;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return bottomVal - docVal(doc);\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public Integer value(int slot) {\n          return values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          final int docValue = docVal(doc);\n          return topVal - docValue;  // values will be small enough that there is no overflow concern\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","date":1565097295,"type":3,"author":"Jan Hydahl","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.ElevationComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"    @Override\n    public FieldComparator<Integer> newComparator(String fieldName, final int numHits, int sortPos, boolean reversed) {\n      return new SimpleFieldComparator<>() {\n        final int[] values = new int[numHits];\n        int bottomVal;\n        int topVal;\n\n        int docBase;\n        boolean hasElevatedDocsThisSegment;\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) {\n          docBase = context.docBase;\n          // ascertain if hasElevatedDocsThisSegment\n          final int idx = Arrays.binarySearch(sortedElevatedDocIds, docBase);\n          if (idx < 0) {\n            //first doc in segment isn't elevated (typical).  Maybe another is?\n            int nextIdx = -idx - 1;\n            if (nextIdx < sortedElevatedDocIds.length) {\n              int nextElevatedDocId = sortedElevatedDocIds[nextIdx];\n              if (nextElevatedDocId > docBase + context.reader().maxDoc()) {\n                hasElevatedDocsThisSegment = false;\n                return;\n              }\n            }\n          }\n          hasElevatedDocsThisSegment = true;\n        }\n\n        @Override\n        public int compare(int slot1, int slot2) {\n          return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n        }\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public void setTopValue(Integer value) {\n          topVal = value;\n        }\n\n        private int docVal(int doc) {\n          if (!hasElevatedDocsThisSegment) {\n            assert elevatedWithPriority.containsKey(docBase + doc) == false;\n            return -1;\n          } else if (useConfiguredElevatedOrder) {\n            return elevatedWithPriority.getOrDefault(docBase + doc, -1);\n          } else {\n            return elevatedWithPriority.containsKey(docBase + doc) ? 1 : -1;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return bottomVal - docVal(doc);\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public Integer value(int slot) {\n          return values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          final int docValue = docVal(doc);\n          return topVal - docValue;  // values will be small enough that there is no overflow concern\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator<Integer> newComparator(String fieldName, final int numHits, int sortPos, boolean reversed) {\n      return new SimpleFieldComparator<Integer>() {\n        final int[] values = new int[numHits];\n        int bottomVal;\n        int topVal;\n\n        int docBase;\n        boolean hasElevatedDocsThisSegment;\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          docBase = context.docBase;\n          // ascertain if hasElevatedDocsThisSegment\n          final int idx = Arrays.binarySearch(sortedElevatedDocIds, docBase);\n          if (idx < 0) {\n            //first doc in segment isn't elevated (typical).  Maybe another is?\n            int nextIdx = -idx - 1;\n            if (nextIdx < sortedElevatedDocIds.length) {\n              int nextElevatedDocId = sortedElevatedDocIds[nextIdx];\n              if (nextElevatedDocId > docBase + context.reader().maxDoc()) {\n                hasElevatedDocsThisSegment = false;\n                return;\n              }\n            }\n          }\n          hasElevatedDocsThisSegment = true;\n        }\n\n        @Override\n        public int compare(int slot1, int slot2) {\n          return values[slot1] - values[slot2];  // values will be small enough that there is no overflow concern\n        }\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public void setTopValue(Integer value) {\n          topVal = value;\n        }\n\n        private int docVal(int doc) {\n          if (!hasElevatedDocsThisSegment) {\n            assert elevatedWithPriority.containsKey(docBase + doc) == false;\n            return -1;\n          } else if (useConfiguredElevatedOrder) {\n            return elevatedWithPriority.getOrDefault(docBase + doc, -1);\n          } else {\n            return elevatedWithPriority.containsKey(docBase + doc) ? 1 : -1;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return bottomVal - docVal(doc);\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public Integer value(int slot) {\n          return values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          final int docValue = docVal(doc);\n          return topVal - docValue;  // values will be small enough that there is no overflow concern\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["6b4e3cd382d0d075a0f1725649c084bb6510c483"],"5fe6ef04a47e9838def5339eb5d567e5a404554d":["1d0561cea94adff1867218e77bb763c7583be279"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["02331260bb246364779cb6f04919ca47900d01bb","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["03e38c6374c23083c93e212a9498ff0a9c255476"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","7615b855702e008d91a95a2578bf05d27372f599"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5fe6ef04a47e9838def5339eb5d567e5a404554d"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"1d0561cea94adff1867218e77bb763c7583be279":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e6046c615b67e878b7c0ab9257d01dd759493f06":["2ad458affd82a1d762eb506003907d9363a333cb"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"cb5311f0bff57ce15a23909f4cfb953773630534":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["28288370235ed02234a64753cdbf0c6ec096304a","2ad458affd82a1d762eb506003907d9363a333cb"],"6b4e3cd382d0d075a0f1725649c084bb6510c483":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4","cb77aeaebb451427f825381042f68a6916417d1d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2ad458affd82a1d762eb506003907d9363a333cb":["28288370235ed02234a64753cdbf0c6ec096304a"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":["2ad458affd82a1d762eb506003907d9363a333cb","e6046c615b67e878b7c0ab9257d01dd759493f06"],"cb77aeaebb451427f825381042f68a6916417d1d":["cb5311f0bff57ce15a23909f4cfb953773630534"],"ef0d8a69209261514c5739c770bba706c2308450":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["28288370235ed02234a64753cdbf0c6ec096304a","2ad458affd82a1d762eb506003907d9363a333cb"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"901e951cec2e6af4e503209a6721c8834db23279":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe"],"e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"51f5280f31484820499077f41fcdfe92d527d9dc":["901e951cec2e6af4e503209a6721c8834db23279"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["5fe6ef04a47e9838def5339eb5d567e5a404554d","96d207426bd26fa5c1014e26d21d87603aea68b7"],"28288370235ed02234a64753cdbf0c6ec096304a":["03e38c6374c23083c93e212a9498ff0a9c255476","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["0f4464508ee83288c8c4585b533f9faaa93aa314","03e38c6374c23083c93e212a9498ff0a9c255476"],"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"03e38c6374c23083c93e212a9498ff0a9c255476":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["02331260bb246364779cb6f04919ca47900d01bb"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["fb02351ae2b114dd41585916d1e35fb2cff98fb0","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","02331260bb246364779cb6f04919ca47900d01bb"],"7615b855702e008d91a95a2578bf05d27372f599":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","02331260bb246364779cb6f04919ca47900d01bb"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["03e38c6374c23083c93e212a9498ff0a9c255476","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e6046c615b67e878b7c0ab9257d01dd759493f06"],"02331260bb246364779cb6f04919ca47900d01bb":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"5fe6ef04a47e9838def5339eb5d567e5a404554d":["96d207426bd26fa5c1014e26d21d87603aea68b7","5cab9a86bd67202d20b6adc463008c8e982b070a"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"1d0561cea94adff1867218e77bb763c7583be279":["5fe6ef04a47e9838def5339eb5d567e5a404554d"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"e6046c615b67e878b7c0ab9257d01dd759493f06":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["901e951cec2e6af4e503209a6721c8834db23279"],"cb5311f0bff57ce15a23909f4cfb953773630534":["cb77aeaebb451427f825381042f68a6916417d1d"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"6b4e3cd382d0d075a0f1725649c084bb6510c483":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d0561cea94adff1867218e77bb763c7583be279"],"2ad458affd82a1d762eb506003907d9363a333cb":["e6046c615b67e878b7c0ab9257d01dd759493f06","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["ef0d8a69209261514c5739c770bba706c2308450","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe33227f6805edab2036cbb80645cc4e2d1fa424","d6f074e73200c07d54f242d3880a8da5a35ff97b","02331260bb246364779cb6f04919ca47900d01bb"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":[],"cb77aeaebb451427f825381042f68a6916417d1d":["6b4e3cd382d0d075a0f1725649c084bb6510c483"],"ef0d8a69209261514c5739c770bba706c2308450":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"901e951cec2e6af4e503209a6721c8834db23279":["51f5280f31484820499077f41fcdfe92d527d9dc"],"e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"51f5280f31484820499077f41fcdfe92d527d9dc":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"28288370235ed02234a64753cdbf0c6ec096304a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","2ad458affd82a1d762eb506003907d9363a333cb","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["e1a45617f98e5cd25b73e9ae4ea69e0a0edacebe"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","ef0d8a69209261514c5739c770bba706c2308450","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["cb5311f0bff57ce15a23909f4cfb953773630534","6b4e3cd382d0d075a0f1725649c084bb6510c483"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","03e38c6374c23083c93e212a9498ff0a9c255476"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"03e38c6374c23083c93e212a9498ff0a9c255476":["e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","28288370235ed02234a64753cdbf0c6ec096304a","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"7615b855702e008d91a95a2578bf05d27372f599":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["27ab7b234eab0cbc020836989b96ed430e1065bb","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","7615b855702e008d91a95a2578bf05d27372f599"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"02331260bb246364779cb6f04919ca47900d01bb":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","15250ca94ba8ab3bcdd476daf6bf3f3febb92640","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","ef0d8a69209261514c5739c770bba706c2308450","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}